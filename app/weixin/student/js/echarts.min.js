!function (t, e) {
  "function" == typeof define && define.amd ? define([], e) : "object" == typeof module && module.exports ? module.exports = e() : t.echarts = e()
}(this, function () {
  var t, e;
  !function () {
    function i(t, e) {
      if (!e)return t;
      if (0 === t.indexOf(".")) {
        var i = e.split("/"), n = t.split("/"), r = i.length - 1, a = n.length, o = 0, s = 0;
        t:for (var l = 0; a > l; l++)switch (n[l]) {
          case"..":
            if (!(r > o))break t;
            o++, s++;
            break;
          case".":
            s++;
            break;
          default:
            break t
        }
        return i.length = r - o, n = n.slice(s), i.concat(n).join("/")
      }
      return t
    }

    function n(t) {
      function e(e, o) {
        if ("string" == typeof e) {
          var s = n[e];
          return s || (s = a(i(e, t)), n[e] = s), s
        }
        e instanceof Array && (o = o || function () {
        }, o.apply(this, r(e, o, t)))
      }

      var n = {};
      return e
    }

    function r(e, n, r) {
      for (var s = [], l = o[r], c = 0, u = Math.min(e.length, n.length); u > c; c++) {
        var h, d = i(e[c], r);
        switch (d) {
          case"require":
            h = l && l.require || t;
            break;
          case"exports":
            h = l.exports;
            break;
          case"module":
            h = l;
            break;
          default:
            h = a(d)
        }
        s.push(h)
      }
      return s
    }

    function a(t) {
      var e = o[t];
      if (!e)throw new Error("No " + t);
      if (!e.defined) {
        var i = e.factory, n = i.apply(this, r(e.deps || [], i, t));
        "undefined" != typeof n && (e.exports = n), e.defined = 1
      }
      return e.exports
    }

    var o = {};
    e = function (t, e, i) {
      o[t] = {id: t, deps: e, factory: i, defined: 0, exports: {}, require: n(t)}
    }, t = n("")
  }();
  var i = "__dirty", n = "moveTo", r = "transform", a = "ecModel", o = "option", s = "category", l = "inside", c = "stroke", u = "lineWidth", h = "applyTransform", d = "getName", f = "normal", p = "../../echarts", v = "getShallow", m = "getItemModel", g = "concat", y = "createElement", x = "ordinal", _ = "animation", b = "dataToCoord", w = "getItemVisual", S = "dimensions", M = "dataToPoint", T = "radius", C = "getBaseAxis", A = "../../util/graphic", L = "getExtent", P = "getTicks", k = "contain", I = "opacity", z = "position", D = "center", E = "middle", O = "getBoundingRect", R = "getTextColor", B = "getFont", N = "textAlign", G = "textStyle", F = "inherits", V = "indexOf", H = "filter", q = "number", W = "function", Z = "isArray", U = "replace", j = "zlevel", X = "setStyle", Y = "getDataParams", $ = "seriesIndex", Q = "dataIndex", K = "target", J = "mouseout", te = "mouseover", ee = "splice", ie = "series", ne = "length", re = "extend", ae = "remove", oe = "isObject", se = "update", le = "create", ce = "height", ue = "bottom", he = "ignore", de = "storage", fe = "canvasSupported", pe = "getHeight", ve = "getWidth", me = "getModel", ge = "resize", ye = "string", xe = "prototype", _e = "toLowerCase", be = "zrender/core/vector", we = "getData", Se = "getItemStyle", Me = "defaults", Te = "coordinateSystem", Ce = "removeAll", Ae = "extendComponentView", Le = "zrender/core/util", Pe = "require";
  e("echarts/chart/line", [Pe, Le, "../echarts", "./line/LineSeries", "./line/LineView", "../visual/symbol", "../layout/points", "../processor/dataSample", "../component/grid"], function (t) {
    var e = t(Le), i = t("../echarts"), n = i.PRIORITY;
    t("./line/LineSeries"), t("./line/LineView"), i.registerVisual(e.curry(t("../visual/symbol"), "line", "circle", "line")), i.registerLayout(e.curry(t("../layout/points"), "line")), i.registerProcessor(n.PROCESSOR.STATISTIC, e.curry(t("../processor/dataSample"), "line")), t("../component/grid")
  }), e("echarts/chart/radar", [Pe, Le, "../echarts", "../component/radar", "./radar/RadarSeries", "./radar/RadarView", "../visual/dataColor", "../visual/symbol", "./radar/radarLayout", "../processor/dataFilter", "./radar/backwardCompat"], function (t) {
    var e = t(Le), i = t("../echarts");
    t("../component/radar"), t("./radar/RadarSeries"), t("./radar/RadarView"), i.registerVisual(e.curry(t("../visual/dataColor"), "radar")), i.registerVisual(e.curry(t("../visual/symbol"), "radar", "circle", null)), i.registerLayout(t("./radar/radarLayout")), i.registerProcessor(e.curry(t("../processor/dataFilter"), "radar")), i.registerPreprocessor(t("./radar/backwardCompat"))
  }), e("echarts/component/grid", [Pe, "../util/graphic", Le, "../coord/cartesian/Grid", "./axis", "../echarts"], function (t) {
    var e = t("../util/graphic"), i = t(Le);
    t("../coord/cartesian/Grid"), t("./axis"), t("../echarts")[Ae]({
      type: "grid", render: function (t) {
        this.group[Ce](), t.get("show") && this.group.add(new e.Rect({
          shape: t[Te].getRect(),
          style: i[Me]({fill: t.get("backgroundColor")}, t[Se]()),
          silent: !0
        }))
      }
    })
  }), e("echarts/chart/bar", [Pe, Le, "../coord/cartesian/Grid", "./bar/BarSeries", "./bar/BarView", "../layout/barGrid", "../echarts", "../component/grid"], function (t) {
    var e = t(Le);
    t("../coord/cartesian/Grid"), t("./bar/BarSeries"), t("./bar/BarView");
    var i = t("../layout/barGrid"), n = t("../echarts");
    n.registerLayout(e.curry(i, "bar")), n.registerVisual(function (t) {
      t.eachSeriesByType("bar", function (t) {
        var e = t[we]();
        e.setVisual("legendSymbol", "roundRect")
      })
    }), t("../component/grid")
  }), e("echarts/chart/pie", [Pe, Le, "../echarts", "./pie/PieSeries", "./pie/PieView", "../action/createDataSelectAction", "../visual/dataColor", "./pie/pieLayout", "../processor/dataFilter"], function (t) {
    var e = t(Le), i = t("../echarts");
    t("./pie/PieSeries"), t("./pie/PieView"), t("../action/createDataSelectAction")("pie", [{
      type: "pieToggleSelect",
      event: "pieselectchanged",
      method: "toggleSelected"
    }, {type: "pieSelect", event: "pieselected", method: "select"}, {
      type: "pieUnSelect",
      event: "pieunselected",
      method: "unSelect"
    }]), i.registerVisual(e.curry(t("../visual/dataColor"), "pie")), i.registerLayout(e.curry(t("./pie/pieLayout"), "pie")), i.registerProcessor(e.curry(t("../processor/dataFilter"), "pie"))
  }), e("echarts/echarts", [Pe, "zrender/core/env", "./model/Global", "./ExtensionAPI", "./CoordinateSystem", "./model/OptionManager", "./model/Component", "./model/Series", "./view/Component", "./view/Chart", "./util/graphic", "zrender", Le, "zrender/tool/color", "zrender/mixin/Eventful", "zrender/core/timsort", "./loading/default", "./visual/seriesColor", "./preprocessor/backwardCompat", "./data/List", "./model/Model", "./util/number", "./util/format", "zrender/core/matrix", be], function (t) {
    function e(t) {
      return function (e, i, n) {
        e = e && e[_e](), P[xe][t].call(this, e, i, n)
      }
    }

    function i() {
      P.call(this)
    }

    function n(t, e, n) {
      function r(t, e) {
        return t.prio - e.prio
      }

      n = n || {}, typeof e === ye && (e = Re[e]), this.id, this.group, this._dom = t, this._zr = C.init(t, {
        renderer: n.renderer || "canvas",
        devicePixelRatio: n.devicePixelRatio
      }), this._theme = A.clone(e), this._chartsViews = [], this._chartsMap = {}, this._componentsViews = [], this._componentsMap = {}, this._api = new y(this), this._coordSysMgr = new x, P.call(this), this._messageCenter = new i, this._initEvents(), this[ge] = A.bind(this[ge], this), this._pendingActions = [], k(Oe, r), k(De, r)
    }

    function r(t, e) {
      var i = this._model;
      i && i.eachComponent({mainType: "series", query: e}, function (n) {
        var r = this._chartsMap[n.__viewId];
        r && r.__alive && r[t](n, i, this._api, e)
      }, this)
    }

    function a(t, e, i) {
      var n = this._api;
      I(this._componentsViews, function (r) {
        var a = r.__model;
        r[t](a, e, n, i), p(a, r)
      }, this), e.eachSeries(function (r) {
        var a = this._chartsMap[r.__viewId];
        a[t](r, e, n, i), p(r, a), f(r, a)
      }, this), d(this._zr, e)
    }

    function o(t, e) {
      for (var i = "component" === t, n = i ? this._componentsViews : this._chartsViews, r = i ? this._componentsMap : this._chartsMap, a = this._zr, o = 0; o < n[ne]; o++)n[o].__alive = !1;
      e[i ? "eachComponent" : "eachSeries"](function (t, o) {
        if (i) {
          if (t === ie)return
        } else o = t;
        var s = o.id + "_" + o.type, l = r[s];
        if (!l) {
          var c = b.parseClassType(o.type), u = i ? S.getClass(c.main, c.sub) : M.getClass(c.sub);
          if (!u)return;
          l = new u, l.init(e, this._api), r[s] = l, n.push(l), a.add(l.group)
        }
        o.__viewId = s, l.__alive = !0, l.__id = s, l.__model = o
      }, this);
      for (var o = 0; o < n[ne];) {
        var s = n[o];
        s.__alive ? o++ : (a[ae](s.group), s.dispose(e, this._api), n[ee](o, 1), delete r[s.__id])
      }
    }

    function s(t, e) {
      I(De, function (i) {
        i.func(t, e)
      })
    }

    function l(t) {
      var e = {};
      t.eachSeries(function (t) {
        var i = t.get("stack"), n = t[we]();
        if (i && "list" === n.type) {
          var r = e[i];
          r && (n.stackedOn = r), e[i] = n
        }
      })
    }

    function c(t, e) {
      var i = this._api;
      I(Oe, function (n) {
        n.isLayout && n.func(t, i, e)
      })
    }

    function u(t, e) {
      var i = this._api;
      t.clearColorPalette(), t.eachSeries(function (t) {
        t.clearColorPalette()
      }), I(Oe, function (n) {
        n.func(t, i, e)
      })
    }

    function h(t, e) {
      var i = this._api;
      I(this._componentsViews, function (n) {
        var r = n.__model;
        n.render(r, t, i, e), p(r, n)
      }, this), I(this._chartsViews, function (t) {
        t.__alive = !1
      }, this), t.eachSeries(function (n) {
        var r = this._chartsMap[n.__viewId];
        r.__alive = !0, r.render(n, t, i, e), r.group.silent = !!n.get("silent"), p(n, r), f(n, r)
      }, this), d(this._zr, t), I(this._chartsViews, function (e) {
        e.__alive || e[ae](t, i)
      }, this)
    }

    function d(t, e) {
      var i = t[de], n = 0;
      i.traverse(function (t) {
        t.isGroup || n++
      }), n > e.get("hoverLayerThreshold") && !m.node && i.traverse(function (t) {
        t.isGroup || (t.useHoverLayer = !0)
      })
    }

    function f(t, e) {
      var i = 0;
      e.group.traverse(function (t) {
        "group" === t.type || t[he] || i++
      });
      var n = +t.get("progressive"), r = i > t.get("progressiveThreshold") && n && !m.node;
      r && e.group.traverse(function (t) {
        t.isGroup || (t.progressive = r ? Math.floor(i++ / n) : -1, r && t.stopAnimation(!0))
      });
      var a = t.get("blendMode") || null;
      e.group.traverse(function (t) {
        t.isGroup || t[X]("blend", a)
      })
    }

    function p(t, e) {
      var i = t.get("z"), n = t.get(j);
      e.group.traverse(function (t) {
        "group" !== t.type && (null != i && (t.z = i), null != n && (t[j] = n))
      })
    }

    function v(t) {
      function e(t, e) {
        for (var i = 0; i < t[ne]; i++) {
          var n = t[i];
          n[a] = e
        }
      }

      var i = 0, n = 1, r = 2, a = "__connectUpdateStatus";
      A.each(ze, function (o, s) {
        t._messageCenter.on(s, function (o) {
          if (Ne[t.group] && t[a] !== i) {
            var s = t.makeActionFromEvent(o), l = [];
            for (var c in Be) {
              var u = Be[c];
              u !== t && u.group === t.group && l.push(u)
            }
            e(l, i), I(l, function (t) {
              t[a] !== n && t.dispatchAction(s)
            }), e(l, r)
          }
        })
      })
    }

    var m = t("zrender/core/env"), g = t("./model/Global"), y = t("./ExtensionAPI"), x = t("./CoordinateSystem"), _ = t("./model/OptionManager"), b = t("./model/Component"), w = t("./model/Series"), S = t("./view/Component"), M = t("./view/Chart"), T = t("./util/graphic"), C = t("zrender"), A = t(Le), L = t("zrender/tool/color"), P = t("zrender/mixin/Eventful"), k = t("zrender/core/timsort"), I = A.each, z = 1e3, D = 5e3, E = 1e3, O = 2e3, R = 3e3, B = 4e3, N = 5e3, G = "__flag_in_main_process", Se = "_hasGradientOrPatternBg";
    i[xe].on = e("on"), i[xe].off = e("off"), i[xe].one = e("one"), A.mixin(i, P);
    var Te = n[xe];
    Te.getDom = function () {
      return this._dom
    }, Te.getZr = function () {
      return this._zr
    }, Te.setOption = function (t, e, i) {
      if (this[G] = !0, !this._model || e) {
        var n = new _(this._api), r = this._theme, a = this._model = new g(null, null, r, n);
        a.init(null, null, r, n)
      }
      this._model.setOption(t, Ee), Ce.prepareAndUpdate.call(this), this[G] = !1, this._flushPendingActions(), !i && this._zr.refreshImmediately()
    }, Te.setTheme = function () {
      console.log("ECharts#setTheme() is DEPRECATED in ECharts 3.0")
    }, Te[me] = function () {
      return this._model
    }, Te.getOption = function () {
      return this._model.getOption()
    }, Te[ve] = function () {
      return this._zr[ve]()
    }, Te[pe] = function () {
      return this._zr[pe]()
    }, Te.getRenderedCanvas = function (t) {
      if (m[fe]) {
        t = t || {}, t.pixelRatio = t.pixelRatio || 1, t.backgroundColor = t.backgroundColor || this._model.get("backgroundColor");
        var e = this._zr, i = e[de].getDisplayList();
        return A.each(i, function (t) {
          t.stopAnimation(!0)
        }), e.painter.getRenderedCanvas(t)
      }
    }, Te.getDataURL = function (t) {
      t = t || {};
      var e = t.excludeComponents, i = this._model, n = [], r = this;
      I(e, function (t) {
        i.eachComponent({mainType: t}, function (t) {
          var e = r._componentsMap[t.__viewId];
          e.group[he] || (n.push(e), e.group[he] = !0)
        })
      });
      var a = this.getRenderedCanvas(t).toDataURL("image/" + (t && t.type || "png"));
      return I(n, function (t) {
        t.group[he] = !1
      }), a
    }, Te.getConnectedDataURL = function (t) {
      if (m[fe]) {
        var e = this.group, i = Math.min, n = Math.max, r = 1 / 0;
        if (Ne[e]) {
          var a = r, o = r, s = -r, l = -r, c = [], u = t && t.pixelRatio || 1;
          for (var h in Be) {
            var d = Be[h];
            if (d.group === e) {
              var f = d.getRenderedCanvas(A.clone(t)), p = d.getDom().getBoundingClientRect();
              a = i(p.left, a), o = i(p.top, o), s = n(p.right, s), l = n(p[ue], l), c.push({
                dom: f,
                left: p.left,
                top: p.top
              })
            }
          }
          a *= u, o *= u, s *= u, l *= u;
          var v = s - a, g = l - o, y = A.createCanvas();
          y.width = v, y[ce] = g;
          var x = C.init(y);
          return I(c, function (t) {
            var e = new T.Image({style: {x: t.left * u - a, y: t.top * u - o, image: t.dom}});
            x.add(e)
          }), x.refreshImmediately(), y.toDataURL("image/" + (t && t.type || "png"))
        }
        return this.getDataURL(t)
      }
    };
    var Ce = {
      update: function (t) {
        var e = this._model, i = this._api, n = this._coordSysMgr, r = this._zr;
        if (e) {
          e.restoreData(), n[le](this._model, this._api), s.call(this, e, i), l.call(this, e), n[se](e, i), u.call(this, e, t), h.call(this, e, t);
          var a = e.get("backgroundColor") || "transparent", o = r.painter;
          if (o.isSingleCanvas && o.isSingleCanvas())r.configLayer(0, {clearColor: a}); else {
            if (!m[fe]) {
              var c = L.parse(a);
              a = L.stringify(c, "rgb"), 0 === c[3] && (a = "transparent")
            }
            a.colorStops || a.image ? (r.configLayer(0, {clearColor: a}), this[Se] = !0, this._dom.style.background = "transparent") : (this[Se] && r.configLayer(0, {clearColor: null}), this[Se] = !1, this._dom.style.background = a)
          }
        }
      }, updateView: function (t) {
        var e = this._model;
        e && (e.eachSeries(function (t) {
          t[we]().clearAllVisual()
        }), u.call(this, e, t), a.call(this, "updateView", e, t))
      }, updateVisual: function (t) {
        var e = this._model;
        e && (e.eachSeries(function (t) {
          t[we]().clearAllVisual()
        }), u.call(this, e, t), a.call(this, "updateVisual", e, t))
      }, updateLayout: function (t) {
        var e = this._model;
        e && (c.call(this, e, t), a.call(this, "updateLayout", e, t))
      }, highlight: function (t) {
        r.call(this, "highlight", t)
      }, downplay: function (t) {
        r.call(this, "downplay", t)
      }, prepareAndUpdate: function (t) {
        var e = this._model;
        o.call(this, "component", e), o.call(this, "chart", e), Ce[se].call(this, t)
      }
    };
    Te[ge] = function () {
      this[G] = !0, this._zr[ge]();
      var t = this._model && this._model.resetOption("media");
      Ce[t ? "prepareAndUpdate" : se].call(this), this._loadingFX && this._loadingFX[ge](), this[G] = !1, this._flushPendingActions()
    };
    var Pe = t("./loading/default");
    Te.showLoading = function (t, e) {
      A[oe](t) && (e = t, t = "default"), this.hideLoading();
      var i = Pe(this._api, e), n = this._zr;
      this._loadingFX = i, n.add(i)
    }, Te.hideLoading = function () {
      this._loadingFX && this._zr[ae](this._loadingFX), this._loadingFX = null
    }, Te.makeActionFromEvent = function (t) {
      var e = A[re]({}, t);
      return e.type = ze[t.type], e
    }, Te.dispatchAction = function (t, e) {
      var i = Ie[t.type];
      if (i) {
        var n = i.actionInfo, r = n[se] || se;
        if (this[G])return void this._pendingActions.push(t);
        this[G] = !0;
        var a = [t], o = !1;
        t.batch && (o = !0, a = A.map(t.batch, function (e) {
          return e = A[Me](A[re]({}, e), t), e.batch = null, e
        }));
        for (var s, l = [], c = "highlight" === t.type || "downplay" === t.type, u = 0; u < a[ne]; u++) {
          var h = a[u];
          s = i.action(h, this._model), s = s || A[re]({}, h), s.type = n.event || s.type, l.push(s), c && Ce[r].call(this, h)
        }
        "none" !== r && !c && Ce[r].call(this, t), s = o ? {
          type: n.event || t.type,
          batch: l
        } : l[0], this[G] = !1, !e && this._messageCenter.trigger(s.type, s), this._flushPendingActions()
      }
    }, Te._flushPendingActions = function () {
      for (var t = this._pendingActions; t[ne];) {
        var e = t.shift();
        this.dispatchAction(e)
      }
    }, Te.on = e("on"), Te.off = e("off"), Te.one = e("one");
    var ke = ["click", "dblclick", te, J, "mousedown", "mouseup", "globalout"];
    Te._initEvents = function () {
      I(ke, function (t) {
        this._zr.on(t, function (e) {
          var i = this[me](), n = e[K];
          if (n && null != n[Q]) {
            var r = n.dataModel || i.getSeriesByIndex(n[$]), a = r && r[Y](n[Q], n.dataType) || {};
            a.event = e, a.type = t, this.trigger(t, a)
          } else n && n.eventData && this.trigger(t, n.eventData)
        }, this)
      }, this), I(ze, function (t, e) {
        this._messageCenter.on(e, function (t) {
          this.trigger(e, t)
        }, this)
      }, this)
    }, Te.isDisposed = function () {
      return this._disposed
    }, Te.clear = function () {
      this.setOption({}, !0)
    }, Te.dispose = function () {
      if (!this._disposed) {
        this._disposed = !0;
        var t = this._api, e = this._model;
        I(this._componentsViews, function (i) {
          i.dispose(e, t)
        }), I(this._chartsViews, function (i) {
          i.dispose(e, t)
        }), this._zr.dispose(), delete Be[this.id]
      }
    }, A.mixin(n, P);
    var Ie = [], ze = {}, De = [], Ee = [], Oe = [], Re = {}, Be = {}, Ne = {}, Ge = new Date - 0, Fe = new Date - 0, Ve = "_echarts_instance_", He = {
      version: "3.2.2",
      dependencies: {zrender: "3.1.2"}
    };
    He.init = function (t, e, i) {
      var r = new n(t, e, i);
      return r.id = "ec_" + Ge++, Be[r.id] = r, t.setAttribute && t.setAttribute(Ve, r.id), v(r), r
    }, He.connect = function (t) {
      if (A[Z](t)) {
        var e = t;
        t = null, A.each(e, function (e) {
          null != e.group && (t = e.group)
        }), t = t || "g_" + Fe++, A.each(e, function (e) {
          e.group = t
        })
      }
      return Ne[t] = !0, t
    }, He.disConnect = function (t) {
      Ne[t] = !1
    }, He.dispose = function (t) {
      A.isDom(t) ? t = He.getInstanceByDom(t) : typeof t === ye && (t = Be[t]), t instanceof n && !t.isDisposed() && t.dispose()
    }, He.getInstanceByDom = function (t) {
      var e = t.getAttribute(Ve);
      return Be[e]
    }, He.getInstanceById = function (t) {
      return Be[t]
    }, He.registerTheme = function (t, e) {
      Re[t] = e
    }, He.registerPreprocessor = function (t) {
      Ee.push(t)
    }, He.registerProcessor = function (t, e) {
      typeof t === W && (e = t, t = z), De.push({prio: t, func: e})
    }, He.registerAction = function (t, e, i) {
      typeof e === W && (i = e, e = "");
      var n = A[oe](t) ? t.type : [t, t = {event: e}][0];
      t.event = (t.event || n)[_e](), e = t.event, Ie[n] || (Ie[n] = {action: i, actionInfo: t}), ze[e] = n
    }, He.registerCoordinateSystem = function (t, e) {
      x.register(t, e)
    }, He.registerLayout = function (t, e) {
      typeof t === W && (e = t, t = E), Oe.push({prio: t, func: e, isLayout: !0})
    }, He.registerVisual = function (t, e) {
      typeof t === W && (e = t, t = R), Oe.push({prio: t, func: e})
    };
    var qe = b.parseClassType;
    return He.extendComponentModel = function (t, e) {
      var i = b;
      if (e) {
        var n = qe(e);
        i = b.getClass(n.main, n.sub, !0)
      }
      return i[re](t)
    }, He[Ae] = function (t, e) {
      var i = S;
      if (e) {
        var n = qe(e);
        i = S.getClass(n.main, n.sub, !0)
      }
      return i[re](t)
    }, He.extendSeriesModel = function (t, e) {
      var i = w;
      if (e) {
        e = "series." + e[U]("series.", "");
        var n = qe(e);
        i = w.getClass(n.main, n.sub, !0)
      }
      return i[re](t)
    }, He.extendChartView = function (t, e) {
      var i = M;
      if (e) {
        e[U]("series.", "");
        var n = qe(e);
        i = M.getClass(n.main, !0)
      }
      return M[re](t)
    }, He.setCanvasCreator = function (t) {
      A.createCanvas = t
    }, He.registerVisual(O, t("./visual/seriesColor")), He.registerPreprocessor(t("./preprocessor/backwardCompat")), He.registerAction({
      type: "highlight",
      event: "highlight",
      update: "highlight"
    }, A.noop), He.registerAction({
      type: "downplay",
      event: "downplay",
      update: "downplay"
    }, A.noop), He.List = t("./data/List"), He.Model = t("./model/Model"), He.graphic = t("./util/graphic"), He[q] = t("./util/number"), He.format = t("./util/format"), He.matrix = t("zrender/core/matrix"), He.vector = t(be), He.color = t("zrender/tool/color"), He.util = {}, I(["map", "each", H, V, F, "reduce", H, "bind", "curry", Z, "isString", oe, "isFunction", re, Me], function (t) {
      He.util[t] = A[t]
    }), He.PRIORITY = {
      PROCESSOR: {FILTER: z, STATISTIC: D},
      VISUAL: {LAYOUT: E, GLOBAL: O, CHART: R, COMPONENT: B, BRUSH: N}
    }, He
  }), e("echarts/component/tooltip", [Pe, "./tooltip/TooltipModel", "./tooltip/TooltipView", "../echarts"], function (t) {
    t("./tooltip/TooltipModel"), t("./tooltip/TooltipView"), t("../echarts").registerAction({
      type: "showTip",
      event: "showTip",
      update: "none"
    }, function () {
    }), t("../echarts").registerAction({type: "hideTip", event: "hideTip", update: "none"}, function () {
    })
  }), e("echarts/component/title", [Pe, "../echarts", "../util/graphic", "../util/layout"], function (t) {
    var e = t("../echarts"), i = t("../util/graphic"), n = t("../util/layout");
    e.extendComponentModel({
      type: "title",
      layoutMode: {type: "box", ignoreSize: !0},
      defaultOption: {
        zlevel: 0,
        z: 6,
        show: !0,
        text: "",
        target: "blank",
        subtext: "",
        subtarget: "blank",
        left: 0,
        top: 0,
        backgroundColor: "rgba(0,0,0,0)",
        borderColor: "#ccc",
        borderWidth: 0,
        padding: 5,
        itemGap: 10,
        textStyle: {fontSize: 18, fontWeight: "bolder", color: "#333"},
        subtextStyle: {color: "#aaa"}
      }
    }), e[Ae]({
      type: "title", render: function (t, e, r) {
        if (this.group[Ce](), t.get("show")) {
          var a = this.group, o = t[me](G), s = t[me]("subtextStyle"), l = t.get(N), c = t.get("textBaseline"), u = new i.Text({
            style: {
              text: t.get("text"),
              textFont: o[B](),
              fill: o[R]()
            }, z2: 10
          }), h = u[O](), d = t.get("subtext"), f = new i.Text({
            style: {
              text: d,
              textFont: s[B](),
              fill: s[R](),
              y: h[ce] + t.get("itemGap"),
              textBaseline: "top"
            }, z2: 10
          }), p = t.get("link"), v = t.get("sublink");
          u.silent = !p, f.silent = !v, p && u.on("click", function () {
            window.open(p, "_" + t.get(K))
          }), v && f.on("click", function () {
            window.open(v, "_" + t.get("subtarget"))
          }), a.add(u), d && a.add(f);
          var m = a[O](), g = t.getBoxLayoutParams();
          g.width = m.width, g[ce] = m[ce];
          var y = n.getLayoutRect(g, {width: r[ve](), height: r[pe]()}, t.get("padding"));
          l || (l = t.get("left") || t.get("right"), l === E && (l = D), "right" === l ? y.x += y.width : l === D && (y.x += y.width / 2)), c || (c = t.get("top") || t.get(ue), c === D && (c = E), c === ue ? y.y += y[ce] : c === E && (y.y += y[ce] / 2), c = c || "top"), a.attr(z, [y.x, y.y]);
          var x = {textAlign: l, textVerticalAlign: c};
          u[X](x), f[X](x), m = a[O]();
          var _ = y.margin, b = t[Se](["color", I]);
          b.fill = t.get("backgroundColor");
          var w = new i.Rect({
            shape: {
              x: m.x - _[3],
              y: m.y - _[0],
              width: m.width + _[1] + _[3],
              height: m[ce] + _[0] + _[2]
            }, style: b, silent: !0
          });
          i.subPixelOptimizeRect(w), a.add(w)
        }
      }
    })
  }), e("zrender/vml/vml", [Pe, "./graphic", "../zrender", "./Painter"], function (t) {
    t("./graphic"), t("../zrender").registerPainter("vml", t("./Painter"))
  }), e("echarts/component/legend", [Pe, "./legend/LegendModel", "./legend/legendAction", "./legend/LegendView", "../echarts", "./legend/legendFilter"], function (t) {
    t("./legend/LegendModel"), t("./legend/legendAction"), t("./legend/LegendView");
    var e = t("../echarts");
    e.registerProcessor(t("./legend/legendFilter"))
  }), e("echarts/scale/Time", [Pe, Le, "../util/number", "../util/format", "./Interval"], function (t) {
    var e = t(Le), i = t("../util/number"), n = t("../util/format"), r = t("./Interval"), a = r[xe], o = Math.ceil, s = Math.floor, l = 1e3, c = 60 * l, u = 60 * c, h = 24 * u, d = function (t, e, i, n) {
      for (; n > i;) {
        var r = i + n >>> 1;
        t[r][2] < e ? i = r + 1 : n = r
      }
      return i
    }, f = r[re]({
      type: "time", getLabel: function (t) {
        var e = this._stepLvl, i = new Date(t);
        return n.formatTime(e[0], i)
      }, niceExtent: function (t, e, n) {
        var r = this._extent;
        if (r[0] === r[1] && (r[0] -= h, r[1] += h), r[1] === -1 / 0 && 1 / 0 === r[0]) {
          var a = new Date;
          r[1] = new Date(a.getFullYear(), a.getMonth(), a.getDate()), r[0] = r[1] - h
        }
        this.niceTicks(t);
        var l = this._interval;
        e || (r[0] = i.round(s(r[0] / l) * l)), n || (r[1] = i.round(o(r[1] / l) * l))
      }, niceTicks: function (t) {
        t = t || 10;
        var e = this._extent, n = e[1] - e[0], r = n / t, a = p[ne], l = d(p, r, 0, a), c = p[Math.min(l, a - 1)], u = c[2];
        if ("year" === c[0]) {
          var h = n / u, f = i.nice(h / t, !0);
          u *= f
        }
        var v = [o(e[0] / u) * u, s(e[1] / u) * u];
        this._stepLvl = c, this._interval = u, this._niceExtent = v
      }, parse: function (t) {
        return +i.parseDate(t)
      }
    });
    e.each([k, "normalize"], function (t) {
      f[xe][t] = function (e) {
        return a[t].call(this, this.parse(e))
      }
    });
    var p = [["hh:mm:ss", 1, l], ["hh:mm:ss", 5, 5 * l], ["hh:mm:ss", 10, 10 * l], ["hh:mm:ss", 15, 15 * l], ["hh:mm:ss", 30, 30 * l], ["hh:mm\nMM-dd", 1, c], ["hh:mm\nMM-dd", 5, 5 * c], ["hh:mm\nMM-dd", 10, 10 * c], ["hh:mm\nMM-dd", 15, 15 * c], ["hh:mm\nMM-dd", 30, 30 * c], ["hh:mm\nMM-dd", 1, u], ["hh:mm\nMM-dd", 2, 2 * u], ["hh:mm\nMM-dd", 6, 6 * u], ["hh:mm\nMM-dd", 12, 12 * u], ["MM-dd\nyyyy", 1, h], ["week", 7, 7 * h], ["month", 1, 31 * h], ["quarter", 3, 380 * h / 4], ["half-year", 6, 380 * h / 2], ["year", 1, 380 * h]];
    return f[le] = function () {
      return new f
    }, f
  }), e("echarts/scale/Log", [Pe, Le, "./Scale", "../util/number", "./Interval"], function (t) {
    var e = t(Le), i = t("./Scale"), n = t("../util/number"), r = t("./Interval"), a = i[xe], o = r[xe], s = Math.floor, l = Math.ceil, c = Math.pow, u = 10, h = Math.log, d = i[re]({
      type: "log",
      getTicks: function () {
        return e.map(o[P].call(this), function (t) {
          return n.round(c(u, t))
        })
      },
      getLabel: o.getLabel,
      scale: function (t) {
        return t = a.scale.call(this, t), c(u, t)
      },
      setExtent: function (t, e) {
        t = h(t) / h(u), e = h(e) / h(u), o.setExtent.call(this, t, e)
      },
      getExtent: function () {
        var t = a[L].call(this);
        return t[0] = c(u, t[0]), t[1] = c(u, t[1]), t
      },
      unionExtent: function (t) {
        t[0] = h(t[0]) / h(u), t[1] = h(t[1]) / h(u), a.unionExtent.call(this, t)
      },
      niceTicks: function (t) {
        t = t || 10;
        var e = this._extent, i = e[1] - e[0];
        if (!(1 / 0 === i || 0 >= i)) {
          var r = c(10, s(h(i / t) / Math.LN10)), a = t / i * r;
          .5 >= a && (r *= 10);
          var o = [n.round(l(e[0] / r) * r), n.round(s(e[1] / r) * r)];
          this._interval = r, this._niceExtent = o
        }
      },
      niceExtent: o.niceExtent
    });
    return e.each([k, "normalize"], function (t) {
      d[xe][t] = function (e) {
        return e = h(e) / h(u), a[t].call(this, e)
      }
    }), d[le] = function () {
      return new d
    }, d
  }), e("echarts/chart/line/LineView", [Pe, Le, "../helper/SymbolDraw", "../helper/Symbol", "./lineAnimationDiff", A, "./poly", "../../view/Chart"], function (t) {
    function e(t, e) {
      if (t[ne] === e[ne]) {
        for (var i = 0; i < t[ne]; i++) {
          var n = t[i], r = e[i];
          if (n[0] !== r[0] || n[1] !== r[1])return
        }
        return !0
      }
    }

    function i(t) {
      return typeof t === q ? t : t ? .3 : 0
    }

    function n(t) {
      var e = t.getGlobalExtent();
      if (t.onBand) {
        var i = t.getBandWidth() / 2 - 1, n = e[1] > e[0] ? 1 : -1;
        e[0] += n * i, e[1] -= n * i
      }
      return e
    }

    function r(t) {
      return t >= 0 ? 1 : -1
    }

    function a(t, e) {
      var i = t[C](), n = t.getOtherAxis(i), a = i.onZero ? 0 : n.scale[L]()[0], o = n.dim, s = "x" === o || o === T ? 1 : 0;
      return e.mapArray([o], function (n, l) {
        for (var c, u = e.stackedOn; u && r(u.get(o, l)) === r(n);) {
          c = u;
          break
        }
        var h = [];
        return h[s] = e.get(i.dim, l), h[1 - s] = c ? c.get(o, l, !0) : a, t[M](h)
      }, !0)
    }

    function o(t, e) {
      return null != e[Q] ? e[Q] : null != e.name ? t.indexOfName(e.name) : void 0
    }

    function s(t, e, i) {
      var r = n(t.getAxis("x")), a = n(t.getAxis("y")), o = t[C]().isHorizontal(), s = Math.min(r[0], r[1]), l = Math.min(a[0], a[1]), c = Math.max(r[0], r[1]) - s, u = Math.max(a[0], a[1]) - l, h = i.get("lineStyle.normal.width") || 2, d = i.get("clipOverflow") ? h / 2 : Math.max(c, u);
      o ? (l -= d, u += 2 * d) : (s -= d, c += 2 * d);
      var f = new g.Rect({shape: {x: s, y: l, width: c, height: u}});
      return e && (f.shape[o ? "width" : ce] = 0, g.initProps(f, {shape: {width: c, height: u}}, i)), f
    }

    function l(t, e, i) {
      var n = t.getAngleAxis(), r = t.getRadiusAxis(), a = r[L](), o = n[L](), s = Math.PI / 180, l = new g.Sector({
        shape: {
          cx: t.cx,
          cy: t.cy,
          r0: a[0],
          r: a[1],
          startAngle: -o[0] * s,
          endAngle: -o[1] * s,
          clockwise: n.inverse
        }
      });
      return e && (l.shape.endAngle = -o[0] * s, g.initProps(l, {shape: {endAngle: -o[1] * s}}, i)), l
    }

    function c(t, e, i) {
      return "polar" === t.type ? l(t, e, i) : s(t, e, i)
    }

    function u(t, e, i) {
      for (var n = e[C](), r = "x" === n.dim || n.dim === T ? 0 : 1, a = [], o = 0; o < t[ne] - 1; o++) {
        var s = t[o + 1], l = t[o];
        a.push(l);
        var c = [];
        switch (i) {
          case"end":
            c[r] = s[r], c[1 - r] = l[1 - r], a.push(c);
            break;
          case E:
            var u = (l[r] + s[r]) / 2, h = [];
            c[r] = h[r] = u, c[1 - r] = l[1 - r], h[1 - r] = s[1 - r], a.push(c), a.push(h);
            break;
          default:
            c[r] = l[r], c[1 - r] = s[1 - r], a.push(c)
        }
      }
      return t[o] && a.push(t[o]), a
    }

    function h(t, e) {
      return Math.max(Math.min(t, e[1]), e[0])
    }

    function d(t, e) {
      var i = t.getVisual("visualMeta");
      if (i && i[ne]) {
        for (var n, r = i[ne] - 1; r >= 0; r--)if (i[r].dimension < 2) {
          n = i[r];
          break
        }
        if (n && "cartesian2d" === e.type) {
          var a = n.dimension, o = t[S][a], s = t.getDataExtent(o), l = n.stops, c = [];
          l[0].interval && l.sort(function (t, e) {
            return t.interval[0] - e.interval[0]
          });
          var u = l[0], d = l[l[ne] - 1], f = u.interval ? h(u.interval[0], s) : u.value, p = d.interval ? h(d.interval[1], s) : d.value, v = p - f;
          if (0 === v)return t[w](0, "color");
          for (var r = 0; r < l[ne]; r++)if (l[r].interval) {
            if (l[r].interval[1] === l[r].interval[0])continue;
            c.push({
              offset: (h(l[r].interval[0], s) - f) / v,
              color: l[r].color
            }, {offset: (h(l[r].interval[1], s) - f) / v, color: l[r].color})
          } else c.push({offset: (l[r].value - f) / v, color: l[r].color});
          var m = new g.LinearGradient(0, 0, 0, 0, c, !0), y = e.getAxis(o), x = Math.round(y.toGlobalCoord(y[b](f))), _ = Math.round(y.toGlobalCoord(y[b](p)));
          return m[o] = x, m[o + "2"] = _, m
        }
      }
    }

    var f = t(Le), p = t("../helper/SymbolDraw"), v = t("../helper/Symbol"), m = t("./lineAnimationDiff"), g = t(A), y = t("./poly"), P = t("../../view/Chart");
    return P[re]({
      type: "line", init: function () {
        var t = new g.Group, e = new p;
        this.group.add(e.group), this._symbolDraw = e, this._lineGroup = t
      }, render: function (t, n, r) {
        var o = t[Te], s = this.group, l = t[we](), h = t[me]("lineStyle.normal"), p = t[me]("areaStyle.normal"), v = l.mapArray(l.getItemLayout, !0), m = "polar" === o.type, g = this._coordSys, y = this._symbolDraw, x = this._polyline, b = this._polygon, w = this._lineGroup, S = t.get(_), M = !p.isEmpty(), T = a(o, l), C = t.get("showSymbol"), A = C && !m && !t.get("showAllSymbol") && this._getSymbolIgnoreFunc(l, o), L = this._data;
        L && L.eachItemGraphicEl(function (t, e) {
          t.__temp && (s[ae](t), L.setItemGraphicEl(e, null))
        }), C || y[ae](), s.add(w);
        var P = !m && t.get("step");
        x && g.type === o.type && P === this._step ? (M && !b ? b = this._newPolygon(v, T, o, S) : b && !M && (w[ae](b), b = this._polygon = null), w.setClipPath(c(o, !1, t)), C && y.updateData(l, A), l.eachItemGraphicEl(function (t) {
          t.stopAnimation(!0)
        }), e(this._stackedOnPoints, T) && e(this._points, v) || (S ? this._updateAnimation(l, T, o, r, P) : (x.setShape({points: v}), b && b.setShape({
          points: v,
          stackedOnPoints: T
        })))) : (C && y.updateData(l, A), P && (v = u(v, o, P), T = u(T, o, P)), x = this._newPolyline(v, o, S), M && (b = this._newPolygon(v, T, o, S)), w.setClipPath(c(o, !0, t)));
        var k = d(l, o) || l.getVisual("color");
        x.useStyle(f[Me](h.getLineStyle(), {fill: "none", stroke: k, lineJoin: "bevel"}));
        var I = t.get("smooth");
        if (I = i(t.get("smooth")), x.setShape({
            smooth: I,
            smoothMonotone: t.get("smoothMonotone"),
            connectNulls: t.get("connectNulls")
          }), b) {
          var z = l.stackedOn, D = 0;
          if (b.useStyle(f[Me](p.getAreaStyle(), {fill: k, opacity: .7, lineJoin: "bevel"})), z) {
            var E = z.hostModel;
            D = i(E.get("smooth"))
          }
          b.setShape({
            smooth: I,
            stackedOnSmooth: D,
            smoothMonotone: t.get("smoothMonotone"),
            connectNulls: t.get("connectNulls")
          })
        }
        this._data = l, this._coordSys = o, this._stackedOnPoints = T, this._points = v, this._step = P
      }, highlight: function (t, e, i, n) {
        var r = t[we](), a = o(r, n);
        if (!(a instanceof Array) && null != a && a >= 0) {
          var s = r.getItemGraphicEl(a);
          if (!s) {
            var l = r.getItemLayout(a);
            s = new v(r, a), s[z] = l, s.setZ(t.get(j), t.get("z")), s[he] = isNaN(l[0]) || isNaN(l[1]), s.__temp = !0, r.setItemGraphicEl(a, s), s.stopSymbolAnimation(!0), this.group.add(s)
          }
          s.highlight()
        } else P[xe].highlight.call(this, t, e, i, n)
      }, downplay: function (t, e, i, n) {
        var r = t[we](), a = o(r, n);
        if (null != a && a >= 0) {
          var s = r.getItemGraphicEl(a);
          s && (s.__temp ? (r.setItemGraphicEl(a, null), this.group[ae](s)) : s.downplay())
        } else P[xe].downplay.call(this, t, e, i, n)
      }, _newPolyline: function (t) {
        var e = this._polyline;
        return e && this._lineGroup[ae](e), e = new y.Polyline({
          shape: {points: t},
          silent: !0,
          z2: 10
        }), this._lineGroup.add(e), this._polyline = e, e
      }, _newPolygon: function (t, e) {
        var i = this._polygon;
        return i && this._lineGroup[ae](i), i = new y.Polygon({
          shape: {points: t, stackedOnPoints: e},
          silent: !0
        }), this._lineGroup.add(i), this._polygon = i, i
      }, _getSymbolIgnoreFunc: function (t, e) {
        var i = e.getAxesByScale(x)[0];
        return i && i.isLabelIgnored ? f.bind(i.isLabelIgnored, i) : void 0
      }, _updateAnimation: function (t, e, i, n, r) {
        var a = this._polyline, o = this._polygon, s = t.hostModel, l = m(this._data, t, this._stackedOnPoints, e, this._coordSys, i), c = l.current, h = l.stackedOnCurrent, d = l.next, f = l.stackedOnNext;
        r && (c = u(l.current, i, r), h = u(l.stackedOnCurrent, i, r), d = u(l.next, i, r), f = u(l.stackedOnNext, i, r)), a.shape.__points = l.current, a.shape.points = c, g.updateProps(a, {shape: {points: d}}, s), o && (o.setShape({
          points: c,
          stackedOnPoints: h
        }), g.updateProps(o, {shape: {points: d, stackedOnPoints: f, __points: l.next}}, s));
        for (var p = [], v = l.status, y = 0; y < v[ne]; y++) {
          var x = v[y].cmd;
          if ("=" === x) {
            var _ = t.getItemGraphicEl(v[y].idx1);
            _ && p.push({el: _, ptIdx: y})
          }
        }
        a.animators && a.animators[ne] && a.animators[0].during(function () {
          for (var t = 0; t < p[ne]; t++) {
            var e = p[t].el;
            e.attr(z, a.shape.__points[p[t].ptIdx])
          }
        })
      }, remove: function () {
        var t = this.group, e = this._data;
        this._lineGroup[Ce](), this._symbolDraw[ae](!0), e && e.eachItemGraphicEl(function (i, n) {
          i.__temp && (t[ae](i), e.setItemGraphicEl(n, null))
        }), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null
      }
    })
  }), e("echarts/chart/line/LineSeries", [Pe, "../helper/createListFromArray", "../../model/Series"], function (t) {
    var e = t("../helper/createListFromArray"), i = t("../../model/Series");
    return i[re]({
      type: "series.line",
      dependencies: ["grid", "polar"],
      getInitialData: function (t, i) {
        return e(t.data, this, i)
      },
      defaultOption: {
        zlevel: 0,
        z: 2,
        coordinateSystem: "cartesian2d",
        legendHoverLink: !0,
        hoverAnimation: !0,
        xAxisIndex: 0,
        yAxisIndex: 0,
        polarIndex: 0,
        clipOverflow: !0,
        label: {normal: {position: "top"}},
        lineStyle: {normal: {width: 2, type: "solid"}},
        step: !1,
        smooth: !1,
        smoothMonotone: null,
        symbol: "emptyCircle",
        symbolSize: 4,
        symbolRotate: null,
        showSymbol: !0,
        showAllSymbol: !1,
        connectNulls: !1,
        sampling: "none",
        animationEasing: "linear",
        progressive: 0,
        hoverLayerThreshold: 1 / 0
      }
    })
  }), e(Le, [Pe], function () {
    function t(e) {
      if ("object" == typeof e && null !== e) {
        var i = e;
        if (e instanceof Array) {
          i = [];
          for (var n = 0, r = e[ne]; r > n; n++)i[n] = t(e[n])
        } else if (!M(e) && !T(e)) {
          i = {};
          for (var a in e)e.hasOwnProperty(a) && (i[a] = t(e[a]))
        }
        return i
      }
      return e
    }

    function e(i, n, r) {
      if (!S(n) || !S(i))return r ? t(n) : i;
      for (var a in n)if (n.hasOwnProperty(a)) {
        var o = i[a], s = n[a];
        !S(s) || !S(o) || _(s) || _(o) || T(s) || T(o) || M(s) || M(o) ? !r && a in i || (i[a] = t(n[a], !0)) : e(o, s, r)
      }
      return i
    }

    function i(t, i) {
      for (var n = t[0], r = 1, a = t[ne]; a > r; r++)n = e(n, t[r], i);
      return n
    }

    function n(t, e) {
      for (var i in e)e.hasOwnProperty(i) && (t[i] = e[i]);
      return t
    }

    function r(t, e, i) {
      for (var n in e)e.hasOwnProperty(n) && (i ? null != e[n] : null == t[n]) && (t[n] = e[n]);
      return t
    }

    function a() {
      return document[y]("canvas")
    }

    function o() {
      return P || (P = N.createCanvas().getContext("2d")), P
    }

    function s(t, e) {
      if (t) {
        if (t[V])return t[V](e);
        for (var i = 0, n = t[ne]; n > i; i++)if (t[i] === e)return i
      }
      return -1
    }

    function l(t, e) {
      function i() {
      }

      var n = t[xe];
      i[xe] = e[xe], t[xe] = new i;
      for (var r in n)t[xe][r] = n[r];
      t[xe].constructor = t, t.superClass = e
    }

    function c(t, e, i) {
      t = xe in t ? t[xe] : t, e = xe in e ? e[xe] : e, r(t, e, i)
    }

    function u(t) {
      return t ? typeof t == ye ? !1 : typeof t[ne] == q : void 0
    }

    function h(t, e, i) {
      if (t && e)if (t.forEach && t.forEach === D)t.forEach(e, i); else if (t[ne] === +t[ne])for (var n = 0, r = t[ne]; r > n; n++)e.call(i, t[n], n, t); else for (var a in t)t.hasOwnProperty(a) && e.call(i, t[a], a, t)
    }

    function d(t, e, i) {
      if (t && e) {
        if (t.map && t.map === R)return t.map(e, i);
        for (var n = [], r = 0, a = t[ne]; a > r; r++)n.push(e.call(i, t[r], r, t));
        return n
      }
    }

    function f(t, e, i, n) {
      if (t && e) {
        if (t.reduce && t.reduce === B)return t.reduce(e, i, n);
        for (var r = 0, a = t[ne]; a > r; r++)i = e.call(n, i, t[r], r, t);
        return i
      }
    }

    function p(t, e, i) {
      if (t && e) {
        if (t[H] && t[H] === E)return t[H](e, i);
        for (var n = [], r = 0, a = t[ne]; a > r; r++)e.call(i, t[r], r, t) && n.push(t[r]);
        return n
      }
    }

    function v(t, e, i) {
      if (t && e)for (var n = 0, r = t[ne]; r > n; n++)if (e.call(i, t[n], n, t))return t[n]
    }

    function m(t, e) {
      var i = O.call(arguments, 2);
      return function () {
        return t.apply(e, i[g](O.call(arguments)))
      }
    }

    function x(t) {
      var e = O.call(arguments, 1);
      return function () {
        return t.apply(this, e[g](O.call(arguments)))
      }
    }

    function _(t) {
      return "[object Array]" === I.call(t)
    }

    function b(t) {
      return typeof t === W
    }

    function w(t) {
      return "[object String]" === I.call(t)
    }

    function S(t) {
      var e = typeof t;
      return e === W || !!t && "object" == e
    }

    function M(t) {
      return !!k[I.call(t)]
    }

    function T(t) {
      return t && 1 === t.nodeType && typeof t.nodeName == ye
    }

    function C() {
      for (var t = 0, e = arguments[ne]; e > t; t++)if (null != arguments[t])return arguments[t]
    }

    function A() {
      return Function.call.apply(O, arguments)
    }

    function L(t, e) {
      if (!t)throw new Error(e)
    }

    var P, k = {
      "[object Function]": 1,
      "[object RegExp]": 1,
      "[object Date]": 1,
      "[object Error]": 1,
      "[object CanvasGradient]": 1,
      "[object CanvasPattern]": 1,
      "[object Image]": 1
    }, I = Object[xe].toString, z = Array[xe], D = z.forEach, E = z[H], O = z.slice, R = z.map, B = z.reduce, N = {
      inherits: l,
      mixin: c,
      clone: t,
      merge: e,
      mergeAll: i,
      extend: n,
      defaults: r,
      getContext: o,
      createCanvas: a,
      indexOf: s,
      slice: A,
      find: v,
      isArrayLike: u,
      each: h,
      map: d,
      reduce: f,
      filter: p,
      bind: m,
      curry: x,
      isArray: _,
      isString: w,
      isObject: S,
      isFunction: b,
      isBuildInObject: M,
      isDom: T,
      retrieve: C,
      assert: L,
      noop: function () {
      }
    };
    return N
  }), e("echarts/visual/symbol", [Pe], function () {
    return function (t, e, i, n) {
      n.eachRawSeriesByType(t, function (t) {
        var r = t[we](), a = t.get("symbol") || e, o = t.get("symbolSize");
        r.setVisual({
          legendSymbol: i || a,
          symbol: a,
          symbolSize: o
        }), n.isSeriesFiltered(t) || (typeof o === W && r.each(function (e) {
          var i = t.getRawValue(e), n = t[Y](e);
          r.setItemVisual(e, "symbolSize", o(i, n))
        }), r.each(function (t) {
          var e = r[m](t), i = e[v]("symbol", !0), n = e[v]("symbolSize", !0);
          null != i && r.setItemVisual(t, "symbol", i), null != n && r.setItemVisual(t, "symbolSize", n)
        }))
      })
    }
  }), e("echarts/layout/points", [Pe], function () {
    return function (t, e) {
      e.eachSeriesByType(t, function (t) {
        var e = t[we](), i = t[Te];
        if (i) {
          var n = i[S];
          "singleAxis" === i.type ? e.each(n[0], function (t, n) {
            e.setItemLayout(n, isNaN(t) ? [0 / 0, 0 / 0] : i[M](t))
          }) : e.each(n, function (t, n, r) {
            e.setItemLayout(r, isNaN(t) || isNaN(n) ? [0 / 0, 0 / 0] : i[M]([t, n]))
          }, !0)
        }
      })
    }
  }), e("echarts/processor/dataSample", [], function () {
    var t = {
      average: function (t) {
        for (var e = 0, i = 0, n = 0; n < t[ne]; n++)isNaN(t[n]) || (e += t[n], i++);
        return 0 === i ? 0 / 0 : e / i
      }, sum: function (t) {
        for (var e = 0, i = 0; i < t[ne]; i++)e += t[i] || 0;
        return e
      }, max: function (t) {
        for (var e = -1 / 0, i = 0; i < t[ne]; i++)t[i] > e && (e = t[i]);
        return e
      }, min: function (t) {
        for (var e = 1 / 0, i = 0; i < t[ne]; i++)t[i] < e && (e = t[i]);
        return e
      }, nearest: function (t) {
        return t[0]
      }
    }, e = function (t) {
      return Math.round(t[ne] / 2)
    };
    return function (i, n) {
      n.eachSeriesByType(i, function (i) {
        var n = i[we](), r = i.get("sampling"), a = i[Te];
        if ("cartesian2d" === a.type && r) {
          var o = a[C](), s = a.getOtherAxis(o), l = o[L](), c = l[1] - l[0], u = Math.round(n.count() / c);
          if (u > 1) {
            var h;
            typeof r === ye ? h = t[r] : typeof r === W && (h = r), h && (n = n.downSample(s.dim, 1 / u, h, e), i.setData(n))
          }
        }
      }, this)
    }
  }), e("echarts/chart/radar/RadarView", [Pe, A, Le, "../../util/symbol", p], function (t) {
    function e(t) {
      return n[Z](t) || (t = [+t, +t]), t
    }

    var i = t(A), n = t(Le), r = t("../../util/symbol");
    return t(p).extendChartView({
      type: "radar", render: function (t) {
        function a(t, i) {
          var n = t[w](i, "symbol") || "circle", a = t[w](i, "color");
          if ("none" !== n) {
            var o = r.createSymbol(n, -.5, -.5, 1, 1, a);
            return o.attr({style: {strokeNoScale: !0}, z2: 100, scale: e(t[w](i, "symbolSize"))}), o
          }
        }

        function o(e, n, r, o, s, l) {
          r[Ce]();
          for (var c = 0; c < n[ne] - 1; c++) {
            var u = a(o, s);
            u && (u.__dimIdx = c, e[c] ? (u.attr(z, e[c]), i[l ? "initProps" : "updateProps"](u, {position: n[c]}, t, s)) : u.attr(z, n[c]), r.add(u))
          }
        }

        function s(t) {
          return n.map(t, function () {
            return [l.cx, l.cy]
          })
        }

        var l = t[Te], c = this.group, u = t[we](), h = this._data;
        u.diff(h).add(function (e) {
          var n = u.getItemLayout(e);
          if (n) {
            var r = new i.Polygon, a = new i.Polyline, l = {shape: {points: n}};
            r.shape.points = s(n), a.shape.points = s(n), i.initProps(r, l, t, e), i.initProps(a, l, t, e);
            var c = new i.Group, h = new i.Group;
            c.add(a), c.add(r), c.add(h), o(a.shape.points, n, h, u, e, !0), u.setItemGraphicEl(e, c)
          }
        })[se](function (e, n) {
          var r = h.getItemGraphicEl(n), a = r.childAt(0), s = r.childAt(1), l = r.childAt(2), c = {shape: {points: u.getItemLayout(e)}};
          c.shape.points && (o(a.shape.points, c.shape.points, l, u, e, !1), i.updateProps(a, c, t), i.updateProps(s, c, t), u.setItemGraphicEl(e, r))
        })[ae](function (t) {
          c[ae](h.getItemGraphicEl(t))
        }).execute(), u.eachItemGraphicEl(function (e, r) {
          function a() {
            h.attr(he, x)
          }

          function o() {
            h.attr(he, y)
          }

          var s = u[m](r), l = e.childAt(0), h = e.childAt(1), d = e.childAt(2), p = u[w](r, "color");
          c.add(e), l.useStyle(n[Me](s[me]("lineStyle.normal").getLineStyle(), {
            fill: "none",
            stroke: p
          })), l.hoverStyle = s[me]("lineStyle.emphasis").getLineStyle();
          var v = s[me]("areaStyle.normal"), g = s[me]("areaStyle.emphasis"), y = v.isEmpty() && v.parentModel.isEmpty(), x = g.isEmpty() && g.parentModel.isEmpty();
          x = x && y, h[he] = y, h.useStyle(n[Me](v.getAreaStyle(), {
            fill: p,
            opacity: .7
          })), h.hoverStyle = g.getAreaStyle();
          var _ = s[me]("itemStyle.normal")[Se](["color"]), b = s[me]("itemStyle.emphasis")[Se](), M = s[me]("label.normal"), T = s[me]("label.emphasis");
          d.eachChild(function (e) {
            e[X](_), e.hoverStyle = n.clone(b);
            var a = u.get(u[S][e.__dimIdx], r);
            i.setText(e.style, M, p), e[X]({text: M.get("show") ? n.retrieve(t.getFormattedLabel(r, f, null, e.__dimIdx), a) : ""}), i.setText(e.hoverStyle, T, p), e.hoverStyle.text = T.get("show") ? n.retrieve(t.getFormattedLabel(r, "emphasis", null, e.__dimIdx), a) : ""
          }), e.off(te).off(J).off(f).off("emphasis"), e.on("emphasis", a).on(te, a).on(f, o).on(J, o), i.setHoverStyle(e)
        }), this._data = u
      }, remove: function () {
        this.group[Ce](), this._data = null
      }
    })
  }), e("echarts/component/radar", [Pe, "../coord/radar/Radar", "../coord/radar/RadarModel", "./radar/RadarView"], function (t) {
    t("../coord/radar/Radar"), t("../coord/radar/RadarModel"), t("./radar/RadarView")
  }), e("echarts/chart/radar/RadarSeries", [Pe, "../../model/Series", "../../data/List", "../../data/helper/completeDimensions", Le], function (t) {
    var e = t("../../model/Series"), i = t("../../data/List"), n = t("../../data/helper/completeDimensions"), r = t(Le), a = e[re]({
      type: "series.radar",
      dependencies: ["radar"],
      init: function () {
        a.superApply(this, "init", arguments), this.legendDataProvider = function () {
          return this._dataBeforeProcessed
        }
      },
      getInitialData: function (t) {
        var e = t.data || [], r = n([], e, [], "indicator_"), a = new i(r, this);
        return a.initData(e), a
      },
      formatTooltip: function (t) {
        var e = this.getRawValue(t), i = this[Te], n = i.getIndicatorAxes();
        return ("" == this._data[d](t) ? this.name : this._data[d](t)) + "<br/>" + r.map(n, function (t, i) {
            return t.name + " : " + e[i]
          }).join("<br />")
      },
      defaultOption: {
        zlevel: 0,
        z: 2,
        coordinateSystem: "radar",
        legendHoverLink: !0,
        radarIndex: 0,
        lineStyle: {normal: {width: 2, type: "solid"}},
        label: {normal: {position: "top"}},
        symbol: "emptyCircle",
        symbolSize: 4
      }
    });
    return a
  }), e("echarts/visual/dataColor", [Pe], function () {
    return function (t, e) {
      var i = {};
      e.eachRawSeriesByType(t, function (t) {
        var n = t.getRawData(), r = {};
        if (!e.isSeriesFiltered(t)) {
          var a = t[we]();
          a.each(function (t) {
            var e = a.getRawIndex(t);
            r[e] = t
          }), n.each(function (e) {
            var o = n[m](e), s = r[e], l = a[w](s, "color", !0);
            if (l)n.setItemVisual(e, "color", l); else {
              var c = o.get("itemStyle.normal.color") || t.getColorFromPalette(n[d](e), i);
              n.setItemVisual(e, "color", c), a.setItemVisual(s, "color", c)
            }
          })
        }
      })
    }
  }), e("echarts/chart/radar/radarLayout", [Pe], function () {
    return function (t) {
      t.eachSeriesByType("radar", function (t) {
        function e(t, e) {
          n[e] = n[e] || [], n[e][a] = r[M](t, a)
        }

        var i = t[we](), n = [], r = t[Te];
        if (r) {
          for (var a = 0; a < r.getIndicatorAxes()[ne]; a++) {
            var o = i[S][a];
            i.each(o, e)
          }
          i.each(function (t) {
            n[t][0] && n[t].push(n[t][0].slice()), i.setItemLayout(t, n[t])
          })
        }
      })
    }
  }), e("echarts/processor/dataFilter", [], function () {
    return function (t, e) {
      var i = e.findComponents({mainType: "legend"});
      i && i[ne] && e.eachSeriesByType(t, function (t) {
        var e = t[we]();
        e.filterSelf(function (t) {
          for (var n = e[d](t), r = 0; r < i[ne]; r++)if (!i[r].isSelected(n))return !1;
          return !0
        }, this)
      }, this)
    }
  }), e("echarts/chart/radar/backwardCompat", [Pe, Le], function (t) {
    var e = t(Le);
    return function (t) {
      var i = t.polar;
      if (i) {
        e[Z](i) || (i = [i]);
        var n = [];
        e.each(i, function (i) {
          i.indicator ? (i.type && !i.shape && (i.shape = i.type), t.radar = t.radar || [], e[Z](t.radar) || (t.radar = [t.radar]), t.radar.push(i)) : n.push(i)
        }), t.polar = n
      }
      e.each(t[ie], function (t) {
        "radar" === t.type && t.polarIndex && (t.radarIndex = t.polarIndex)
      })
    }
  }), e("echarts/util/graphic", [Pe, Le, "zrender/tool/path", "zrender/graphic/Path", "zrender/tool/color", "zrender/core/matrix", be, "zrender/graphic/Gradient", "zrender/container/Group", "zrender/graphic/Image", "zrender/graphic/Text", "zrender/graphic/shape/Circle", "zrender/graphic/shape/Sector", "zrender/graphic/shape/Ring", "zrender/graphic/shape/Polygon", "zrender/graphic/shape/Polyline", "zrender/graphic/shape/Rect", "zrender/graphic/shape/Line", "zrender/graphic/shape/BezierCurve", "zrender/graphic/shape/Arc", "zrender/graphic/CompoundPath", "zrender/graphic/LinearGradient", "zrender/graphic/RadialGradient", "zrender/core/BoundingRect"], function (t) {
    function e(t) {
      return null != t && "none" != t
    }

    function i(t) {
      return typeof t === ye ? T.lift(t, -.1) : t
    }

    function n(t) {
      if (t.__hoverStlDirty) {
        var n = t.style[c], r = t.style.fill, a = t.__hoverStl;
        a.fill = a.fill || (e(r) ? i(r) : null), a[c] = a[c] || (e(n) ? i(n) : null);
        var o = {};
        for (var s in a)a.hasOwnProperty(s) && (o[s] = t.style[s]);
        t.__normalStl = o, t.__hoverStlDirty = !1
      }
    }

    function r(t) {
      t.__isHover || (n(t), t.useHoverLayer ? t.__zr && t.__zr.addHover(t, t.__hoverStl) : (t[X](t.__hoverStl), t.z2 += 1), t.__isHover = !0)
    }

    function a(t) {
      if (t.__isHover) {
        var e = t.__normalStl;
        t.useHoverLayer ? t.__zr && t.__zr.removeHover(t) : (e && t[X](e), t.z2 -= 1), t.__isHover = !1
      }
    }

    function o(t) {
      "group" === t.type ? t.traverse(function (t) {
        "group" !== t.type && r(t)
      }) : r(t)
    }

    function s(t) {
      "group" === t.type ? t.traverse(function (t) {
        "group" !== t.type && a(t)
      }) : a(t)
    }

    function d(t, e) {
      t.__hoverStl = t.hoverStyle || e || {}, t.__hoverStlDirty = !0, t.__isHover && n(t)
    }

    function p() {
      !this.__isEmphasis && o(this)
    }

    function m() {
      !this.__isEmphasis && s(this)
    }

    function g() {
      this.__isEmphasis = !0, o(this)
    }

    function y() {
      this.__isEmphasis = !1, s(this)
    }

    function x(t, e, i, n, r, a) {
      typeof r === W && (a = r, r = null);
      var o = n && (n.ifEnableAnimation ? n.ifEnableAnimation() : n[v](_));
      if (o) {
        var s = t ? "Update" : "", l = n && n[v]("animationDuration" + s), c = n && n[v]("animationEasing" + s), u = n && n[v]("animationDelay" + s);
        typeof u === W && (u = u(r)), l > 0 ? e.animateTo(i, l, u || 0, c, a) : (e.attr(i), a && a())
      } else e.attr(i), a && a()
    }

    var b = t(Le), w = t("zrender/tool/path"), S = Math.round, M = t("zrender/graphic/Path"), T = t("zrender/tool/color"), C = t("zrender/core/matrix"), A = t(be), L = (t("zrender/graphic/Gradient"), {});
    return L.Group = t("zrender/container/Group"), L.Image = t("zrender/graphic/Image"), L.Text = t("zrender/graphic/Text"), L.Circle = t("zrender/graphic/shape/Circle"), L.Sector = t("zrender/graphic/shape/Sector"), L.Ring = t("zrender/graphic/shape/Ring"), L.Polygon = t("zrender/graphic/shape/Polygon"), L.Polyline = t("zrender/graphic/shape/Polyline"), L.Rect = t("zrender/graphic/shape/Rect"), L.Line = t("zrender/graphic/shape/Line"), L.BezierCurve = t("zrender/graphic/shape/BezierCurve"), L.Arc = t("zrender/graphic/shape/Arc"), L.CompoundPath = t("zrender/graphic/CompoundPath"), L.LinearGradient = t("zrender/graphic/LinearGradient"), L.RadialGradient = t("zrender/graphic/RadialGradient"), L.BoundingRect = t("zrender/core/BoundingRect"), L.extendShape = function (t) {
      return M[re](t)
    }, L.extendPath = function (t, e) {
      return w.extendFromString(t, e)
    }, L.makePath = function (t, e, i, n) {
      var r = w.createFromString(t, e), a = r[O]();
      if (i) {
        var o = a.width / a[ce];
        if (n === D) {
          var s, l = i[ce] * o;
          l <= i.width ? s = i[ce] : (l = i.width, s = l / o);
          var c = i.x + i.width / 2, u = i.y + i[ce] / 2;
          i.x = c - l / 2, i.y = u - s / 2, i.width = l, i[ce] = s
        }
        this.resizePath(r, i)
      }
      return r
    }, L.mergePath = w.mergePath, L.resizePath = function (t, e) {
      if (t[h]) {
        var i = t[O](), n = i.calculateTransform(e);
        t[h](n)
      }
    }, L.subPixelOptimizeLine = function (t) {
      var e = L.subPixelOptimize, i = t.shape, n = t.style[u];
      return S(2 * i.x1) === S(2 * i.x2) && (i.x1 = i.x2 = e(i.x1, n, !0)), S(2 * i.y1) === S(2 * i.y2) && (i.y1 = i.y2 = e(i.y1, n, !0)), t
    }, L.subPixelOptimizeRect = function (t) {
      var e = L.subPixelOptimize, i = t.shape, n = t.style[u], r = i.x, a = i.y, o = i.width, s = i[ce];
      return i.x = e(i.x, n, !0), i.y = e(i.y, n, !0), i.width = Math.max(e(r + o, n, !1) - i.x, 0 === o ? 0 : 1), i[ce] = Math.max(e(a + s, n, !1) - i.y, 0 === s ? 0 : 1), t
    }, L.subPixelOptimize = function (t, e, i) {
      var n = S(2 * t);
      return (n + S(e)) % 2 === 0 ? n / 2 : (n + (i ? 1 : -1)) / 2
    }, L.setHoverStyle = function (t, e) {
      "group" === t.type ? t.traverse(function (t) {
        "group" !== t.type && d(t, e)
      }) : d(t, e), t.on(te, p).on(J, m), t.on("emphasis", g).on(f, y)
    }, L.setText = function (t, e, i) {
      var n = e[v](z) || l, r = n[V](l) >= 0 ? "white" : i, a = e[me](G);
      b[re](t, {textDistance: e[v]("distance") || 5, textFont: a[B](), textPosition: n, textFill: a[R]() || r})
    }, L.updateProps = function (t, e, i, n, r) {
      x(!0, t, e, i, n, r)
    }, L.initProps = function (t, e, i, n, r) {
      x(!1, t, e, i, n, r)
    }, L.getTransform = function (t, e) {
      for (var i = C.identity([]); t && t !== e;)C.mul(i, t.getLocalTransform(), i), t = t.parent;
      return i
    }, L[h] = function (t, e, i) {
      return i && (e = C.invert([], e)), A[h]([], t, e)
    }, L.transformDirection = function (t, e, i) {
      var n = 0 === e[4] || 0 === e[5] || 0 === e[0] ? 1 : Math.abs(2 * e[4] / e[0]), r = 0 === e[4] || 0 === e[5] || 0 === e[2] ? 1 : Math.abs(2 * e[4] / e[2]), a = ["left" === t ? -n : "right" === t ? n : 0, "top" === t ? -r : t === ue ? r : 0];
      return a = L[h](a, e, i), Math.abs(a[0]) > Math.abs(a[1]) ? a[0] > 0 ? "right" : "left" : a[1] > 0 ? ue : "top"
    }, L.groupTransition = function (t, e, i) {
      function n(t) {
        var e = {};
        return t.traverse(function (t) {
          !t.isGroup && t.anid && (e[t.anid] = t)
        }), e
      }

      function r(t) {
        var e = {position: A.clone(t[z]), rotation: t.rotation};
        return t.shape && (e.shape = b[re]({}, t.shape)), e
      }

      if (t && e) {
        var a = n(t);
        e.traverse(function (t) {
          if (!t.isGroup && t.anid) {
            var e = a[t.anid];
            if (e) {
              var n = r(t);
              t.attr(r(e)), L.updateProps(t, n, i, t[Q])
            }
          }
        })
      }
    }, L
  }), e("echarts/component/axis", [Pe, "../coord/cartesian/AxisModel", "./axis/AxisView"], function (t) {
    t("../coord/cartesian/AxisModel"), t("./axis/AxisView")
  }), e("echarts/coord/cartesian/Grid", [Pe, "exports", "../../util/layout", "../../coord/axisHelper", Le, "./Cartesian2D", "./Axis2D", "./GridModel", "../../CoordinateSystem"], function (t) {
    function e(t, e, i) {
      return i.getComponent("grid", t.get("gridIndex")) === e
    }

    function i(t) {
      var e, i = t.model, n = i.getFormattedLabels(), r = 1, a = n[ne];
      a > 40 && (r = Math.ceil(a / 40));
      for (var o = 0; a > o; o += r)if (!t.isLabelIgnored(o)) {
        var s = i.getTextRect(n[o]);
        e ? e.union(s) : e = s
      }
      return e
    }

    function n(t, e, i) {
      this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this._initCartesian(t, e, i), this._model = t
    }

    function r(t, e) {
      var i = t[L](), n = i[0] + i[1];
      t.toGlobalCoord = "x" === t.dim ? function (t) {
        return t + e
      } : function (t) {
        return n - t + e
      }, t.toLocalCoord = "x" === t.dim ? function (t) {
        return t - e
      } : function (t) {
        return n - t + e
      }
    }

    var a = t("../../util/layout"), o = t("../../coord/axisHelper"), l = t(Le), c = t("./Cartesian2D"), u = t("./Axis2D"), h = l.each, d = o.ifAxisCrossZero, f = o.niceScaleExtent;
    t("./GridModel");
    var p = n[xe];
    return p.type = "grid", p.getRect = function () {
      return this._rect
    }, p[se] = function (t, e) {
      function i(t) {
        var e = n[t];
        for (var i in e) {
          var r = e[i];
          if (r && (r.type === s || !d(r)))return !0
        }
        return !1
      }

      var n = this._axesMap;
      this._updateScale(t, this._model), h(n.x, function (t) {
        f(t, t.model)
      }), h(n.y, function (t) {
        f(t, t.model)
      }), h(n.x, function (t) {
        i("y") && (t.onZero = !1)
      }), h(n.y, function (t) {
        i("x") && (t.onZero = !1)
      }), this[ge](this._model, e)
    }, p[ge] = function (t, e) {
      function n() {
        h(s, function (t) {
          var e = t.isHorizontal(), i = e ? [0, o.width] : [0, o[ce]], n = t.inverse ? 1 : 0;
          t.setExtent(i[n], i[1 - n]), r(t, e ? o.x : o.y)
        })
      }

      var o = a.getLayoutRect(t.getBoxLayoutParams(), {width: e[ve](), height: e[pe]()});
      this._rect = o;
      var s = this._axesList;
      n(), t.get("containLabel") && (h(s, function (t) {
        if (!t.model.get("axisLabel.inside")) {
          var e = i(t);
          if (e) {
            var n = t.isHorizontal() ? ce : "width", r = t.model.get("axisLabel.margin");
            o[n] -= e[n] + r, "top" === t[z] ? o.y += e[ce] + r : "left" === t[z] && (o.x += e.width + r)
          }
        }
      }), n())
    }, p.getAxis = function (t, e) {
      var i = this._axesMap[t];
      if (null != i) {
        if (null == e)for (var n in i)return i[n];
        return i[e]
      }
    }, p.getCartesian = function (t, e) {
      if (null != t && null != e) {
        var i = "x" + t + "y" + e;
        return this._coordsMap[i]
      }
      for (var n = 0, r = this._coordsList; n < r[ne]; n++)if (r[n].getAxis("x").index === t || r[n].getAxis("y").index === e)return r[n]
    }, p._initCartesian = function (t, i) {
      function n(n) {
        return function (c, h) {
          if (e(c, t, i)) {
            var d = c.get(z);
            "x" === n ? "top" !== d && d !== ue && (d = ue, r[d] && (d = "top" === d ? ue : "top")) : "left" !== d && "right" !== d && (d = "left", r[d] && (d = "left" === d ? "right" : "left")), r[d] = !0;
            var f = new u(n, o.createScaleByModel(c), [0, 0], c.get("type"), d), p = f.type === s;
            f.onBand = p && c.get("boundaryGap"), f.inverse = c.get("inverse"), f.onZero = c.get("axisLine.onZero"), c.axis = f, f.model = c, f.grid = this, f.index = h, this._axesList.push(f), a[n][h] = f, l[n]++
          }
        }
      }

      var r = {left: !1, right: !1, top: !1, bottom: !1}, a = {x: {}, y: {}}, l = {x: 0, y: 0};
      return i.eachComponent("xAxis", n("x"), this), i.eachComponent("yAxis", n("y"), this), l.x && l.y ? (this._axesMap = a, void h(a.x, function (t, e) {
        h(a.y, function (i, n) {
          var r = "x" + e + "y" + n, a = new c(r);
          a.grid = this, this._coordsMap[r] = a, this._coordsList.push(a), a.addAxis(t), a.addAxis(i)
        }, this)
      }, this)) : (this._axesMap = {}, void(this._axesList = []))
    }, p._updateScale = function (t, i) {
      function n(t, e, i) {
        h(i.coordDimToDataDim(e.dim), function (i) {
          e.scale.unionExtent(t.getDataExtent(i, e.scale.type !== x))
        })
      }

      l.each(this._axesList, function (t) {
        t.scale.setExtent(1 / 0, -1 / 0)
      }), t.eachSeries(function (r) {
        if ("cartesian2d" === r.get(Te)) {
          var a = r.get("xAxisIndex"), o = r.get("yAxisIndex"), s = t.getComponent("xAxis", a), l = t.getComponent("yAxis", o);
          if (!e(s, i, t) || !e(l, i, t))return;
          var c = this.getCartesian(a, o), u = r[we](), h = c.getAxis("x"), d = c.getAxis("y");
          "list" === u.type && (n(u, h, r), n(u, d, r))
        }
      }, this)
    }, n[le] = function (t, e) {
      var i = [];
      return t.eachComponent("grid", function (r, a) {
        var o = new n(r, t, e);
        o.name = "grid_" + a, o[ge](r, e), r[Te] = o, i.push(o)
      }), t.eachSeries(function (e) {
        if ("cartesian2d" === e.get(Te)) {
          var n = e.get("xAxisIndex"), r = e.get("yAxisIndex"), a = t.getComponent("xAxis", n), o = i[a.get("gridIndex")];
          e[Te] = o.getCartesian(n, r)
        }
      }), i
    }, n[S] = c[xe][S], t("../../CoordinateSystem").register("cartesian2d", n), n
  }), e("echarts/chart/bar/BarSeries", [Pe, "../../model/Series", "../helper/createListFromArray"], function (t) {
    var e = t("../../model/Series"), i = t("../helper/createListFromArray");
    return e[re]({
      type: "series.bar",
      dependencies: ["grid", "polar"],
      getInitialData: function (t, e) {
        return i(t.data, this, e)
      },
      getMarkerPosition: function (t) {
        var e = this[Te];
        if (e) {
          var i = e[M](t, !0), n = this[we](), r = n.getLayout("offset"), a = n.getLayout("size"), o = e[C]().isHorizontal() ? 0 : 1;
          return i[o] += r + a / 2, i
        }
        return [0 / 0, 0 / 0]
      },
      brushSelector: "rect",
      defaultOption: {
        zlevel: 0,
        z: 2,
        coordinateSystem: "cartesian2d",
        legendHoverLink: !0,
        xAxisIndex: 0,
        yAxisIndex: 0,
        barMinHeight: 0,
        itemStyle: {normal: {}, emphasis: {}}
      }
    })
  }), e("echarts/chart/bar/BarView", [Pe, Le, A, "../../model/Model", "./barItemStyle", p], function (t) {
    function e(t, e) {
      var i = t.width > 0 ? 1 : -1, n = t[ce] > 0 ? 1 : -1;
      e = Math.min(e, Math.abs(t.width), Math.abs(t[ce])), t.x += i * e / 2, t.y += n * e / 2, t.width -= i * e, t[ce] -= n * e
    }

    var i = t(Le), n = t(A);
    return i[re](t("../../model/Model")[xe], t("./barItemStyle")), t(p).extendChartView({
      type: "bar",
      render: function (t, e, i) {
        var n = t.get(Te);
        return "cartesian2d" === n && this._renderOnCartesian(t, e, i), this.group
      },
      _renderOnCartesian: function (t) {
        function r(r, a) {
          var s = o.getItemLayout(r), l = o[m](r).get(d) || 0;
          e(s, l);
          var c = new n.Rect({shape: i[re]({}, s)});
          if (h) {
            var f = c.shape, p = u ? ce : "width", v = {};
            f[p] = 0, v[p] = s[p], n[a ? "updateProps" : "initProps"](c, {shape: v}, t, r)
          }
          return c
        }

        var a = this.group, o = t[we](), s = this._data, l = t[Te], c = l[C](), u = c.isHorizontal(), h = t.get(_), d = ["itemStyle", f, "barBorderWidth"];
        o.diff(s).add(function (t) {
          if (o.hasValue(t)) {
            var e = r(t);
            o.setItemGraphicEl(t, e), a.add(e)
          }
        })[se](function (i, l) {
          var c = s.getItemGraphicEl(l);
          if (!o.hasValue(i))return void a[ae](c);
          c || (c = r(i, !0));
          var u = o.getItemLayout(i), h = o[m](i).get(d) || 0;
          e(u, h), n.updateProps(c, {shape: u}, t, i), o.setItemGraphicEl(i, c), a.add(c)
        })[ae](function (e) {
          var i = s.getItemGraphicEl(e);
          i && (i.style.text = "", n.updateProps(i, {shape: {width: 0}}, t, e, function () {
            a[ae](i)
          }))
        }).execute(), this._updateStyle(t, o, u), this._data = o
      },
      _updateStyle: function (t, e, r) {
        function a(t, e, i, r, a) {
          n.setText(t, e, i), t.text = r, "outside" === t.textPosition && (t.textPosition = a)
        }

        e.eachItemGraphicEl(function (o, s) {
          var l = e[m](s), c = e[w](s, "color"), u = e[w](s, I), h = e.getItemLayout(s), d = l[me]("itemStyle.normal"), p = l[me]("itemStyle.emphasis").getBarItemStyle();
          o.setShape("r", d.get("barBorderRadius") || 0), o.useStyle(i[Me]({fill: c, opacity: u}, d.getBarItemStyle()));
          var v = r ? h[ce] > 0 ? ue : "top" : h.width > 0 ? "left" : "right", g = l[me]("label.normal"), y = l[me]("label.emphasis"), x = o.style;
          g.get("show") ? a(x, g, c, i.retrieve(t.getFormattedLabel(s, f), t.getRawValue(s)), v) : x.text = "", y.get("show") ? a(p, y, c, i.retrieve(t.getFormattedLabel(s, "emphasis"), t.getRawValue(s)), v) : p.text = "", n.setHoverStyle(o, p)
        })
      },
      remove: function (t) {
        var e = this.group;
        t.get(_) ? this._data && this._data.eachItemGraphicEl(function (i) {
          i.style.text = "", n.updateProps(i, {shape: {width: 0}}, t, i[Q], function () {
            e[ae](i)
          })
        }) : e[Ce]()
      }
    })
  }), e("echarts/layout/barGrid", [Pe, Le, "../util/number"], function (t) {
    function e(t) {
      return t.get("stack") || "__ec_stack_" + t[$]
    }

    function i(t) {
      return t.dim + t.index
    }

    function n(t) {
      var n = {};
      a.each(t, function (t) {
        var r = t[we](), a = t[Te], o = a[C](), c = o[L](), u = o.type === s ? o.getBandWidth() : Math.abs(c[1] - c[0]) / r.count(), h = n[i(o)] || {
            bandWidth: u,
            remainedWidth: u,
            autoWidthCount: 0,
            categoryGap: "20%",
            gap: "30%",
            stacks: {}
          }, d = h.stacks;
        n[i(o)] = h;
        var f = e(t);
        d[f] || h.autoWidthCount++, d[f] = d[f] || {width: 0, maxWidth: 0};
        var p = l(t.get("barWidth"), u), v = l(t.get("barMaxWidth"), u), m = t.get("barGap"), g = t.get("barCategoryGap");
        p && !d[f].width && (p = Math.min(h.remainedWidth, p), d[f].width = p, h.remainedWidth -= p), v && (d[f].maxWidth = v), null != m && (h.gap = m), null != g && (h.categoryGap = g)
      });
      var r = {};
      return a.each(n, function (t, e) {
        r[e] = {};
        var i = t.stacks, n = t.bandWidth, o = l(t.categoryGap, n), s = l(t.gap, 1), c = t.remainedWidth, u = t.autoWidthCount, h = (c - o) / (u + (u - 1) * s);
        h = Math.max(h, 0), a.each(i, function (t) {
          var e = t.maxWidth;
          !t.width && e && h > e && (e = Math.min(e, c), c -= e, t.width = e, u--)
        }), h = (c - o) / (u + (u - 1) * s), h = Math.max(h, 0);
        var d, f = 0;
        a.each(i, function (t) {
          t.width || (t.width = h), d = t, f += t.width * (1 + s)
        }), d && (f -= d.width * s);
        var p = -f / 2;
        a.each(i, function (t, i) {
          r[e][i] = r[e][i] || {offset: p, width: t.width}, p += t.width * (1 + s)
        })
      }), r
    }

    function r(t, r) {
      var o = n(a[H](r.getSeriesByType(t), function (t) {
        return !r.isSeriesFiltered(t) && t[Te] && "cartesian2d" === t[Te].type
      })), s = {};
      r.eachSeriesByType(t, function (t) {
        var n = t[we](), r = t[Te], a = r[C](), l = e(t), c = o[i(a)][l], u = c.offset, h = c.width, d = r.getOtherAxis(a), f = t.get("barMinHeight") || 0, p = a.onZero ? d.toGlobalCoord(d[b](0)) : d.getGlobalExtent()[0], v = r.dataToPoints(n, !0);
        s[l] = s[l] || [], n.setLayout({offset: u, size: h}), n.each(d.dim, function (t, e) {
          if (!isNaN(t)) {
            s[l][e] || (s[l][e] = {p: p, n: p});
            var i, r, a, o, c = t >= 0 ? "p" : "n", m = v[e], g = s[l][e][c];
            d.isHorizontal() ? (i = g, r = m[1] + u, a = m[0] - g, o = h, Math.abs(a) < f && (a = (0 > a ? -1 : 1) * f), s[l][e][c] += a) : (i = m[0] + u, r = g, a = h, o = m[1] - g, Math.abs(o) < f && (o = (0 >= o ? -1 : 1) * f), s[l][e][c] += o), n.setItemLayout(e, {
              x: i,
              y: r,
              width: a,
              height: o
            })
          }
        }, !0)
      }, this)
    }

    var a = t(Le), o = t("../util/number"), l = o.parsePercent;
    return r
  }), e("echarts/chart/pie/PieSeries", [Pe, "../../data/List", Le, "../../util/model", "../../data/helper/completeDimensions", "../../component/helper/selectableMixin", p], function (t) {
    var e = t("../../data/List"), i = t(Le), n = t("../../util/model"), r = t("../../data/helper/completeDimensions"), a = t("../../component/helper/selectableMixin"), s = t(p).extendSeriesModel({
      type: "series.pie",
      init: function (t) {
        s.superApply(this, "init", arguments), this.legendDataProvider = function () {
          return this._dataBeforeProcessed
        }, this.updateSelectedMap(t.data), this._defaultLabelLine(t)
      },
      mergeOption: function (t) {
        s.superCall(this, "mergeOption", t), this.updateSelectedMap(this[o].data)
      },
      getInitialData: function (t) {
        var i = r(["value"], t.data), n = new e(i, this);
        return n.initData(t.data), n
      },
      getDataParams: function (t) {
        var e = this._data, i = s.superCall(this, Y, t), n = e.getSum("value");
        return i.percent = n ? +(e.get("value", t) / n * 100).toFixed(2) : 0, i.$vars.push("percent"), i
      },
      _defaultLabelLine: function (t) {
        n.defaultEmphasis(t.labelLine, ["show"]);
        var e = t.labelLine[f], i = t.labelLine.emphasis;
        e.show = e.show && t.label[f].show, i.show = i.show && t.label.emphasis.show
      },
      defaultOption: {
        zlevel: 0,
        z: 2,
        legendHoverLink: !0,
        hoverAnimation: !0,
        center: ["50%", "50%"],
        radius: [0, "75%"],
        clockwise: !0,
        startAngle: 90,
        minAngle: 0,
        selectedOffset: 10,
        avoidLabelOverlap: !0,
        label: {normal: {rotate: !1, show: !0, position: "outer"}, emphasis: {}},
        labelLine: {normal: {show: !0, length: 15, length2: 15, smooth: !1, lineStyle: {width: 1, type: "solid"}}},
        itemStyle: {normal: {borderWidth: 1}, emphasis: {}},
        animationEasing: "cubicOut",
        data: []
      }
    });
    return i.mixin(s, a), s
  }), e("zrender/core/env", [], function () {
    function t(t) {
      var e = {}, i = {}, n = t.match(/Firefox\/([\d.]+)/), r = t.match(/MSIE\s([\d.]+)/) || t.match(/Trident\/.+?rv:(([\d.]+))/), a = t.match(/Edge\/([\d.]+)/);
      return n && (i.firefox = !0, i.version = n[1]), r && (i.ie = !0, i.version = r[1]), r && (i.ie = !0, i.version = r[1]), a && (i.edge = !0, i.version = a[1]), {
        browser: i,
        os: e,
        node: !1,
        canvasSupported: document[y]("canvas").getContext ? !0 : !1,
        touchEventsSupported: "ontouchstart"in window && !i.ie && !i.edge,
        pointerEventsSupported: "onpointerdown"in window && (i.edge || i.ie && i.version >= 10)
      }
    }

    var e = {};
    return e = "undefined" == typeof navigator ? {
      browser: {},
      os: {},
      node: !0,
      canvasSupported: !0
    } : t(navigator.userAgent)
  }), e("echarts/chart/pie/pieLayout", [Pe, "../../util/number", "./labelLayout", Le], function (t) {
    var e = t("../../util/number"), i = e.parsePercent, n = t("./labelLayout"), r = t(Le), a = 2 * Math.PI, o = Math.PI / 180;
    return function (t, s, l) {
      s.eachSeriesByType(t, function (t) {
        var s = t.get(D), c = t.get(T);
        r[Z](c) || (c = [0, c]), r[Z](s) || (s = [s, s]);
        var u = l[ve](), h = l[pe](), d = Math.min(u, h), f = i(s[0], u), p = i(s[1], h), v = i(c[0], d / 2), m = i(c[1], d / 2), g = t[we](), y = -t.get("startAngle") * o, x = t.get("minAngle") * o, _ = g.getSum("value"), b = Math.PI / (_ || g.count()) * 2, w = t.get("clockwise"), S = t.get("roseType"), M = g.getDataExtent("value");
        M[0] = 0;
        var C = a, A = 0, L = y, P = w ? 1 : -1;
        if (g.each("value", function (t, i) {
            var n;
            n = "area" !== S ? 0 === _ ? b : t * b : a / (g.count() || 1), x > n ? (n = x, C -= x) : A += t;
            var r = L + P * n;
            g.setItemLayout(i, {
              angle: n,
              startAngle: L,
              endAngle: r,
              clockwise: w,
              cx: f,
              cy: p,
              r0: v,
              r: S ? e.linearMap(t, M, [v, m]) : m
            }), L = r
          }, !0), a > C)if (.001 >= C) {
          var k = a / g.count();
          g.each(function (t) {
            var e = g.getItemLayout(t);
            e.startAngle = y + P * t * k, e.endAngle = y + P * (t + 1) * k
          })
        } else b = C / A, L = y, g.each("value", function (t, e) {
          var i = g.getItemLayout(e), n = i.angle === x ? x : t * b;
          i.startAngle = L, i.endAngle = L + P * n, L += n
        });
        n(t, m, u, h)
      })
    }
  }), e("echarts/action/createDataSelectAction", [Pe, "../echarts", Le], function (t) {
    var e = t("../echarts"), i = t(Le);
    return function (t, n) {
      i.each(n, function (i) {
        i[se] = "updateView", e.registerAction(i, function (e, n) {
          var r = {};
          return n.eachComponent({mainType: "series", subType: t, query: e}, function (t) {
            t[i.method] && t[i.method](e.name);
            var n = t[we]();
            n.each(function (e) {
              var i = n[d](e);
              r[i] = t.isSelected(i) || !1
            })
          }), {name: e.name, selected: r}
        })
      })
    }
  }), e("echarts/chart/pie/PieView", [Pe, A, Le, "../../view/Chart"], function (t) {
    function e(t, e, n, r) {
      var a = e[we](), o = this[Q], s = a[d](o), l = e.get("selectedOffset");
      r.dispatchAction({type: "pieToggleSelect", from: t, name: s, seriesId: e.id}), a.each(function (t) {
        i(a.getItemGraphicEl(t), a.getItemLayout(t), e.isSelected(a[d](t)), l, n)
      })
    }

    function i(t, e, i, n, r) {
      var a = (e.startAngle + e.endAngle) / 2, o = Math.cos(a), s = Math.sin(a), l = i ? n : 0, c = [o * l, s * l];
      r ? t.animate().when(200, {position: c}).start("bounceOut") : t.attr(z, c)
    }

    function n(t, e) {
      function i() {
        o[he] = o.hoverIgnore, s[he] = s.hoverIgnore
      }

      function n() {
        o[he] = o.normalIgnore, s[he] = s.normalIgnore
      }

      a.Group.call(this);
      var r = new a.Sector({z2: 2}), o = new a.Polyline, s = new a.Text;
      this.add(r), this.add(o), this.add(s), this.updateData(t, e, !0), this.on("emphasis", i).on(f, n).on(te, i).on(J, n)
    }

    function r(t, e, i, n, r) {
      var a = n[me](G), s = r === l || "inner" === r;
      return {
        fill: a[R]() || (s ? "#fff" : t[w](e, "color")),
        opacity: t[w](e, I),
        textFont: a[B](),
        text: o.retrieve(t.hostModel.getFormattedLabel(e, i), t[d](e))
      }
    }

    var a = t(A), o = t(Le), s = n[xe];
    s.updateData = function (t, e, n) {
      function r() {
        l.stopAnimation(!0), l.animateTo({shape: {r: h.r + 10}}, 300, "elasticOut")
      }

      function s() {
        l.stopAnimation(!0), l.animateTo({shape: {r: h.r}}, 300, "elasticOut")
      }

      var l = this.childAt(0), c = t.hostModel, u = t[m](e), h = t.getItemLayout(e), d = o[re]({}, h);
      d.label = null, n ? (l.setShape(d), l.shape.endAngle = h.startAngle, a.updateProps(l, {shape: {endAngle: h.endAngle}}, c, e)) : a.updateProps(l, {shape: d}, c, e);
      var p = u[me]("itemStyle"), v = t[w](e, "color");
      l.useStyle(o[Me]({
        lineJoin: "bevel",
        fill: v
      }, p[me](f)[Se]())), l.hoverStyle = p[me]("emphasis")[Se](), i(this, t.getItemLayout(e), u.get("selected"), c.get("selectedOffset"), c.get(_)), l.off(te).off(J).off("emphasis").off(f), u.get("hoverAnimation") && c.ifEnableAnimation() && l.on(te, r).on(J, s).on("emphasis", r).on(f, s), this._updateLabel(t, e), a.setHoverStyle(this)
    }, s._updateLabel = function (t, e) {
      var i = this.childAt(1), n = this.childAt(2), o = t.hostModel, s = t[m](e), l = t.getItemLayout(e), c = l.label, u = t[w](e, "color");
      a.updateProps(i, {shape: {points: c.linePoints || [[c.x, c.y], [c.x, c.y], [c.x, c.y]]}}, o, e), a.updateProps(n, {
        style: {
          x: c.x,
          y: c.y
        }
      }, o, e), n.attr({
        style: {textVerticalAlign: c.verticalAlign, textAlign: c[N], textFont: c.font},
        rotation: c.rotation,
        origin: [c.x, c.y],
        z2: 10
      });
      var h = s[me]("label.normal"), d = s[me]("label.emphasis"), p = s[me]("labelLine.normal"), v = s[me]("labelLine.emphasis"), g = h.get(z) || d.get(z);
      n[X](r(t, e, f, h, g)), n[he] = n.normalIgnore = !h.get("show"), n.hoverIgnore = !d.get("show"), i[he] = i.normalIgnore = !p.get("show"), i.hoverIgnore = !v.get("show"), i[X]({
        stroke: u,
        opacity: t[w](e, I)
      }), i[X](p[me]("lineStyle").getLineStyle()), n.hoverStyle = r(t, e, "emphasis", d, g), i.hoverStyle = v[me]("lineStyle").getLineStyle();
      var y = p.get("smooth");
      y && y === !0 && (y = .4), i.setShape({smooth: y})
    }, o[F](n, a.Group);
    var c = t("../../view/Chart")[re]({
      type: "pie", init: function () {
        var t = new a.Group;
        this._sectorGroup = t
      }, render: function (t, i, r, a) {
        if (!a || a.from !== this.uid) {
          var s = t[we](), l = this._data, c = this.group, u = i.get(_), h = !l, d = o.curry(e, this.uid, t, u, r), f = t.get("selectedMode");
          if (s.diff(l).add(function (t) {
              var e = new n(s, t);
              h && e.eachChild(function (t) {
                t.stopAnimation(!0)
              }), f && e.on("click", d), s.setItemGraphicEl(t, e), c.add(e)
            })[se](function (t, e) {
              var i = l.getItemGraphicEl(e);
              i.updateData(s, t), i.off("click"), f && i.on("click", d), c.add(i), s.setItemGraphicEl(t, i)
            })[ae](function (t) {
              var e = l.getItemGraphicEl(t);
              c[ae](e)
            }).execute(), u && h && s.count() > 0) {
            var p = s.getItemLayout(0), v = Math.max(r[ve](), r[pe]()) / 2, m = o.bind(c.removeClipPath, c);
            c.setClipPath(this._createClipPath(p.cx, p.cy, v, p.startAngle, p.clockwise, m, t))
          }
          this._data = s
        }
      }, _createClipPath: function (t, e, i, n, r, o, s) {
        var l = new a.Sector({shape: {cx: t, cy: e, r0: 0, r: i, startAngle: n, endAngle: n, clockwise: r}});
        return a.initProps(l, {shape: {endAngle: n + (r ? 1 : -1) * Math.PI * 2}}, s, o), l
      }
    });
    return c
  }), e("echarts/model/Global", [Pe, Le, "../util/model", "./Model", "./Component", "./globalDefault", "./mixin/colorPalette"], function (t) {
    function e(t, e) {
      for (var i in e)x.hasClass(i) || ("object" == typeof e[i] ? t[i] = t[i] ? u.merge(t[i], e[i], !1) : u.clone(e[i]) : null == t[i] && (t[i] = e[i]))
    }

    function i(t) {
      t = t, this[o] = {}, this[o][b] = 1, this._componentsMap = {}, this._seriesIndices = null, e(t, this._theme[o]), u.merge(t, _, !1), this.mergeOption(t)
    }

    function n(t, e) {
      u[Z](e) || (e = e ? [e] : []);
      var i = {};
      return f(e, function (e) {
        i[e] = (t[e] || []).slice()
      }), i
    }

    function r(t, e) {
      var i = {};
      f(e, function (t) {
        var e = t.exist;
        e && (i[e.id] = t)
      }), f(e, function (e) {
        var n = e[o];
        if (u.assert(!n || null == n.id || !i[n.id] || i[n.id] === e, "id duplicates: " + (n && n.id)), n && null != n.id && (i[n.id] = e), y(n)) {
          var r = a(t, n, e.exist);
          e.keyInfo = {mainType: t, subType: r}
        }
      }), f(e, function (t) {
        var e = t.exist, n = t[o], r = t.keyInfo;
        if (y(n)) {
          if (r.name = null != n.name ? n.name + "" : e ? e.name : "\x00-", e)r.id = e.id; else if (null != n.id)r.id = n.id + ""; else {
            var a = 0;
            do r.id = "\x00" + r.name + "\x00" + a++; while (i[r.id])
          }
          i[r.id] = t
        }
      })
    }

    function a(t, e, i) {
      var n = e.type ? e.type : i ? i.subType : x.determineSubType(t, e);
      return n
    }

    function s(t) {
      return v(t, function (t) {
          return t.componentIndex
        }) || []
    }

    function l(t, e) {
      return e.hasOwnProperty("subType") ? p(t, function (t) {
        return t.subType === e.subType
      }) : t
    }

    function c(t) {
    }

    var u = t(Le), h = t("../util/model"), d = t("./Model"), f = u.each, p = u[H], v = u.map, m = u[Z], g = u[V], y = u[oe], x = t("./Component"), _ = t("./globalDefault"), b = "\x00_ec_inner", w = d[re]({
      constructor: w, init: function (t, e, i, n) {
        i = i || {}, this[o] = null, this._theme = new d(i), this._optionManager = n
      }, setOption: function (t, e) {
        u.assert(!(b in t), "please use chart.getOption()"), this._optionManager.setOption(t, e), this.resetOption()
      }, resetOption: function (t) {
        var e = !1, n = this._optionManager;
        if (!t || "recreate" === t) {
          var r = n.mountOption("recreate" === t);
          this[o] && "recreate" !== t ? (this.restoreData(), this.mergeOption(r)) : i.call(this, r), e = !0
        }
        if (("timeline" === t || "media" === t) && this.restoreData(), !t || "recreate" === t || "timeline" === t) {
          var a = n.getTimelineOption(this);
          a && (this.mergeOption(a), e = !0)
        }
        if (!t || "recreate" === t || "media" === t) {
          var s = n.getMediaOption(this, this._api);
          s[ne] && f(s, function (t) {
            this.mergeOption(t, e = !0)
          }, this)
        }
        return e
      }, mergeOption: function (t) {
        function e(e, l) {
          var c = h.normalizeToArray(t[e]), d = h.mappingToExists(a[e], c);
          r(e, d);
          var p = n(a, l);
          i[e] = [], a[e] = [], f(d, function (t, n) {
            var r = t.exist, s = t[o];
            if (u.assert(y(s) || r, "Empty component definition"), s) {
              var l = x.getClass(e, t.keyInfo.subType, !0);
              if (r && r instanceof l)r.mergeOption(s, this), r.optionUpdated(s, !1); else {
                var c = u[re]({dependentModels: p, componentIndex: n}, t.keyInfo);
                r = new l(s, this, this, c), r.init(s, this, this, c), r.optionUpdated(null, !0)
              }
            } else r.mergeOption({}, this), r.optionUpdated({}, !1);
            a[e][n] = r, i[e][n] = r[o]
          }, this), e === ie && (this._seriesIndices = s(a[ie]))
        }

        var i = this[o], a = this._componentsMap, l = [];
        f(t, function (t, e) {
          null != t && (x.hasClass(e) ? l.push(e) : i[e] = null == i[e] ? u.clone(t) : u.merge(i[e], t, !0))
        }), x.topologicalTravel(l, x.getAllClassMainTypes(), e, this)
      }, getOption: function () {
        var t = u.clone(this[o]);
        return f(t, function (e, i) {
          if (x.hasClass(i)) {
            for (var e = h.normalizeToArray(e), n = e[ne] - 1; n >= 0; n--)h.isIdInner(e[n]) && e[ee](n, 1);
            t[i] = e
          }
        }), delete t[b], t
      }, getTheme: function () {
        return this._theme
      }, getComponent: function (t, e) {
        var i = this._componentsMap[t];
        return i ? i[e || 0] : void 0
      }, queryComponents: function (t) {
        var e = t.mainType;
        if (!e)return [];
        var i = t.index, n = t.id, r = t.name, a = this._componentsMap[e];
        if (!a || !a[ne])return [];
        var o;
        if (null != i)m(i) || (i = [i]), o = p(v(i, function (t) {
          return a[t]
        }), function (t) {
          return !!t
        }); else if (null != n) {
          var s = m(n);
          o = p(a, function (t) {
            return s && g(n, t.id) >= 0 || !s && t.id === n
          })
        } else if (null != r) {
          var c = m(r);
          o = p(a, function (t) {
            return c && g(r, t.name) >= 0 || !c && t.name === r
          })
        }
        return l(o, t)
      }, findComponents: function (t) {
        function e(t) {
          var e = r + "Index", i = r + "Id", n = r + "Name";
          return t && (t.hasOwnProperty(e) || t.hasOwnProperty(i) || t.hasOwnProperty(n)) ? {
            mainType: r,
            index: t[e],
            id: t[i],
            name: t[n]
          } : null
        }

        function i(e) {
          return t[H] ? p(e, t[H]) : e
        }

        var n = t.query, r = t.mainType, a = e(n), o = a ? this.queryComponents(a) : this._componentsMap[r];
        return i(l(o, t))
      }, eachComponent: function (t, e, i) {
        var n = this._componentsMap;
        if (typeof t === W)i = e, e = t, f(n, function (t, n) {
          f(t, function (t, r) {
            e.call(i, n, t, r)
          })
        }); else if (u.isString(t))f(n[t], e, i); else if (y(t)) {
          var r = this.findComponents(t);
          f(r, e, i)
        }
      }, getSeriesByName: function (t) {
        var e = this._componentsMap[ie];
        return p(e, function (e) {
          return e.name === t
        })
      }, getSeriesByIndex: function (t) {
        return this._componentsMap[ie][t]
      }, getSeriesByType: function (t) {
        var e = this._componentsMap[ie];
        return p(e, function (e) {
          return e.subType === t
        })
      }, getSeries: function () {
        return this._componentsMap[ie].slice()
      }, eachSeries: function (t, e) {
        c(this), f(this._seriesIndices, function (i) {
          var n = this._componentsMap[ie][i];
          t.call(e, n, i)
        }, this)
      }, eachRawSeries: function (t, e) {
        f(this._componentsMap[ie], t, e)
      }, eachSeriesByType: function (t, e, i) {
        c(this), f(this._seriesIndices, function (n) {
          var r = this._componentsMap[ie][n];
          r.subType === t && e.call(i, r, n)
        }, this)
      }, eachRawSeriesByType: function (t, e, i) {
        return f(this.getSeriesByType(t), e, i)
      }, isSeriesFiltered: function (t) {
        return c(this), u[V](this._seriesIndices, t.componentIndex) < 0
      }, filterSeries: function (t, e) {
        c(this);
        var i = p(this._componentsMap[ie], t, e);
        this._seriesIndices = s(i)
      }, restoreData: function () {
        var t = this._componentsMap;
        this._seriesIndices = s(t[ie]);
        var e = [];
        f(t, function (t, i) {
          e.push(i)
        }), x.topologicalTravel(e, x.getAllClassMainTypes(), function (e) {
          f(t[e], function (t) {
            t.restoreData()
          })
        })
      }
    });
    return u.mixin(w, t("./mixin/colorPalette")), w
  }), e("echarts/CoordinateSystem", [Pe], function () {
    function t() {
      this._coordinateSystems = []
    }

    var e = {};
    return t[xe] = {
      constructor: t, create: function (t, i) {
        var n = [];
        for (var r in e) {
          var a = e[r][le](t, i);
          a && (n = n[g](a))
        }
        this._coordinateSystems = n
      }, update: function (t, e) {
        for (var i = this._coordinateSystems, n = 0; n < i[ne]; n++)i[n][se] && i[n][se](t, e)
      }
    }, t.register = function (t, i) {
      e[t] = i
    }, t.get = function (t) {
      return e[t]
    }, t
  }), e("echarts/model/Component", [Pe, "./Model", Le, "../util/component", "../util/clazz", "../util/layout", "./mixin/boxLayout"], function (t) {
    function e(t) {
      var e = [];
      return n.each(c.getClassesByMainType(t), function (t) {
        r.apply(e, t[xe].dependencies || [])
      }), n.map(e, function (t) {
        return s.parseClassType(t).main
      })
    }

    var i = t("./Model"), n = t(Le), r = Array[xe].push, a = t("../util/component"), s = t("../util/clazz"), l = t("../util/layout"), c = i[re]({
      type: "component",
      id: "",
      name: "",
      mainType: "",
      subType: "",
      componentIndex: 0,
      defaultOption: null,
      ecModel: null,
      dependentModels: [],
      uid: null,
      layoutMode: null,
      $constructor: function (t, e, r, o) {
        i.call(this, t, e, r, o), n[re](this, o), this.uid = a.getUID("componentModel")
      },
      init: function (t, e, i) {
        this.mergeDefaultAndTheme(t, i)
      },
      mergeDefaultAndTheme: function (t, e) {
        var i = this.layoutMode, r = i ? l.getLayoutParams(t) : {}, a = e.getTheme();
        n.merge(t, a.get(this.mainType)), n.merge(t, this.getDefaultOption()), i && l.mergeLayoutParam(t, r, i)
      },
      mergeOption: function (t) {
        n.merge(this[o], t, !0);
        var e = this.layoutMode;
        e && l.mergeLayoutParam(this[o], t, e)
      },
      optionUpdated: function () {
      },
      getDefaultOption: function () {
        if (!this.hasOwnProperty("__defaultOption")) {
          for (var t = [], e = this.constructor; e;) {
            var i = e[xe].defaultOption;
            i && t.push(i), e = e.superClass
          }
          for (var r = {}, a = t[ne] - 1; a >= 0; a--)r = n.merge(r, t[a], !0);
          this.__defaultOption = r
        }
        return this.__defaultOption
      }
    });
    return s.enableClassManagement(c, {registerWhenExtend: !0}), a.enableSubTypeDefaulter(c), a.enableTopologicalTravel(c, e), n.mixin(c, t("./mixin/boxLayout")), c
  }), e("echarts/ExtensionAPI", [Pe, Le], function (t) {
    function e(t) {
      i.each(n, function (e) {
        this[e] = i.bind(t[e], t)
      }, this)
    }

    var i = t(Le), n = ["getDom", "getZr", ve, pe, "dispatchAction", "isDisposed", "on", "off", "getDataURL", "getConnectedDataURL", me, "getOption"];
    return e
  }), e("echarts/model/Series", [Pe, Le, "../util/format", "../util/model", "./Component", "./mixin/colorPalette", "zrender/core/env"], function (t) {
    var e = t(Le), i = t("../util/format"), n = t("../util/model"), r = t("./Component"), s = t("./mixin/colorPalette"), l = t("zrender/core/env"), c = i.encodeHTML, u = i.addCommas, h = r[re]({
      type: "series.__base__",
      seriesIndex: 0,
      coordinateSystem: null,
      defaultOption: null,
      legendDataProvider: null,
      visualColorAccessPath: "itemStyle.normal.color",
      init: function (t, e, i) {
        this[$] = this.componentIndex, this.mergeDefaultAndTheme(t, i), this._dataBeforeProcessed = this.getInitialData(t, i), this._data = this._dataBeforeProcessed.cloneShallow()
      },
      mergeDefaultAndTheme: function (t, i) {
        e.merge(t, i.getTheme().get(this.subType)), e.merge(t, this.getDefaultOption()), n.defaultEmphasis(t.label, n.LABEL_OPTIONS), this.fillDataTextStyle(t.data)
      },
      mergeOption: function (t, i) {
        t = e.merge(this[o], t, !0), this.fillDataTextStyle(t.data);
        var n = this.getInitialData(t, i);
        n && (this._data = n, this._dataBeforeProcessed = n.cloneShallow())
      },
      fillDataTextStyle: function (t) {
        if (t)for (var e = 0; e < t[ne]; e++)t[e] && t[e].label && n.defaultEmphasis(t[e].label, n.LABEL_OPTIONS)
      },
      getInitialData: function () {
      },
      getData: function (t) {
        return null == t ? this._data : this._data.getLinkedData(t)
      },
      setData: function (t) {
        this._data = t
      },
      getRawData: function () {
        return this._dataBeforeProcessed
      },
      coordDimToDataDim: function (t) {
        return [t]
      },
      dataDimToCoordDim: function (t) {
        return t
      },
      getBaseAxis: function () {
        var t = this[Te];
        return t && t[C] && t[C]()
      },
      formatTooltip: function (t, n) {
        function r(t) {
          return e.map(t, function (t, e) {
            var r = a.getDimensionInfo(e), o = r && r.type;
            return o === x ? t : "time" === o ? n ? "" : i.formatTime("yyyy/mm/dd hh:mm:ss", t) : u(t)
          })[H](function (t) {
            return !!t
          }).join(", ")
        }

        var a = this._data, o = this.getRawValue(t), s = e[Z](o) ? r(o) : u(o), l = a[d](t), h = a[w](t, "color"), f = '<span style="display:inline-block;margin-right:5px;border-radius:10px;width:9px;height:9px;background-color:' + h + '"></span>', p = this.name;
        return "\x00-" === p && (p = ""), n ? f + c(this.name) + " : " + s : (p && c(p) + "<br />") + f + (l ? c(l) + " : " + s : s)
      },
      ifEnableAnimation: function () {
        if (l.node)return !1;
        var t = this[v](_);
        return t && this[we]().count() > this[v]("animationThreshold") && (t = !1), t
      },
      restoreData: function () {
        this._data = this._dataBeforeProcessed.cloneShallow()
      },
      getColorFromPalette: function (t, e) {
        var i = this[a], n = s.getColorFromPalette.call(this, t, e);
        return n || (n = i.getColorFromPalette(t, e)), n
      },
      getAxisTooltipDataIndex: null
    });
    return e.mixin(h, n.dataFormatMixin), e.mixin(h, s), h
  }), e("echarts/model/OptionManager", [Pe, Le, "../util/model", "./Component"], function (t) {
    function e(t) {
      this._api = t, this._timelineOptions = [], this._mediaList = [], this._mediaDefault, this._currentMediaIndices = [], this._optionBackup, this._newBaseOption
    }

    function i(t, e, i) {
      var n, r, a = [], s = [], c = t.timeline;
      if (t.baseOption && (r = t.baseOption), (c || t.options) && (r = r || {}, a = (t.options || []).slice()), t.media) {
        r = r || {};
        var u = t.media;
        h(u, function (t) {
          t && t[o] && (t.query ? s.push(t) : n || (n = t))
        })
      }
      return r || (r = t), r.timeline || (r.timeline = c), h([r][g](a)[g](l.map(s, function (t) {
        return t[o]
      })), function (t) {
        h(e, function (e) {
          e(t, i)
        })
      }), {baseOption: r, timelineOptions: a, mediaDefault: n, mediaList: s}
    }

    function n(t, e, i) {
      var n = {width: e, height: i, aspectratio: e / i}, a = !0;
      return l.each(t, function (t, e) {
        var i = e.match(v);
        if (i && i[1] && i[2]) {
          var o = i[1], s = i[2][_e]();
          r(n[s], t, o) || (a = !1)
        }
      }), a
    }

    function r(t, e, i) {
      return "min" === i ? t >= e : "max" === i ? e >= t : t === e
    }

    function a(t, e) {
      return t.join(",") === e.join(",")
    }

    function s(t, e) {
      e = e || {}, h(e, function (e, i) {
        if (null != e) {
          var n = t[i];
          if (u.hasClass(i)) {
            e = c.normalizeToArray(e), n = c.normalizeToArray(n);
            var r = c.mappingToExists(n, e);
            t[i] = f(r, function (t) {
              return t[o] && t.exist ? p(t.exist, t[o], !0) : t.exist || t[o]
            })
          } else t[i] = p(n, e, !0)
        }
      })
    }

    var l = t(Le), c = t("../util/model"), u = t("./Component"), h = l.each, d = l.clone, f = l.map, p = l.merge, v = /^(min|max)?(.+)$/;
    return e[xe] = {
      constructor: e, setOption: function (t, e) {
        t = d(t, !0);
        var n = this._optionBackup, r = i.call(this, t, e, !n);
        this._newBaseOption = r.baseOption, n ? (s(n.baseOption, r.baseOption), r.timelineOptions[ne] && (n.timelineOptions = r.timelineOptions), r.mediaList[ne] && (n.mediaList = r.mediaList), r.mediaDefault && (n.mediaDefault = r.mediaDefault)) : this._optionBackup = r
      }, mountOption: function (t) {
        var e = this._optionBackup;
        return this._timelineOptions = f(e.timelineOptions, d), this._mediaList = f(e.mediaList, d), this._mediaDefault = d(e.mediaDefault), this._currentMediaIndices = [], d(t ? e.baseOption : this._newBaseOption)
      }, getTimelineOption: function (t) {
        var e, i = this._timelineOptions;
        if (i[ne]) {
          var n = t.getComponent("timeline");
          n && (e = d(i[n.getCurrentIndex()], !0))
        }
        return e
      }, getMediaOption: function () {
        var t = this._api[ve](), e = this._api[pe](), i = this._mediaList, r = this._mediaDefault, s = [], l = [];
        if (!i[ne] && !r)return l;
        for (var c = 0, u = i[ne]; u > c; c++)n(i[c].query, t, e) && s.push(c);
        return !s[ne] && r && (s = [-1]), s[ne] && !a(s, this._currentMediaIndices) && (l = f(s, function (t) {
          return d(-1 === t ? r[o] : i[t][o])
        })), this._currentMediaIndices = s, l
      }
    }, e
  }), e("echarts/view/Component", [Pe, "zrender/container/Group", "../util/component", "../util/clazz"], function (t) {
    var e = t("zrender/container/Group"), i = t("../util/component"), n = t("../util/clazz"), r = function () {
      this.group = new e, this.uid = i.getUID("viewComponent")
    };
    r[xe] = {
      constructor: r, init: function () {
      }, render: function () {
      }, dispose: function () {
      }
    };
    var a = r[xe];
    return a.updateView = a.updateLayout = a.updateVisual = function () {
    }, n.enableClassExtend(r), n.enableClassManagement(r, {registerWhenExtend: !0}), r
  }), e("echarts/view/Chart", [Pe, "zrender/container/Group", "../util/component", "../util/clazz"], function (t) {
    function e() {
      this.group = new r, this.uid = a.getUID("viewChart")
    }

    function i(t, e) {
      if (t && (t.trigger(e), "group" === t.type))for (var n = 0; n < t.childCount(); n++)i(t.childAt(n), e)
    }

    function n(t, e, n) {
      var r = e && e[Q], a = e && e.name;
      if (null != r)for (var o = r instanceof Array ? r : [r], s = 0, l = o[ne]; l > s; s++)i(t.getItemGraphicEl(o[s]), n); else if (a)for (var c = a instanceof Array ? a : [a], s = 0, l = c[ne]; l > s; s++) {
        var r = t.indexOfName(c[s]);
        i(t.getItemGraphicEl(r), n)
      } else t.eachItemGraphicEl(function (t) {
        i(t, n)
      })
    }

    var r = t("zrender/container/Group"), a = t("../util/component"), o = t("../util/clazz");
    e[xe] = {
      type: "chart", init: function () {
      }, render: function () {
      }, highlight: function (t, e, i, r) {
        n(t[we](), r, "emphasis")
      }, downplay: function (t, e, i, r) {
        n(t[we](), r, f)
      }, remove: function () {
        this.group[Ce]()
      }, dispose: function () {
      }
    };
    var s = e[xe];
    return s.updateView = s.updateLayout = s.updateVisual = function (t, e, i, n) {
      this.render(t, e, i, n)
    }, o.enableClassExtend(e), o.enableClassManagement(e, {registerWhenExtend: !0}), e
  }), e("echarts/visual/seriesColor", [Pe, "zrender/graphic/Gradient"], function (t) {
    var e = t("zrender/graphic/Gradient");
    return function (t) {
      function i(i) {
        var n = (i.visualColorAccessPath || "itemStyle.normal.color").split("."), r = i[we](), a = i.get(n) || i.getColorFromPalette(i.get("name"));
        r.setVisual("color", a), t.isSeriesFiltered(i) || (typeof a !== W || a instanceof e || r.each(function (t) {
          r.setItemVisual(t, "color", a(i[Y](t)))
        }), r.each(function (t) {
          var e = r[m](t), i = e.get(n, !0);
          null != i && r.setItemVisual(t, "color", i)
        }))
      }

      t.eachRawSeries(i)
    }
  }), e("echarts/loading/default", [Pe, "../util/graphic", Le], function (t) {
    var e = t("../util/graphic"), i = t(Le), n = Math.PI;
    return function (t, r) {
      r = r || {}, i[Me](r, {
        text: "loading",
        color: "#c23531",
        textColor: "#000",
        maskColor: "rgba(255, 255, 255, 0.8)",
        zlevel: 0
      });
      var a = new e.Rect({style: {fill: r.maskColor}, zlevel: r[j], z: 1e4}), o = new e.Arc({
        shape: {
          startAngle: -n / 2,
          endAngle: -n / 2 + .1,
          r: 10
        }, style: {stroke: r.color, lineCap: "round", lineWidth: 5}, zlevel: r[j], z: 10001
      }), s = new e.Rect({
        style: {
          fill: "none",
          text: r.text,
          textPosition: "right",
          textDistance: 10,
          textFill: r.textColor
        }, zlevel: r[j], z: 10001
      });
      o.animateShape(!0).when(1e3, {endAngle: 3 * n / 2}).start("circularInOut"), o.animateShape(!0).when(1e3, {startAngle: 3 * n / 2}).delay(300).start("circularInOut");
      var l = new e.Group;
      return l.add(o), l.add(s), l.add(a), l[ge] = function () {
        var e = t[ve]() / 2, i = t[pe]() / 2;
        o.setShape({cx: e, cy: i});
        var n = o.shape.r;
        s.setShape({x: e - n, y: i - n, width: 2 * n, height: 2 * n}), a.setShape({
          x: 0,
          y: 0,
          width: t[ve](),
          height: t[pe]()
        })
      }, l[ge](), l
    }
  }), e("zrender/mixin/Eventful", [Pe], function () {
    var t = Array[xe].slice, e = function () {
      this._$handlers = {}
    };
    return e[xe] = {
      constructor: e, one: function (t, e, i) {
        var n = this._$handlers;
        if (!e || !t)return this;
        n[t] || (n[t] = []);
        for (var r = 0; r < n[t][ne]; r++)if (n[t][r].h === e)return this;
        return n[t].push({h: e, one: !0, ctx: i || this}), this
      }, on: function (t, e, i) {
        var n = this._$handlers;
        if (!e || !t)return this;
        n[t] || (n[t] = []);
        for (var r = 0; r < n[t][ne]; r++)if (n[t][r].h === e)return this;
        return n[t].push({h: e, one: !1, ctx: i || this}), this
      }, isSilent: function (t) {
        var e = this._$handlers;
        return e[t] && e[t][ne]
      }, off: function (t, e) {
        var i = this._$handlers;
        if (!t)return this._$handlers = {}, this;
        if (e) {
          if (i[t]) {
            for (var n = [], r = 0, a = i[t][ne]; a > r; r++)i[t][r].h != e && n.push(i[t][r]);
            i[t] = n
          }
          i[t] && 0 === i[t][ne] && delete i[t]
        } else delete i[t];
        return this
      }, trigger: function (e) {
        if (this._$handlers[e]) {
          var i = arguments, n = i[ne];
          n > 3 && (i = t.call(i, 1));
          for (var r = this._$handlers[e], a = r[ne], o = 0; a > o;) {
            switch (n) {
              case 1:
                r[o].h.call(r[o].ctx);
                break;
              case 2:
                r[o].h.call(r[o].ctx, i[1]);
                break;
              case 3:
                r[o].h.call(r[o].ctx, i[1], i[2]);
                break;
              default:
                r[o].h.apply(r[o].ctx, i)
            }
            r[o].one ? (r[ee](o, 1), a--) : o++
          }
        }
        return this
      }, triggerWithContext: function (e) {
        if (this._$handlers[e]) {
          var i = arguments, n = i[ne];
          n > 4 && (i = t.call(i, 1, i[ne] - 1));
          for (var r = i[i[ne] - 1], a = this._$handlers[e], o = a[ne], s = 0; o > s;) {
            switch (n) {
              case 1:
                a[s].h.call(r);
                break;
              case 2:
                a[s].h.call(r, i[1]);
                break;
              case 3:
                a[s].h.call(r, i[1], i[2]);
                break;
              default:
                a[s].h.apply(r, i)
            }
            a[s].one ? (a[ee](s, 1), o--) : s++
          }
        }
        return this
      }
    }, e
  }), e("zrender/zrender", [Pe, "./core/guid", "./core/env", "./Handler", "./Storage", "./animation/Animation", "./dom/HandlerProxy", "./Painter"], function (t) {
    function e(t) {
      delete u[t]
    }

    var i = t("./core/guid"), n = t("./core/env"), r = t("./Handler"), a = t("./Storage"), o = t("./animation/Animation"), s = t("./dom/HandlerProxy"), l = !n[fe], c = {canvas: t("./Painter")}, u = {}, h = {};
    h.version = "3.1.2", h.init = function (t, e) {
      var n = new d(i(), t, e);
      return u[n.id] = n, n
    }, h.dispose = function (t) {
      if (t)t.dispose(); else {
        for (var e in u)u[e].dispose();
        u = {}
      }
      return h
    }, h.getInstance = function (t) {
      return u[t]
    }, h.registerPainter = function (t, e) {
      c[t] = e
    };
    var d = function (t, e, i) {
      i = i || {}, this.dom = e, this.id = t;
      var u = this, h = new a, d = i.renderer;
      if (l) {
        if (!c.vml)throw new Error("You need to require 'zrender/vml/vml' to support IE8");
        d = "vml"
      } else d && c[d] || (d = "canvas");
      var f = new c[d](e, h, i);
      this[de] = h, this.painter = f;
      var p = n.node ? null : new s(f.getViewportRoot());
      this.handler = new r(h, f, p), this[_] = new o({
        stage: {
          update: function () {
            u._needsRefresh && u.refreshImmediately(), u._needsRefreshHover && u.refreshHoverImmediately()
          }
        }
      }), this[_].start(), this._needsRefresh;
      var v = h.delFromMap, m = h.addToMap;
      h.delFromMap = function (t) {
        var e = h.get(t);
        v.call(h, t), e && e.removeSelfFromZr(u)
      }, h.addToMap = function (t) {
        m.call(h, t), t.addSelfToZr(u)
      }
    };
    return d[xe] = {
      constructor: d, getId: function () {
        return this.id
      }, add: function (t) {
        this[de].addRoot(t), this._needsRefresh = !0
      }, remove: function (t) {
        this[de].delRoot(t), this._needsRefresh = !0
      }, configLayer: function (t, e) {
        this.painter.configLayer(t, e), this._needsRefresh = !0
      }, refreshImmediately: function () {
        this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1
      }, refresh: function () {
        this._needsRefresh = !0
      }, addHover: function (t, e) {
        this.painter.addHover && (this.painter.addHover(t, e), this.refreshHover())
      }, removeHover: function (t) {
        this.painter.removeHover && (this.painter.removeHover(t), this.refreshHover())
      }, clearHover: function () {
        this.painter.clearHover && (this.painter.clearHover(), this.refreshHover())
      }, refreshHover: function () {
        this._needsRefreshHover = !0
      }, refreshHoverImmediately: function () {
        this._needsRefreshHover = !1, this.painter.refreshHover && this.painter.refreshHover()
      }, resize: function () {
        this.painter[ge](), this.handler[ge]()
      }, clearAnimation: function () {
        this[_].clear()
      }, getWidth: function () {
        return this.painter[ve]()
      }, getHeight: function () {
        return this.painter[pe]()
      }, pathToImage: function (t, e, n) {
        var r = i();
        return this.painter.pathToImage(r, t, e, n)
      }, setCursorStyle: function (t) {
        this.handler.setCursorStyle(t)
      }, on: function (t, e, i) {
        this.handler.on(t, e, i)
      }, off: function (t, e) {
        this.handler.off(t, e)
      }, trigger: function (t, e) {
        this.handler.trigger(t, e)
      }, clear: function () {
        this[de].delRoot(), this.painter.clear()
      }, dispose: function () {
        this[_].stop(), this.clear(), this[de].dispose(), this.painter.dispose(), this.handler.dispose(), this[_] = this[de] = this.painter = this.handler = null, e(this.id)
      }
    }, h
  }), e("zrender/core/timsort", [], function () {
    function t(t) {
      for (var e = 0; t >= l;)e |= 1 & t, t >>= 1;
      return t + e
    }

    function e(t, e, n, r) {
      var a = e + 1;
      if (a === n)return 1;
      if (r(t[a++], t[e]) < 0) {
        for (; n > a && r(t[a], t[a - 1]) < 0;)a++;
        i(t, e, a)
      } else for (; n > a && r(t[a], t[a - 1]) >= 0;)a++;
      return a - e
    }

    function i(t, e, i) {
      for (i--; i > e;) {
        var n = t[e];
        t[e++] = t[i], t[i--] = n
      }
    }

    function n(t, e, i, n, r) {
      for (n === e && n++; i > n; n++) {
        for (var a, o = t[n], s = e, l = n; l > s;)a = s + l >>> 1, r(o, t[a]) < 0 ? l = a : s = a + 1;
        var c = n - s;
        switch (c) {
          case 3:
            t[s + 3] = t[s + 2];
          case 2:
            t[s + 2] = t[s + 1];
          case 1:
            t[s + 1] = t[s];
            break;
          default:
            for (; c > 0;)t[s + c] = t[s + c - 1], c--
        }
        t[s] = o
      }
    }

    function r(t, e, i, n, r, a) {
      var o = 0, s = 0, l = 1;
      if (a(t, e[i + r]) > 0) {
        for (s = n - r; s > l && a(t, e[i + r + l]) > 0;)o = l, l = (l << 1) + 1, 0 >= l && (l = s);
        l > s && (l = s), o += r, l += r
      } else {
        for (s = r + 1; s > l && a(t, e[i + r - l]) <= 0;)o = l, l = (l << 1) + 1, 0 >= l && (l = s);
        l > s && (l = s);
        var c = o;
        o = r - l, l = r - c
      }
      for (o++; l > o;) {
        var u = o + (l - o >>> 1);
        a(t, e[i + u]) > 0 ? o = u + 1 : l = u
      }
      return l
    }

    function a(t, e, i, n, r, a) {
      var o = 0, s = 0, l = 1;
      if (a(t, e[i + r]) < 0) {
        for (s = r + 1; s > l && a(t, e[i + r - l]) < 0;)o = l, l = (l << 1) + 1, 0 >= l && (l = s);
        l > s && (l = s);
        var c = o;
        o = r - l, l = r - c
      } else {
        for (s = n - r; s > l && a(t, e[i + r + l]) >= 0;)o = l, l = (l << 1) + 1, 0 >= l && (l = s);
        l > s && (l = s), o += r, l += r
      }
      for (o++; l > o;) {
        var u = o + (l - o >>> 1);
        a(t, e[i + u]) < 0 ? l = u : o = u + 1
      }
      return l
    }

    function o(t, e) {
      function i(t, e) {
        d[y] = t, f[y] = e, y += 1
      }

      function n() {
        for (; y > 1;) {
          var t = y - 2;
          if (t >= 1 && f[t - 1] <= f[t] + f[t + 1] || t >= 2 && f[t - 2] <= f[t] + f[t - 1])f[t - 1] < f[t + 1] && t--; else if (f[t] > f[t + 1])break;
          s(t)
        }
      }

      function o() {
        for (; y > 1;) {
          var t = y - 2;
          t > 0 && f[t - 1] < f[t + 1] && t--, s(t)
        }
      }

      function s(i) {
        var n = d[i], o = f[i], s = d[i + 1], c = f[i + 1];
        f[i] = o + c, i === y - 3 && (d[i + 1] = d[i + 2], f[i + 1] = f[i + 2]), y--;
        var u = a(t[s], t, n, o, 0, e);
        n += u, o -= u, 0 !== o && (c = r(t[n + o - 1], t, s, c, c - 1, e), 0 !== c && (c >= o ? l(n, o, s, c) : h(n, o, s, c)))
      }

      function l(i, n, o, s) {
        var l = 0;
        for (l = 0; n > l; l++)x[l] = t[i + l];
        var u = 0, h = o, d = i;
        if (t[d++] = t[h++], 0 !== --s) {
          if (1 === n) {
            for (l = 0; s > l; l++)t[d + l] = t[h + l];
            return void(t[d + s] = x[u])
          }
          for (var f, v, m, g = p; ;) {
            f = 0, v = 0, m = !1;
            do if (e(t[h], x[u]) < 0) {
              if (t[d++] = t[h++], v++, f = 0, 0 === --s) {
                m = !0;
                break
              }
            } else if (t[d++] = x[u++], f++, v = 0, 1 === --n) {
              m = !0;
              break
            } while (g > (f | v));
            if (m)break;
            do {
              if (f = a(t[h], x, u, n, 0, e), 0 !== f) {
                for (l = 0; f > l; l++)t[d + l] = x[u + l];
                if (d += f, u += f, n -= f, 1 >= n) {
                  m = !0;
                  break
                }
              }
              if (t[d++] = t[h++], 0 === --s) {
                m = !0;
                break
              }
              if (v = r(x[u], t, h, s, 0, e), 0 !== v) {
                for (l = 0; v > l; l++)t[d + l] = t[h + l];
                if (d += v, h += v, s -= v, 0 === s) {
                  m = !0;
                  break
                }
              }
              if (t[d++] = x[u++], 1 === --n) {
                m = !0;
                break
              }
              g--
            } while (f >= c || v >= c);
            if (m)break;
            0 > g && (g = 0), g += 2
          }
          if (p = g, 1 > p && (p = 1), 1 === n) {
            for (l = 0; s > l; l++)t[d + l] = t[h + l];
            t[d + s] = x[u]
          } else {
            if (0 === n)throw new Error;
            for (l = 0; n > l; l++)t[d + l] = x[u + l]
          }
        } else for (l = 0; n > l; l++)t[d + l] = x[u + l]
      }

      function h(i, n, o, s) {
        var l = 0;
        for (l = 0; s > l; l++)x[l] = t[o + l];
        var u = i + n - 1, h = s - 1, d = o + s - 1, f = 0, v = 0;
        if (t[d--] = t[u--], 0 !== --n) {
          if (1 === s) {
            for (d -= n, u -= n, v = d + 1, f = u + 1, l = n - 1; l >= 0; l--)t[v + l] = t[f + l];
            return void(t[d] = x[h])
          }
          for (var m = p; ;) {
            var g = 0, y = 0, _ = !1;
            do if (e(x[h], t[u]) < 0) {
              if (t[d--] = t[u--], g++, y = 0, 0 === --n) {
                _ = !0;
                break
              }
            } else if (t[d--] = x[h--], y++, g = 0, 1 === --s) {
              _ = !0;
              break
            } while (m > (g | y));
            if (_)break;
            do {
              if (g = n - a(x[h], t, i, n, n - 1, e), 0 !== g) {
                for (d -= g, u -= g, n -= g, v = d + 1, f = u + 1, l = g - 1; l >= 0; l--)t[v + l] = t[f + l];
                if (0 === n) {
                  _ = !0;
                  break
                }
              }
              if (t[d--] = x[h--], 1 === --s) {
                _ = !0;
                break
              }
              if (y = s - r(t[u], x, 0, s, s - 1, e), 0 !== y) {
                for (d -= y, h -= y, s -= y, v = d + 1, f = h + 1, l = 0; y > l; l++)t[v + l] = x[f + l];
                if (1 >= s) {
                  _ = !0;
                  break
                }
              }
              if (t[d--] = t[u--], 0 === --n) {
                _ = !0;
                break
              }
              m--
            } while (g >= c || y >= c);
            if (_)break;
            0 > m && (m = 0), m += 2
          }
          if (p = m, 1 > p && (p = 1), 1 === s) {
            for (d -= n, u -= n, v = d + 1, f = u + 1, l = n - 1; l >= 0; l--)t[v + l] = t[f + l];
            t[d] = x[h]
          } else {
            if (0 === s)throw new Error;
            for (f = d - (s - 1), l = 0; s > l; l++)t[f + l] = x[l]
          }
        } else for (f = d - (s - 1), l = 0; s > l; l++)t[f + l] = x[l]
      }

      var d, f, p = c, v = 0, m = u, g = 0, y = 0;
      v = t[ne], 2 * u > v && (m = v >>> 1);
      var x = [];
      g = 120 > v ? 5 : 1542 > v ? 10 : 119151 > v ? 19 : 40, d = [], f = [], this.mergeRuns = n, this.forceMergeRuns = o, this.pushRun = i
    }

    function s(i, r, a, s) {
      a || (a = 0), s || (s = i[ne]);
      var c = s - a;
      if (!(2 > c)) {
        var u = 0;
        if (l > c)return u = e(i, a, s, r), void n(i, a, s, a + u, r);
        var h = new o(i, r), d = t(c);
        do {
          if (u = e(i, a, s, r), d > u) {
            var f = c;
            f > d && (f = d), n(i, a, a + f, a + u, r), u = f
          }
          h.pushRun(a, u), h.mergeRuns(), c -= u, a += u
        } while (0 !== c);
        h.forceMergeRuns()
      }
    }

    var l = 32, c = 7, u = 256;
    return s
  }), e("zrender/tool/color", [Pe], function () {
    function t(t) {
      return t = Math.round(t), 0 > t ? 0 : t > 255 ? 255 : t
    }

    function e(t) {
      return t = Math.round(t), 0 > t ? 0 : t > 360 ? 360 : t
    }

    function i(t) {
      return 0 > t ? 0 : t > 1 ? 1 : t
    }

    function n(e) {
      return t(e[ne] && "%" === e.charAt(e[ne] - 1) ? parseFloat(e) / 100 * 255 : parseInt(e, 10))
    }

    function r(t) {
      return i(t[ne] && "%" === t.charAt(t[ne] - 1) ? parseFloat(t) / 100 : parseFloat(t))
    }

    function a(t, e, i) {
      return 0 > i ? i += 1 : i > 1 && (i -= 1), 1 > 6 * i ? t + (e - t) * i * 6 : 1 > 2 * i ? e : 2 > 3 * i ? t + (e - t) * (2 / 3 - i) * 6 : t
    }

    function o(t, e, i) {
      return t + (e - t) * i
    }

    function s(t) {
      if (t) {
        t += "";
        var e = t[U](/ /g, "")[_e]();
        if (e in g)return g[e].slice();
        if ("#" !== e.charAt(0)) {
          var i = e[V]("("), a = e[V](")");
          if (-1 !== i && a + 1 === e[ne]) {
            var o = e.substr(0, i), s = e.substr(i + 1, a - (i + 1)).split(","), c = 1;
            switch (o) {
              case"rgba":
                if (4 !== s[ne])return;
                c = r(s.pop());
              case"rgb":
                if (3 !== s[ne])return;
                return [n(s[0]), n(s[1]), n(s[2]), c];
              case"hsla":
                if (4 !== s[ne])return;
                return s[3] = r(s[3]), l(s);
              case"hsl":
                if (3 !== s[ne])return;
                return l(s);
              default:
                return
            }
          }
        } else {
          if (4 === e[ne]) {
            var u = parseInt(e.substr(1), 16);
            if (!(u >= 0 && 4095 >= u))return;
            return [(3840 & u) >> 4 | (3840 & u) >> 8, 240 & u | (240 & u) >> 4, 15 & u | (15 & u) << 4, 1]
          }
          if (7 === e[ne]) {
            var u = parseInt(e.substr(1), 16);
            if (!(u >= 0 && 16777215 >= u))return;
            return [(16711680 & u) >> 16, (65280 & u) >> 8, 255 & u, 1]
          }
        }
      }
    }

    function l(e) {
      var i = (parseFloat(e[0]) % 360 + 360) % 360 / 360, n = r(e[1]), o = r(e[2]), s = .5 >= o ? o * (n + 1) : o + n - o * n, l = 2 * o - s, c = [t(255 * a(l, s, i + 1 / 3)), t(255 * a(l, s, i)), t(255 * a(l, s, i - 1 / 3))];
      return 4 === e[ne] && (c[3] = e[3]), c
    }

    function c(t) {
      if (t) {
        var e, i, n = t[0] / 255, r = t[1] / 255, a = t[2] / 255, o = Math.min(n, r, a), s = Math.max(n, r, a), l = s - o, c = (s + o) / 2;
        if (0 === l)e = 0, i = 0; else {
          i = .5 > c ? l / (s + o) : l / (2 - s - o);
          var u = ((s - n) / 6 + l / 2) / l, h = ((s - r) / 6 + l / 2) / l, d = ((s - a) / 6 + l / 2) / l;
          n === s ? e = d - h : r === s ? e = 1 / 3 + u - d : a === s && (e = 2 / 3 + h - u), 0 > e && (e += 1), e > 1 && (e -= 1)
        }
        var f = [360 * e, i, c];
        return null != t[3] && f.push(t[3]), f
      }
    }

    function u(t, e) {
      var i = s(t);
      if (i) {
        for (var n = 0; 3 > n; n++)i[n] = 0 > e ? i[n] * (1 - e) | 0 : (255 - i[n]) * e + i[n] | 0;
        return m(i, 4 === i[ne] ? "rgba" : "rgb")
      }
    }

    function h(t) {
      var e = s(t);
      return e ? ((1 << 24) + (e[0] << 16) + (e[1] << 8) + +e[2]).toString(16).slice(1) : void 0
    }

    function d(e, i, n) {
      if (i && i[ne] && e >= 0 && 1 >= e) {
        n = n || [0, 0, 0, 0];
        var r = e * (i[ne] - 1), a = Math.floor(r), s = Math.ceil(r), l = i[a], c = i[s], u = r - a;
        return n[0] = t(o(l[0], c[0], u)), n[1] = t(o(l[1], c[1], u)), n[2] = t(o(l[2], c[2], u)), n[3] = t(o(l[3], c[3], u)), n
      }
    }

    function f(e, n, r) {
      if (n && n[ne] && e >= 0 && 1 >= e) {
        var a = e * (n[ne] - 1), l = Math.floor(a), c = Math.ceil(a), u = s(n[l]), h = s(n[c]), d = a - l, f = m([t(o(u[0], h[0], d)), t(o(u[1], h[1], d)), t(o(u[2], h[2], d)), i(o(u[3], h[3], d))], "rgba");
        return r ? {color: f, leftIndex: l, rightIndex: c, value: a} : f
      }
    }

    function p(t, i, n, a) {
      return t = s(t), t ? (t = c(t), null != i && (t[0] = e(i)), null != n && (t[1] = r(n)), null != a && (t[2] = r(a)), m(l(t), "rgba")) : void 0
    }

    function v(t, e) {
      return t = s(t), t && null != e ? (t[3] = i(e), m(t, "rgba")) : void 0
    }

    function m(t, e) {
      var i = t[0] + "," + t[1] + "," + t[2];
      return ("rgba" === e || "hsva" === e || "hsla" === e) && (i += "," + t[3]), e + "(" + i + ")"
    }

    var g = {
      transparent: [0, 0, 0, 0],
      aliceblue: [240, 248, 255, 1],
      antiquewhite: [250, 235, 215, 1],
      aqua: [0, 255, 255, 1],
      aquamarine: [127, 255, 212, 1],
      azure: [240, 255, 255, 1],
      beige: [245, 245, 220, 1],
      bisque: [255, 228, 196, 1],
      black: [0, 0, 0, 1],
      blanchedalmond: [255, 235, 205, 1],
      blue: [0, 0, 255, 1],
      blueviolet: [138, 43, 226, 1],
      brown: [165, 42, 42, 1],
      burlywood: [222, 184, 135, 1],
      cadetblue: [95, 158, 160, 1],
      chartreuse: [127, 255, 0, 1],
      chocolate: [210, 105, 30, 1],
      coral: [255, 127, 80, 1],
      cornflowerblue: [100, 149, 237, 1],
      cornsilk: [255, 248, 220, 1],
      crimson: [220, 20, 60, 1],
      cyan: [0, 255, 255, 1],
      darkblue: [0, 0, 139, 1],
      darkcyan: [0, 139, 139, 1],
      darkgoldenrod: [184, 134, 11, 1],
      darkgray: [169, 169, 169, 1],
      darkgreen: [0, 100, 0, 1],
      darkgrey: [169, 169, 169, 1],
      darkkhaki: [189, 183, 107, 1],
      darkmagenta: [139, 0, 139, 1],
      darkolivegreen: [85, 107, 47, 1],
      darkorange: [255, 140, 0, 1],
      darkorchid: [153, 50, 204, 1],
      darkred: [139, 0, 0, 1],
      darksalmon: [233, 150, 122, 1],
      darkseagreen: [143, 188, 143, 1],
      darkslateblue: [72, 61, 139, 1],
      darkslategray: [47, 79, 79, 1],
      darkslategrey: [47, 79, 79, 1],
      darkturquoise: [0, 206, 209, 1],
      darkviolet: [148, 0, 211, 1],
      deeppink: [255, 20, 147, 1],
      deepskyblue: [0, 191, 255, 1],
      dimgray: [105, 105, 105, 1],
      dimgrey: [105, 105, 105, 1],
      dodgerblue: [30, 144, 255, 1],
      firebrick: [178, 34, 34, 1],
      floralwhite: [255, 250, 240, 1],
      forestgreen: [34, 139, 34, 1],
      fuchsia: [255, 0, 255, 1],
      gainsboro: [220, 220, 220, 1],
      ghostwhite: [248, 248, 255, 1],
      gold: [255, 215, 0, 1],
      goldenrod: [218, 165, 32, 1],
      gray: [128, 128, 128, 1],
      green: [0, 128, 0, 1],
      greenyellow: [173, 255, 47, 1],
      grey: [128, 128, 128, 1],
      honeydew: [240, 255, 240, 1],
      hotpink: [255, 105, 180, 1],
      indianred: [205, 92, 92, 1],
      indigo: [75, 0, 130, 1],
      ivory: [255, 255, 240, 1],
      khaki: [240, 230, 140, 1],
      lavender: [230, 230, 250, 1],
      lavenderblush: [255, 240, 245, 1],
      lawngreen: [124, 252, 0, 1],
      lemonchiffon: [255, 250, 205, 1],
      lightblue: [173, 216, 230, 1],
      lightcoral: [240, 128, 128, 1],
      lightcyan: [224, 255, 255, 1],
      lightgoldenrodyellow: [250, 250, 210, 1],
      lightgray: [211, 211, 211, 1],
      lightgreen: [144, 238, 144, 1],
      lightgrey: [211, 211, 211, 1],
      lightpink: [255, 182, 193, 1],
      lightsalmon: [255, 160, 122, 1],
      lightseagreen: [32, 178, 170, 1],
      lightskyblue: [135, 206, 250, 1],
      lightslategray: [119, 136, 153, 1],
      lightslategrey: [119, 136, 153, 1],
      lightsteelblue: [176, 196, 222, 1],
      lightyellow: [255, 255, 224, 1],
      lime: [0, 255, 0, 1],
      limegreen: [50, 205, 50, 1],
      linen: [250, 240, 230, 1],
      magenta: [255, 0, 255, 1],
      maroon: [128, 0, 0, 1],
      mediumaquamarine: [102, 205, 170, 1],
      mediumblue: [0, 0, 205, 1],
      mediumorchid: [186, 85, 211, 1],
      mediumpurple: [147, 112, 219, 1],
      mediumseagreen: [60, 179, 113, 1],
      mediumslateblue: [123, 104, 238, 1],
      mediumspringgreen: [0, 250, 154, 1],
      mediumturquoise: [72, 209, 204, 1],
      mediumvioletred: [199, 21, 133, 1],
      midnightblue: [25, 25, 112, 1],
      mintcream: [245, 255, 250, 1],
      mistyrose: [255, 228, 225, 1],
      moccasin: [255, 228, 181, 1],
      navajowhite: [255, 222, 173, 1],
      navy: [0, 0, 128, 1],
      oldlace: [253, 245, 230, 1],
      olive: [128, 128, 0, 1],
      olivedrab: [107, 142, 35, 1],
      orange: [255, 165, 0, 1],
      orangered: [255, 69, 0, 1],
      orchid: [218, 112, 214, 1],
      palegoldenrod: [238, 232, 170, 1],
      palegreen: [152, 251, 152, 1],
      paleturquoise: [175, 238, 238, 1],
      palevioletred: [219, 112, 147, 1],
      papayawhip: [255, 239, 213, 1],
      peachpuff: [255, 218, 185, 1],
      peru: [205, 133, 63, 1],
      pink: [255, 192, 203, 1],
      plum: [221, 160, 221, 1],
      powderblue: [176, 224, 230, 1],
      purple: [128, 0, 128, 1],
      red: [255, 0, 0, 1],
      rosybrown: [188, 143, 143, 1],
      royalblue: [65, 105, 225, 1],
      saddlebrown: [139, 69, 19, 1],
      salmon: [250, 128, 114, 1],
      sandybrown: [244, 164, 96, 1],
      seagreen: [46, 139, 87, 1],
      seashell: [255, 245, 238, 1],
      sienna: [160, 82, 45, 1],
      silver: [192, 192, 192, 1],
      skyblue: [135, 206, 235, 1],
      slateblue: [106, 90, 205, 1],
      slategray: [112, 128, 144, 1],
      slategrey: [112, 128, 144, 1],
      snow: [255, 250, 250, 1],
      springgreen: [0, 255, 127, 1],
      steelblue: [70, 130, 180, 1],
      tan: [210, 180, 140, 1],
      teal: [0, 128, 128, 1],
      thistle: [216, 191, 216, 1],
      tomato: [255, 99, 71, 1],
      turquoise: [64, 224, 208, 1],
      violet: [238, 130, 238, 1],
      wheat: [245, 222, 179, 1],
      white: [255, 255, 255, 1],
      whitesmoke: [245, 245, 245, 1],
      yellow: [255, 255, 0, 1],
      yellowgreen: [154, 205, 50, 1]
    };
    return {parse: s, lift: u, toHex: h, fastMapToColor: d, mapToColor: f, modifyHSL: p, modifyAlpha: v, stringify: m}
  }), e("echarts/preprocessor/backwardCompat", [Pe, Le, "./helper/compatStyle"], function (t) {
    function e(t, e) {
      e = e.split(",");
      for (var i = t, n = 0; n < e[ne] && (i = i && i[e[n]], null != i); n++);
      return i
    }

    function i(t, e, i, n) {
      e = e.split(",");
      for (var r, a = t, o = 0; o < e[ne] - 1; o++)r = e[o], null == a[r] && (a[r] = {}), a = a[r];
      (n || null == a[e[o]]) && (a[e[o]] = i)
    }

    function n(t) {
      c(o, function (e) {
        e[0]in t && !(e[1]in t) && (t[e[1]] = t[e[0]])
      })
    }

    var r = t(Le), a = t("./helper/compatStyle"), o = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", ue]], s = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"], l = ["bar", "boxplot", "candlestick", "chord", "effectScatter", "funnel", "gauge", "lines", "graph", "heatmap", "line", "map", "parallel", "pie", "radar", "sankey", "scatter", "treemap"], c = r.each;
    return function (t) {
      c(t[ie], function (t) {
        if (r[oe](t)) {
          var o = t.type;
          if (a(t), ("pie" === o || "gauge" === o) && null != t.clockWise && (t.clockwise = t.clockWise), "gauge" === o) {
            var s = e(t, "pointer.color");
            null != s && i(t, "itemStyle.normal.color", s)
          }
          for (var c = 0; c < l[ne]; c++)if (l[c] === t.type) {
            n(t);
            break
          }
        }
      }), t.dataRange && (t.visualMap = t.dataRange), c(s, function (e) {
        var i = t[e];
        i && (r[Z](i) || (i = [i]), c(i, function (t) {
          n(t)
        }))
      })
    }
  }), e("echarts/model/Model", [Pe, Le, "../util/clazz", "./mixin/lineStyle", "./mixin/areaStyle", "./mixin/textStyle", "./mixin/itemStyle"], function (t) {
    function e(t, e, i) {
      this.parentModel = e, this[a] = i, this[o] = t
    }

    var i = t(Le), n = t("../util/clazz");
    e[xe] = {
      constructor: e, init: null, mergeOption: function (t) {
        i.merge(this[o], t, !0)
      }, get: function (t, e) {
        if (!t)return this[o];
        typeof t === ye && (t = t.split("."));
        for (var i = this[o], n = this.parentModel, r = 0; r < t[ne] && (!t[r] || (i = i && "object" == typeof i ? i[t[r]] : null, null != i)); r++);
        return null == i && n && !e && (i = n.get(t)), i
      }, getShallow: function (t, e) {
        var i = this[o], n = i && i[t], r = this.parentModel;
        return null == n && r && !e && (n = r[v](t)), n
      }, getModel: function (t, i) {
        var n = this.get(t, !0), r = this.parentModel, o = new e(n, i || r && r[me](t), this[a]);
        return o
      }, isEmpty: function () {
        return null == this[o]
      }, restoreData: function () {
      }, clone: function () {
        var t = this.constructor;
        return new t(i.clone(this[o]))
      }, setReadOnly: function (t) {
        n.setReadOnly(this, t)
      }
    }, n.enableClassExtend(e);
    var r = i.mixin;
    return r(e, t("./mixin/lineStyle")), r(e, t("./mixin/areaStyle")), r(e, t("./mixin/textStyle")), r(e, t("./mixin/itemStyle")), e
  }), e("echarts/util/format", [Pe, Le, "./number", "zrender/contain/text"], function (t) {
    function e(t) {
      return isNaN(t) ? "-" : (t = (t + "").split("."), t[0][U](/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (t[ne] > 1 ? "." + t[1] : ""))
    }

    function i(t) {
      return t[_e]()[U](/-(.)/g, function (t, e) {
        return e.toUpperCase()
      })
    }

    function n(t) {
      var e = t[ne];
      return typeof t === q ? [t, t, t, t] : 2 === e ? [t[0], t[1], t[0], t[1]] : 3 === e ? [t[0], t[1], t[2], t[1]] : t
    }

    function r(t) {
      return String(t)[U](/&/g, "&amp;")[U](/</g, "&lt;")[U](/>/g, "&gt;")[U](/"/g, "&quot;")[U](/'/g, "&#39;")
    }

    function a(t, e) {
      return "{" + t + (null == e ? "" : e) + "}"
    }

    function o(t, e) {
      c[Z](e) || (e = [e]);
      var i = e[ne];
      if (!i)return "";
      for (var n = e[0].$vars || [], r = 0; r < n[ne]; r++) {
        var o = d[r];
        t = t[U](a(o), a(o, 0))
      }
      for (var s = 0; i > s; s++)for (var l = 0; l < n[ne]; l++)t = t[U](a(d[l], s), e[s][n[l]]);
      return t
    }

    function s(t, e) {
      ("week" === t || "month" === t || "quarter" === t || "half-year" === t || "year" === t) && (t = "MM-dd\nyyyy");
      var i = u.parseDate(e), n = i.getFullYear(), r = i.getMonth() + 1, a = i.getDate(), o = i.getHours(), s = i.getMinutes(), c = i.getSeconds();
      return t = t[U]("MM", l(r))[_e]()[U]("yyyy", n)[U]("yy", n % 100)[U]("dd", l(a))[U]("d", a)[U]("hh", l(o))[U]("h", o)[U]("mm", l(s))[U]("m", s)[U]("ss", l(c))[U]("s", c)
    }

    function l(t) {
      return 10 > t ? "0" + t : t
    }

    var c = t(Le), u = t("./number"), h = t("zrender/contain/text"), d = ["a", "b", "c", "d", "e", "f", "g"];
    return {
      normalizeCssArray: n,
      addCommas: e,
      toCamelCase: i,
      encodeHTML: r,
      formatTpl: o,
      formatTime: s,
      truncateText: h.truncateText
    }
  }), e("echarts/util/number", [Pe], function () {
    function t(t) {
      return t[U](/^\s+/, "")[U](/\s+$/, "")
    }

    var e = {}, i = 1e-4;
    return e.linearMap = function (t, e, i, n) {
      var r = e[1] - e[0], a = i[1] - i[0];
      if (0 === r)return 0 === a ? i[0] : (i[0] + i[1]) / 2;
      if (n)if (r > 0) {
        if (t <= e[0])return i[0];
        if (t >= e[1])return i[1]
      } else {
        if (t >= e[0])return i[0];
        if (t <= e[1])return i[1]
      } else {
        if (t === e[0])return i[0];
        if (t === e[1])return i[1]
      }
      return (t - e[0]) / r * a + i[0]
    }, e.parsePercent = function (e, i) {
      switch (e) {
        case D:
        case E:
          e = "50%";
          break;
        case"left":
        case"top":
          e = "0%";
          break;
        case"right":
        case ue:
          e = "100%"
      }
      return typeof e === ye ? t(e).match(/%$/) ? parseFloat(e) / 100 * i : parseFloat(e) : null == e ? 0 / 0 : +e
    }, e.round = function (t) {
      return +(+t).toFixed(10)
    }, e.asc = function (t) {
      return t.sort(function (t, e) {
        return t - e
      }), t
    }, e.getPrecision = function (t) {
      if (t = +t, isNaN(t))return 0;
      for (var e = 1, i = 0; Math.round(t * e) / e !== t;)e *= 10, i++;
      return i
    }, e.getPixelPrecision = function (t, e) {
      var i = Math.log, n = Math.LN10, r = Math.floor(i(t[1] - t[0]) / n), a = Math.round(i(Math.abs(e[1] - e[0])) / n);
      return Math.max(-r + a, 0)
    }, e.MAX_SAFE_INTEGER = 9007199254740991, e.remRadian = function (t) {
      var e = 2 * Math.PI;
      return (t % e + e) % e
    }, e.isRadianAroundZero = function (t) {
      return t > -i && i > t
    }, e.parseDate = function (t) {
      return t instanceof Date ? t : new Date(typeof t === ye ? new Date(t[U](/-/g, "/")) - new Date("1970/01/01") : Math.round(t))
    }, e.quantity = function (t) {
      return Math.pow(10, Math.floor(Math.log(t) / Math.LN10))
    }, e.nice = function (t, i) {
      var n, r = e.quantity(t), a = t / r;
      return n = i ? 1.5 > a ? 1 : 2.5 > a ? 2 : 4 > a ? 3 : 7 > a ? 5 : 10 : 1 > a ? 1 : 2 > a ? 2 : 3 > a ? 3 : 5 > a ? 5 : 10, n * r
    }, e
  }), e("zrender/core/matrix", [], function () {
    var t = "undefined" == typeof Float32Array ? Array : Float32Array, e = {
      create: function () {
        var i = new t(6);
        return e.identity(i), i
      }, identity: function (t) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t
      }, copy: function (t, e) {
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t
      }, mul: function (t, e, i) {
        var n = e[0] * i[0] + e[2] * i[1], r = e[1] * i[0] + e[3] * i[1], a = e[0] * i[2] + e[2] * i[3], o = e[1] * i[2] + e[3] * i[3], s = e[0] * i[4] + e[2] * i[5] + e[4], l = e[1] * i[4] + e[3] * i[5] + e[5];
        return t[0] = n, t[1] = r, t[2] = a, t[3] = o, t[4] = s, t[5] = l, t
      }, translate: function (t, e, i) {
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4] + i[0], t[5] = e[5] + i[1], t
      }, rotate: function (t, e, i) {
        var n = e[0], r = e[2], a = e[4], o = e[1], s = e[3], l = e[5], c = Math.sin(i), u = Math.cos(i);
        return t[0] = n * u + o * c, t[1] = -n * c + o * u, t[2] = r * u + s * c, t[3] = -r * c + u * s, t[4] = u * a + c * l, t[5] = u * l - c * a, t
      }, scale: function (t, e, i) {
        var n = i[0], r = i[1];
        return t[0] = e[0] * n, t[1] = e[1] * r, t[2] = e[2] * n, t[3] = e[3] * r, t[4] = e[4] * n, t[5] = e[5] * r, t
      }, invert: function (t, e) {
        var i = e[0], n = e[2], r = e[4], a = e[1], o = e[3], s = e[5], l = i * o - a * n;
        return l ? (l = 1 / l, t[0] = o * l, t[1] = -a * l, t[2] = -n * l, t[3] = i * l, t[4] = (n * s - o * r) * l, t[5] = (a * r - i * s) * l, t) : null
      }
    };
    return e
  }), e("echarts/component/tooltip/TooltipModel", [Pe, p], function (t) {
    t(p).extendComponentModel({
      type: "tooltip",
      defaultOption: {
        zlevel: 0,
        z: 8,
        show: !0,
        showContent: !0,
        trigger: "item",
        triggerOn: "mousemove",
        alwaysShowContent: !1,
        showDelay: 0,
        hideDelay: 100,
        transitionDuration: .4,
        enterable: !1,
        backgroundColor: "rgba(50,50,50,0.7)",
        borderColor: "#333",
        borderRadius: 4,
        borderWidth: 0,
        padding: 5,
        extraCssText: "",
        axisPointer: {
          type: "line",
          axis: "auto",
          animation: !0,
          animationDurationUpdate: 200,
          animationEasingUpdate: "exponentialOut",
          lineStyle: {color: "#555", width: 1, type: "solid"},
          crossStyle: {color: "#555", width: 1, type: "dashed", textStyle: {}},
          shadowStyle: {color: "rgba(150,150,150,0.3)"}
        },
        textStyle: {color: "#fff", fontSize: 14}
      }
    })
  }), e(be, [], function () {
    var t = "undefined" == typeof Float32Array ? Array : Float32Array, e = {
      create: function (e, i) {
        var n = new t(2);
        return null == e && (e = 0), null == i && (i = 0), n[0] = e, n[1] = i, n
      }, copy: function (t, e) {
        return t[0] = e[0], t[1] = e[1], t
      }, clone: function (e) {
        var i = new t(2);
        return i[0] = e[0], i[1] = e[1], i
      }, set: function (t, e, i) {
        return t[0] = e, t[1] = i, t
      }, add: function (t, e, i) {
        return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t
      }, scaleAndAdd: function (t, e, i, n) {
        return t[0] = e[0] + i[0] * n, t[1] = e[1] + i[1] * n, t
      }, sub: function (t, e, i) {
        return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t
      }, len: function (t) {
        return Math.sqrt(this.lenSquare(t))
      }, lenSquare: function (t) {
        return t[0] * t[0] + t[1] * t[1]
      }, mul: function (t, e, i) {
        return t[0] = e[0] * i[0], t[1] = e[1] * i[1], t
      }, div: function (t, e, i) {
        return t[0] = e[0] / i[0], t[1] = e[1] / i[1], t
      }, dot: function (t, e) {
        return t[0] * e[0] + t[1] * e[1]
      }, scale: function (t, e, i) {
        return t[0] = e[0] * i, t[1] = e[1] * i, t
      }, normalize: function (t, i) {
        var n = e.len(i);
        return 0 === n ? (t[0] = 0, t[1] = 0) : (t[0] = i[0] / n, t[1] = i[1] / n), t
      }, distance: function (t, e) {
        return Math.sqrt((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]))
      }, distanceSquare: function (t, e) {
        return (t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1])
      }, negate: function (t, e) {
        return t[0] = -e[0], t[1] = -e[1], t
      }, lerp: function (t, e, i, n) {
        return t[0] = e[0] + n * (i[0] - e[0]), t[1] = e[1] + n * (i[1] - e[1]), t
      }, applyTransform: function (t, e, i) {
        var n = e[0], r = e[1];
        return t[0] = i[0] * n + i[2] * r + i[4], t[1] = i[1] * n + i[3] * r + i[5], t
      }, min: function (t, e, i) {
        return t[0] = Math.min(e[0], i[0]), t[1] = Math.min(e[1], i[1]), t
      }, max: function (t, e, i) {
        return t[0] = Math.max(e[0], i[0]), t[1] = Math.max(e[1], i[1]), t
      }
    };
    return e[ne] = e.len, e.lengthSquare = e.lenSquare, e.dist = e.distance, e.distSquare = e.distanceSquare, e
  }), e("echarts/data/List", [Pe, "../model/Model", "./DataDiffer", Le, "../util/model"], function (t) {
    function e(t) {
      return h[Z](t) || (t = [t]), t
    }

    function i(t, e) {
      var i = t[S], n = new _(h.map(i, t.getDimensionInfo, t), t.hostModel);
      y(n, t);
      for (var r = n._storage = {}, a = t._storage, o = 0; o < i[ne]; o++) {
        var s = i[o], l = a[s];
        r[s] = h[V](e, s) >= 0 ? new l.constructor(a[s][ne]) : a[s]
      }
      return n
    }

    var n = "undefined", r = "undefined" == typeof window ? global : window, o = typeof r.Float64Array === n ? Array : r.Float64Array, s = typeof r.Int32Array === n ? Array : r.Int32Array, l = {
      "float": o,
      "int": s,
      ordinal: Array,
      number: Array,
      time: Array
    }, c = t("../model/Model"), u = t("./DataDiffer"), h = t(Le), f = t("../util/model"), p = h[oe], v = ["stackedOn", "hasItemOption", "_nameList", "_idList", "_rawData"], y = function (t, e) {
      h.each(v[g](e.__wrappedMethods || []), function (i) {
        e.hasOwnProperty(i) && (t[i] = e[i])
      }), t.__wrappedMethods = e.__wrappedMethods
    }, _ = function (t, e) {
      t = t || ["x", "y"];
      for (var i = {}, n = [], r = 0; r < t[ne]; r++) {
        var a, o = {};
        typeof t[r] === ye ? (a = t[r], o = {
          name: a,
          stackable: !1,
          type: "number"
        }) : (o = t[r], a = o.name, o.type = o.type || q), n.push(a), i[a] = o
      }
      this[S] = n, this._dimensionInfos = i, this.hostModel = e, this.dataType, this.indices = [], this._storage = {}, this._nameList = [], this._idList = [], this._optionModels = [], this.stackedOn = null, this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._rawData, this._extent
    }, b = _[xe];
    b.type = "list", b.hasItemOption = !0, b.getDimension = function (t) {
      return isNaN(t) || (t = this[S][t] || t), t
    }, b.getDimensionInfo = function (t) {
      return h.clone(this._dimensionInfos[this.getDimension(t)])
    }, b.initData = function (t, e, i) {
      t = t || [], this._rawData = t;
      var n = this._storage = {}, r = this.indices = [], a = this[S], o = t[ne], s = this._dimensionInfos, c = [], u = {};
      e = e || [];
      for (var h = 0; h < a[ne]; h++) {
        var d = s[a[h]], p = l[d.type];
        n[a[h]] = new p(o)
      }
      var v = this;
      i || (v.hasItemOption = !1), i = i || function (t, e, i, n) {
        var r = f.getDataItemValue(t);
        return f.isDataItemOption(t) && (v.hasItemOption = !0), f.converDataValue(r instanceof Array ? r[n] : r, s[e])
      };
      for (var m = 0; m < t[ne]; m++) {
        for (var g = t[m], y = 0; y < a[ne]; y++) {
          var x = a[y], _ = n[x];
          _[m] = i(g, x, m, y)
        }
        r.push(m)
      }
      for (var h = 0; h < t[ne]; h++) {
        e[h] || t[h] && null != t[h].name && (e[h] = t[h].name);
        var b = e[h] || "", w = t[h] && t[h].id;
        !w && b && (u[b] = u[b] || 0, w = b, u[b] > 0 && (w += "__ec__" + u[b]), u[b]++), w && (c[h] = w)
      }
      this._nameList = e, this._idList = c
    }, b.count = function () {
      return this.indices[ne]
    }, b.get = function (t, e, i) {
      var n = this._storage, r = this.indices[e];
      if (null == r)return 0 / 0;
      var a = n[t] && n[t][r];
      if (i) {
        var o = this._dimensionInfos[t];
        if (o && o.stackable)for (var s = this.stackedOn; s;) {
          var l = s.get(t, e);
          (a >= 0 && l > 0 || 0 >= a && 0 > l) && (a += l), s = s.stackedOn
        }
      }
      return a
    }, b.getValues = function (t, e, i) {
      var n = [];
      h[Z](t) || (i = e, e = t, t = this[S]);
      for (var r = 0, a = t[ne]; a > r; r++)n.push(this.get(t[r], e, i));
      return n
    }, b.hasValue = function (t) {
      for (var e = this[S], i = this._dimensionInfos, n = 0, r = e[ne]; r > n; n++)if (i[e[n]].type !== x && isNaN(this.get(e[n], t)))return !1;
      return !0
    }, b.getDataExtent = function (t, e) {
      t = this.getDimension(t);
      var i = this._storage[t], n = this.getDimensionInfo(t);
      e = n && n.stackable && e;
      var r, a = (this._extent || (this._extent = {}))[t + !!e];
      if (a)return a;
      if (i) {
        for (var o = 1 / 0, s = -1 / 0, l = 0, c = this.count(); c > l; l++)r = this.get(t, l, e), o > r && (o = r), r > s && (s = r);
        return this._extent[t + !!e] = [o, s]
      }
      return [1 / 0, -1 / 0]
    }, b.getSum = function (t, e) {
      var i = this._storage[t], n = 0;
      if (i)for (var r = 0, a = this.count(); a > r; r++) {
        var o = this.get(t, r, e);
        isNaN(o) || (n += o)
      }
      return n
    }, b[V] = function (t, e) {
      var i = this._storage, n = i[t], r = this.indices;
      if (n)for (var a = 0, o = r[ne]; o > a; a++) {
        var s = r[a];
        if (n[s] === e)return a
      }
      return -1
    }, b.indexOfName = function (t) {
      for (var e = this.indices, i = this._nameList, n = 0, r = e[ne]; r > n; n++) {
        var a = e[n];
        if (i[a] === t)return n
      }
      return -1
    }, b.indexOfRawIndex = function (t) {
      for (var e = this.indices, i = 0, n = e[ne] - 1; n >= i;) {
        var r = (i + n) / 2 | 0;
        if (e[r] < t)i = r + 1; else {
          if (!(e[r] > t))return r;
          n = r - 1
        }
      }
      return -1
    }, b.indexOfNearest = function (t, e, i, n) {
      var r = this._storage, a = r[t];
      null == n && (n = 1 / 0);
      var o = -1;
      if (a)for (var s = Number.MAX_VALUE, l = 0, c = this.count(); c > l; l++) {
        var u = e - this.get(t, l, i), h = Math.abs(u);
        n >= u && (s > h || h === s && u > 0) && (s = h, o = l)
      }
      return o
    }, b.getRawIndex = function (t) {
      var e = this.indices[t];
      return null == e ? -1 : e
    }, b.getRawDataItem = function (t) {
      return this._rawData[this.getRawIndex(t)]
    }, b[d] = function (t) {
      return this._nameList[this.indices[t]] || ""
    }, b.getId = function (t) {
      return this._idList[this.indices[t]] || this.getRawIndex(t) + ""
    }, b.each = function (t, i, n, r) {
      typeof t === W && (r = n, n = i, i = t, t = []), t = h.map(e(t), this.getDimension, this);
      var a = [], o = t[ne], s = this.indices;
      r = r || this;
      for (var l = 0; l < s[ne]; l++)switch (o) {
        case 0:
          i.call(r, l);
          break;
        case 1:
          i.call(r, this.get(t[0], l, n), l);
          break;
        case 2:
          i.call(r, this.get(t[0], l, n), this.get(t[1], l, n), l);
          break;
        default:
          for (var c = 0; o > c; c++)a[c] = this.get(t[c], l, n);
          a[c] = l, i.apply(r, a)
      }
    }, b.filterSelf = function (t, i, n, r) {
      typeof t === W && (r = n, n = i, i = t, t = []), t = h.map(e(t), this.getDimension, this);
      var a = [], o = [], s = t[ne], l = this.indices;
      r = r || this;
      for (var c = 0; c < l[ne]; c++) {
        var u;
        if (1 === s)u = i.call(r, this.get(t[0], c, n), c); else {
          for (var d = 0; s > d; d++)o[d] = this.get(t[d], c, n);
          o[d] = c, u = i.apply(r, o)
        }
        u && a.push(l[c])
      }
      return this.indices = a, this._extent = {}, this
    }, b.mapArray = function (t, e, i, n) {
      typeof t === W && (n = i, i = e, e = t, t = []);
      var r = [];
      return this.each(t, function () {
        r.push(e && e.apply(this, arguments))
      }, i, n), r
    }, b.map = function (t, n, r, a) {
      t = h.map(e(t), this.getDimension, this);
      var o = i(this, t), s = o.indices = this.indices, l = o._storage, c = [];
      return this.each(t, function () {
        var e = arguments[arguments[ne] - 1], i = n && n.apply(this, arguments);
        if (null != i) {
          typeof i === q && (c[0] = i, i = c);
          for (var r = 0; r < i[ne]; r++) {
            var a = t[r], o = l[a], u = s[e];
            o && (o[u] = i[r])
          }
        }
      }, r, a), o
    }, b.downSample = function (t, e, n, r) {
      for (var a = i(this, [t]), o = this._storage, s = a._storage, l = this.indices, c = a.indices = [], u = [], h = [], d = Math.floor(1 / e), f = s[t], p = this.count(), v = 0; v < o[t][ne]; v++)s[t][v] = o[t][v];
      for (var v = 0; p > v; v += d) {
        d > p - v && (d = p - v, u[ne] = d);
        for (var m = 0; d > m; m++) {
          var g = l[v + m];
          u[m] = f[g], h[m] = g
        }
        var y = n(u), g = h[r(u, y) || 0];
        f[g] = y, c.push(g)
      }
      return a
    }, b[m] = function (t) {
      var e = this.hostModel;
      return t = this.indices[t], new c(this._rawData[t], e, e && e[a])
    }, b.diff = function (t) {
      var e = this._idList, i = t && t._idList;
      return new u(t ? t.indices : [], this.indices, function (t) {
        return i[t] || t + ""
      }, function (t) {
        return e[t] || t + ""
      })
    }, b.getVisual = function (t) {
      var e = this._visual;
      return e && e[t]
    }, b.setVisual = function (t, e) {
      if (p(t))for (var i in t)t.hasOwnProperty(i) && this.setVisual(i, t[i]); else this._visual = this._visual || {}, this._visual[t] = e
    }, b.setLayout = function (t, e) {
      if (p(t))for (var i in t)t.hasOwnProperty(i) && this.setLayout(i, t[i]); else this._layout[t] = e
    }, b.getLayout = function (t) {
      return this._layout[t]
    }, b.getItemLayout = function (t) {
      return this._itemLayouts[t]
    }, b.setItemLayout = function (t, e, i) {
      this._itemLayouts[t] = i ? h[re](this._itemLayouts[t] || {}, e) : e
    }, b.clearItemLayouts = function () {
      this._itemLayouts[ne] = 0
    }, b[w] = function (t, e, i) {
      var n = this._itemVisuals[t], r = n && n[e];
      return null != r || i ? r : this.getVisual(e)
    }, b.setItemVisual = function (t, e, i) {
      var n = this._itemVisuals[t] || {};
      if (this._itemVisuals[t] = n, p(e))for (var r in e)e.hasOwnProperty(r) && (n[r] = e[r]); else n[e] = i
    }, b.clearAllVisual = function () {
      this._visual = {}, this._itemVisuals = []
    };
    var M = function (t) {
      t[$] = this[$], t[Q] = this[Q], t.dataType = this.dataType
    };
    return b.setItemGraphicEl = function (t, e) {
      var i = this.hostModel;
      e && (e[Q] = t, e.dataType = this.dataType, e[$] = i && i[$], "group" === e.type && e.traverse(M, e)), this._graphicEls[t] = e
    }, b.getItemGraphicEl = function (t) {
      return this._graphicEls[t]
    }, b.eachItemGraphicEl = function (t, e) {
      h.each(this._graphicEls, function (i, n) {
        i && t && t.call(e, i, n)
      })
    }, b.cloneShallow = function () {
      var t = h.map(this[S], this.getDimensionInfo, this), e = new _(t, this.hostModel);
      return e._storage = this._storage, y(e, this), e.indices = this.indices.slice(), this._extent && (e._extent = h[re]({}, this._extent)), e
    }, b.wrapMethod = function (t, e) {
      var i = this[t];
      typeof i === W && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(t), this[t] = function () {
        var t = i.apply(this, arguments);
        return e.apply(this, [t][g](h.slice(arguments)))
      })
    }, b.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "map"], b.CHANGABLE_METHODS = ["filterSelf"], _
  }), e("echarts/util/layout", [Pe, Le, "zrender/core/BoundingRect", "./number", "./format"], function (t) {
    function e(t, e, i, n, r) {
      var a = 0, o = 0;
      null == n && (n = 1 / 0), null == r && (r = 1 / 0);
      var s = 0;
      e.eachChild(function (l, c) {
        var u, h, d = l[z], f = l[O](), p = e.childAt(c + 1), v = p && p[O]();
        if ("horizontal" === t) {
          var m = f.width + (v ? -v.x + f.x : 0);
          u = a + m, u > n || l.newline ? (a = 0, u = m, o += s + i, s = f[ce]) : s = Math.max(s, f[ce])
        } else {
          var g = f[ce] + (v ? -v.y + f.y : 0);
          h = o + g, h > r || l.newline ? (a += s + i, o = 0, h = g, s = f.width) : s = Math.max(s, f.width)
        }
        l.newline || (d[0] = a, d[1] = o, "horizontal" === t ? a = u + i : o = h + i)
      })
    }

    var i = t(Le), n = t("zrender/core/BoundingRect"), r = t("./number"), a = t("./format"), o = r.parsePercent, s = i.each, l = {}, c = ["left", "right", "top", ue, "width", ce];
    return l.box = e, l.vbox = i.curry(e, "vertical"), l.hbox = i.curry(e, "horizontal"), l.getAvailableSize = function (t, e, i) {
      var n = e.width, r = e[ce], s = o(t.x, n), l = o(t.y, r), c = o(t.x2, n), u = o(t.y2, r);
      return (isNaN(s) || isNaN(parseFloat(t.x))) && (s = 0), (isNaN(c) || isNaN(parseFloat(t.x2))) && (c = n), (isNaN(l) || isNaN(parseFloat(t.y))) && (l = 0), (isNaN(u) || isNaN(parseFloat(t.y2))) && (u = r), i = a.normalizeCssArray(i || 0), {
        width: Math.max(c - s - i[1] - i[3], 0),
        height: Math.max(u - l - i[0] - i[2], 0)
      }
    }, l.getLayoutRect = function (t, e, i) {
      i = a.normalizeCssArray(i || 0);
      var r = e.width, s = e[ce], l = o(t.left, r), c = o(t.top, s), u = o(t.right, r), h = o(t[ue], s), d = o(t.width, r), f = o(t[ce], s), p = i[2] + i[0], v = i[1] + i[3], m = t.aspect;
      switch (isNaN(d) && (d = r - u - v - l), isNaN(f) && (f = s - h - p - c), isNaN(d) && isNaN(f) && (m > r / s ? d = .8 * r : f = .8 * s), null != m && (isNaN(d) && (d = m * f), isNaN(f) && (f = d / m)), isNaN(l) && (l = r - u - d - v), isNaN(c) && (c = s - h - f - p), t.left || t.right) {
        case D:
          l = r / 2 - d / 2 - i[3];
          break;
        case"right":
          l = r - d - v
      }
      switch (t.top || t[ue]) {
        case E:
        case D:
          c = s / 2 - f / 2 - i[0];
          break;
        case ue:
          c = s - f - p
      }
      l = l || 0, c = c || 0, isNaN(d) && (d = r - l - (u || 0)), isNaN(f) && (f = s - c - (h || 0));
      var g = new n(l + i[3], c + i[0], d, f);
      return g.margin = i, g
    }, l.positionGroup = function (t, e, n, r) {
      var a = t[O]();
      e = i[re](i.clone(e), {
        width: a.width,
        height: a[ce]
      }), e = l.getLayoutRect(e, n, r), t.attr(z, [e.x - a.x, e.y - a.y])
    }, l.mergeLayoutParam = function (t, e, n) {
      function r(i) {
        var r = {}, l = 0, c = {}, u = 0, h = n.ignoreSize ? 1 : 2;
        if (s(i, function (e) {
            c[e] = t[e]
          }), s(i, function (t) {
            a(e, t) && (r[t] = c[t] = e[t]), o(r, t) && l++, o(c, t) && u++
          }), u !== h && l) {
          if (l >= h)return r;
          for (var d = 0; d < i[ne]; d++) {
            var f = i[d];
            if (!a(r, f) && a(t, f)) {
              r[f] = t[f];
              break
            }
          }
          return r
        }
        return c
      }

      function a(t, e) {
        return t.hasOwnProperty(e)
      }

      function o(t, e) {
        return null != t[e] && "auto" !== t[e]
      }

      function l(t, e, i) {
        s(t, function (t) {
          e[t] = i[t]
        })
      }

      !i[oe](n) && (n = {});
      var c = ["width", "left", "right"], u = [ce, "top", ue], h = r(c), d = r(u);
      l(c, t, h), l(u, t, d)
    }, l.getLayoutParams = function (t) {
      return l.copyLayoutParams({}, t)
    }, l.copyLayoutParams = function (t, e) {
      return e && t && s(c, function (i) {
        e.hasOwnProperty(i) && (t[i] = e[i])
      }), t
    }, l
  }), e("echarts/component/tooltip/TooltipView", [Pe, "./TooltipContent", A, Le, "../../util/format", "../../util/number", "zrender/core/env", "../../model/Model", p], function (t) {
    function e(t, e) {
      if (!t || !e)return !1;
      var i = P.round;
      return i(t[0]) === i(e[0]) && i(t[1]) === i(e[1])
    }

    function i(t, e, i, n) {
      return {x1: t, y1: e, x2: i, y2: n}
    }

    function o(t, e, i, n) {
      return {x: t, y: e, width: i, height: n}
    }

    function u(t, e, i, n, r, a) {
      return {cx: t, cy: e, r0: i, r: n, startAngle: r, endAngle: a, clockwise: !0}
    }

    function f(t, e, i, n, r) {
      var a = i.clientWidth, o = i.clientHeight, s = 20;
      return t + a + s > n ? t -= a + s : t += s, e + o + s > r ? e -= o + s : e += s, [t, e]
    }

    function v(t, e, i) {
      var n = i.clientWidth, r = i.clientHeight, a = 5, o = 0, s = 0, c = e.width, u = e[ce];
      switch (t) {
        case l:
          o = e.x + c / 2 - n / 2, s = e.y + u / 2 - r / 2;
          break;
        case"top":
          o = e.x + c / 2 - n / 2, s = e.y - r - a;
          break;
        case ue:
          o = e.x + c / 2 - n / 2, s = e.y + u + a;
          break;
        case"left":
          o = e.x - n - a, s = e.y + u / 2 - r / 2;
          break;
        case"right":
          o = e.x + c + a, s = e.y + u / 2 - r / 2
      }
      return [o, s]
    }

    function g(t, e, i, a, o, s, l) {
      var c = l[ve](), u = l[pe](), d = s && s[O]().clone();
      if (s && d[h](s[r]), typeof t === W && (t = t([e, i], o, a.el, d)), b[Z](t))e = k(t[0], c), i = k(t[1], u); else if (typeof t === ye && s) {
        var p = v(t, d, a.el);
        e = p[0], i = p[1]
      } else {
        var p = f(e, i, a.el, c, u);
        e = p[0], i = p[1]
      }
      a[n](e, i)
    }

    function y(t) {
      var e = t[Te], i = t.get("tooltip.trigger", !0);
      return !(!e || "cartesian2d" !== e.type && "polar" !== e.type && "singleAxis" !== e.type || "item" === i)
    }

    var x = t("./TooltipContent"), _ = t(A), b = t(Le), w = t("../../util/format"), P = t("../../util/number"), k = P.parsePercent, I = t("zrender/core/env"), D = t("../../model/Model");
    t(p)[Ae]({
      type: "tooltip", _axisPointers: {}, init: function (t, e) {
        if (!I.node) {
          var i = new x(e.getDom(), e);
          this._tooltipContent = i, e.on("showTip", this._manuallyShowTip, this), e.on("hideTip", this._manuallyHideTip, this)
        }
      }, render: function (t, e, i) {
        if (!I.node) {
          this.group[Ce](), this._axisPointers = {}, this._tooltipModel = t, this._ecModel = e, this._api = i, this._lastHover = {};
          var n = this._tooltipContent;
          n[se](), n.enterable = t.get("enterable"), this._alwaysShowContent = t.get("alwaysShowContent"), this._seriesGroupByAxis = this._prepareAxisTriggerData(t, e);
          var r = this._crossText;
          if (r && this.group.add(r), null != this._lastX && null != this._lastY) {
            var a = this;
            clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function () {
              a._manuallyShowTip({x: a._lastX, y: a._lastY})
            })
          }
          var o = this._api.getZr();
          o.off("click", this._tryShow), o.off("mousemove", this._mousemove), o.off(J, this._hide), o.off("globalout", this._hide), "click" === t.get("triggerOn") ? o.on("click", this._tryShow, this) : (o.on("mousemove", this._mousemove, this), o.on(J, this._hide, this), o.on("globalout", this._hide, this))
        }
      }, _mousemove: function (t) {
        var e = this._tooltipModel.get("showDelay"), i = this;
        clearTimeout(this._showTimeout), e > 0 ? this._showTimeout = setTimeout(function () {
          i._tryShow(t)
        }, e) : this._tryShow(t)
      }, _manuallyShowTip: function (t) {
        if (t.from !== this.uid) {
          var e = this._ecModel, i = t[$], n = t[Q], a = e.getSeriesByIndex(i), o = this._api;
          if (null == t.x || null == t.y) {
            if (a || e.eachSeries(function (t) {
                y(t) && !a && (a = t)
              }), a) {
              var s = a[we]();
              null == n && (n = s.indexOfName(t.name));
              var l, c, u = s.getItemGraphicEl(n), d = a[Te];
              if (d && d[M]) {
                var f = d[M](s.getValues(b.map(d[S], function (t) {
                  return a.coordDimToDataDim(t)[0]
                }), n, !0));
                l = f && f[0], c = f && f[1]
              } else if (u) {
                var p = u[O]().clone();
                p[h](u[r]), l = p.x + p.width / 2, c = p.y + p[ce] / 2
              }
              null != l && null != c && this._tryShow({offsetX: l, offsetY: c, target: u, event: {}})
            }
          } else {
            var u = o.getZr().handler.findHover(t.x, t.y);
            this._tryShow({offsetX: t.x, offsetY: t.y, target: u, event: {}})
          }
        }
      }, _manuallyHideTip: function (t) {
        t.from !== this.uid && this._hide()
      }, _prepareAxisTriggerData: function (t, e) {
        var i = {};
        return e.eachSeries(function (t) {
          if (y(t)) {
            var e, n, r = t[Te];
            "cartesian2d" === r.type ? (e = r[C](), n = e.dim + e.index) : "singleAxis" === r.type ? (e = r.getAxis(), n = e.dim + e.type) : (e = r[C](), n = e.dim + r.name), i[n] = i[n] || {
              coordSys: [],
              series: []
            }, i[n].coordSys.push(r), i[n][ie].push(t)
          }
        }, this), i
      }, _tryShow: function (t) {
        var e = t[K], i = this._tooltipModel, n = i.get("trigger"), r = this._ecModel, a = this._api;
        if (i)if (this._lastX = t.offsetX, this._lastY = t.offsetY, e && null != e[Q]) {
          var o = e.dataModel || r.getSeriesByIndex(e[$]), s = e[Q], l = o[we]()[m](s);
          "axis" === (l.get("tooltip.trigger") || n) ? this._showAxisTooltip(i, r, t) : (this._ticket = "", this._hideAxisPointer(), this._resetLastHover(), this._showItemTooltipContent(o, s, e.dataType, t)), a.dispatchAction({
            type: "showTip",
            from: this.uid,
            dataIndex: e[Q],
            seriesIndex: e[$]
          })
        } else if (e && e.tooltip) {
          var c = e.tooltip;
          if (typeof c === ye) {
            var u = c;
            c = {content: u, formatter: u}
          }
          var h = new D(c, i), d = h.get("content"), f = Math.random();
          this._showTooltipContent(h, d, h.get("formatterParams") || {}, f, t.offsetX, t.offsetY, e, a)
        } else"item" === n ? this._hide() : this._showAxisTooltip(i, r, t), "cross" === i.get("axisPointer.type") && a.dispatchAction({
          type: "showTip",
          from: this.uid,
          x: t.offsetX,
          y: t.offsetY
        })
      }, _showAxisTooltip: function (t, i, n) {
        var r = t[me]("axisPointer"), a = r.get("type");
        if ("cross" === a) {
          var o = n[K];
          if (o && null != o[Q]) {
            var s = i.getSeriesByIndex(o[$]), l = o[Q];
            this._showItemTooltipContent(s, l, o.dataType, n)
          }
        }
        this._showAxisPointer();
        var c = !0;
        b.each(this._seriesGroupByAxis, function (t) {
          var i = t.coordSys, o = i[0], s = [n.offsetX, n.offsetY];
          if (!o.containPoint(s))return void this._hideAxisPointer(o.name);
          c = !1;
          var l = o[S], u = o.pointToData(s, !0);
          s = o[M](u);
          var h = o[C](), d = r.get("axis");
          "auto" === d && (d = h.dim);
          var f = !1, p = this._lastHover;
          if ("cross" === a)e(p.data, u) && (f = !0), p.data = u; else {
            var v = b[V](l, d);
            p.data === u[v] && (f = !0), p.data = u[v]
          }
          "cartesian2d" !== o.type || f ? "polar" !== o.type || f ? "singleAxis" !== o.type || f || this._showSinglePointer(r, o, d, s) : this._showPolarPointer(r, o, d, s) : this._showCartesianPointer(r, o, d, s), "cross" !== a && this._dispatchAndShowSeriesTooltipContent(o, t[ie], s, u, f)
        }, this), this._tooltipModel.get("show") || this._hideAxisPointer(), c && this._hide()
      }, _showCartesianPointer: function (t, e, n, r) {
        function a(n, r, a) {
          var o = "x" === n ? i(r[0], a[0], r[0], a[1]) : i(a[0], r[1], a[1], r[1]), s = c._getPointerElement(e, t, n, o);
          _.subPixelOptimizeLine({shape: o, style: s.style}), d ? _.updateProps(s, {shape: o}, t) : s.attr({shape: o})
        }

        function l(i, n, r) {
          var a = e.getAxis(i), s = a.getBandWidth(), l = r[1] - r[0], u = "x" === i ? o(n[0] - s / 2, r[0], s, l) : o(r[0], n[1] - s / 2, l, s), h = c._getPointerElement(e, t, i, u);
          d ? _.updateProps(h, {shape: u}, t) : h.attr({shape: u})
        }

        var c = this, u = t.get("type"), h = e[C](), d = "cross" !== u && h.type === s && h.getBandWidth() > 20;
        if ("cross" === u)a("x", r, e.getAxis("y").getGlobalExtent()), a("y", r, e.getAxis("x").getGlobalExtent()), this._updateCrossText(e, r, t); else {
          var f = e.getAxis("x" === n ? "y" : "x"), p = f.getGlobalExtent();
          "cartesian2d" === e.type && ("line" === u ? a : l)(n, r, p)
        }
      }, _showSinglePointer: function (t, e, n, r) {
        function a(n, r, a) {
          var s = e.getAxis(), l = s.orient, u = "horizontal" === l ? i(r[0], a[0], r[0], a[1]) : i(a[0], r[1], a[1], r[1]), h = o._getPointerElement(e, t, n, u);
          c ? _.updateProps(h, {shape: u}, t) : h.attr({shape: u})
        }

        var o = this, l = t.get("type"), c = "cross" !== l && e[C]().type === s, u = e.getRect(), h = [u.y, u.y + u[ce]];
        a(n, r, h)
      }, _showPolarPointer: function (t, e, n, r) {
        function a(n, r, a) {
          var o, s = e.pointToCoord(r);
          if ("angle" === n) {
            var c = e.coordToPoint([a[0], s[1]]), u = e.coordToPoint([a[1], s[1]]);
            o = i(c[0], c[1], u[0], u[1])
          } else o = {cx: e.cx, cy: e.cy, r: s[0]};
          var h = l._getPointerElement(e, t, n, o);
          f ? _.updateProps(h, {shape: o}, t) : h.attr({shape: o})
        }

        function o(i, n, r) {
          var a, o = e.getAxis(i), s = o.getBandWidth(), c = e.pointToCoord(n), h = Math.PI / 180;
          a = "angle" === i ? u(e.cx, e.cy, r[0], r[1], (-c[1] - s / 2) * h, (-c[1] + s / 2) * h) : u(e.cx, e.cy, c[0] - s / 2, c[0] + s / 2, 0, 2 * Math.PI);
          var d = l._getPointerElement(e, t, i, a);
          f ? _.updateProps(d, {shape: a}, t) : d.attr({shape: a})
        }

        var l = this, c = t.get("type"), h = e.getAngleAxis(), d = e.getRadiusAxis(), f = "cross" !== c && e[C]().type === s;
        if ("cross" === c)a("angle", r, d[L]()), a(T, r, h[L]()), this._updateCrossText(e, r, t); else {
          var p = e.getAxis(n === T ? "angle" : T), v = p[L]();
          ("line" === c ? a : o)(n, r, v)
        }
      }, _updateCrossText: function (t, e, i) {
        var n = i[me]("crossStyle"), r = n[me](G), a = this._tooltipModel, o = this._crossText;
        o || (o = this._crossText = new _.Text({
          style: {
            textAlign: "left",
            textVerticalAlign: "bottom"
          }
        }), this.group.add(o));
        var l = t.pointToData(e), c = t[S];
        l = b.map(l, function (e, i) {
          var n = t.getAxis(c[i]);
          return e = n.type === s || "time" === n.type ? n.scale.getLabel(e) : w.addCommas(e.toFixed(n.getPixelPrecision()))
        }), o[X]({
          fill: r[R]() || n.get("color"),
          textFont: r[B](),
          text: l.join(", "),
          x: e[0] + 5,
          y: e[1] - 5
        }), o.z = a.get("z"), o[j] = a.get(j)
      }, _getPointerElement: function (t, e, i, n) {
        var r = this._tooltipModel, a = r.get("z"), o = r.get(j), s = this._axisPointers, l = t.name;
        if (s[l] = s[l] || {}, s[l][i])return s[l][i];
        var u = e.get("type"), h = e[me](u + "Style"), d = "shadow" === u, f = h[d ? "getAreaStyle" : "getLineStyle"](), p = "polar" === t.type ? d ? "Sector" : i === T ? "Circle" : "Line" : d ? "Rect" : "Line";
        d ? f[c] = null : f.fill = null;
        var v = s[l][i] = new _[p]({style: f, z: a, zlevel: o, silent: !0, shape: n});
        return this.group.add(v), v
      }, _dispatchAndShowSeriesTooltipContent: function (t, e, i, n, r) {
        var a = this._tooltipModel, o = t[C](), l = "x" === o.dim || o.dim === T ? 0 : 1, c = b.map(e, function (t) {
          return {
            seriesIndex: t[$],
            dataIndex: t.getAxisTooltipDataIndex ? t.getAxisTooltipDataIndex(t.coordDimToDataDim(o.dim), n, o) : t[we]().indexOfNearest(t.coordDimToDataDim(o.dim)[0], n[l], !1, o.type === s ? .5 : null)
          }
        }), u = this._lastHover, h = this._api;
        if (u.payloadBatch && !r && h.dispatchAction({
            type: "downplay",
            batch: u.payloadBatch
          }), r || (h.dispatchAction({
            type: "highlight",
            batch: c
          }), u.payloadBatch = c), h.dispatchAction({
            type: "showTip",
            dataIndex: c[0][Q],
            seriesIndex: c[0][$],
            from: this.uid
          }), o && a.get("showContent") && a.get("show")) {
          var f = b.map(e, function (t, e) {
            return t[Y](c[e][Q])
          });
          if (r)g(a.get(z), i[0], i[1], this._tooltipContent, f, null, h); else {
            var p = c[0][Q], v = "time" === o.type ? o.scale.getLabel(n[l]) : e[0][we]()[d](p), m = (v ? v + "<br />" : "") + b.map(e, function (t, e) {
                return t.formatTooltip(c[e][Q], !0)
              }).join("<br />"), y = "axis_" + t.name + "_" + p;
            this._showTooltipContent(a, m, f, y, i[0], i[1], null, h)
          }
        }
      }, _showItemTooltipContent: function (t, e, i, n) {
        var r = this._api, o = t[we](i), s = o[m](e), l = s.get("tooltip", !0);
        if (typeof l === ye) {
          var c = l;
          l = {formatter: c}
        }
        var u = this._tooltipModel, h = t[me]("tooltip", u), d = new D(l, h, h[a]), f = t[Y](e, i), p = t.formatTooltip(e, !1, i), v = "item_" + t.name + "_" + e;
        this._showTooltipContent(d, p, f, v, n.offsetX, n.offsetY, n[K], r)
      }, _showTooltipContent: function (t, e, i, n, r, a, o, s) {
        if (this._ticket = "", t.get("showContent") && t.get("show")) {
          var l = this._tooltipContent, c = t.get("formatter"), u = t.get(z), h = e;
          if (c)if (typeof c === ye)h = w.formatTpl(c, i); else if (typeof c === W) {
            var d = this, f = n, p = function (t, e) {
              t === d._ticket && (l.setContent(e), g(u, r, a, l, i, o, s))
            };
            d._ticket = f, h = c(i, f, p)
          }
          l.show(t), l.setContent(h), g(u, r, a, l, i, o, s)
        }
      }, _showAxisPointer: function (t) {
        if (t) {
          var e = this._axisPointers[t];
          e && b.each(e, function (t) {
            t.show()
          })
        } else this.group.eachChild(function (t) {
          t.show()
        }), this.group.show()
      }, _resetLastHover: function () {
        var t = this._lastHover;
        t.payloadBatch && this._api.dispatchAction({type: "downplay", batch: t.payloadBatch}), this._lastHover = {}
      }, _hideAxisPointer: function (t) {
        if (t) {
          var e = this._axisPointers[t];
          e && b.each(e, function (t) {
            t.hide()
          })
        } else this.group.children()[ne] && this.group.hide()
      }, _hide: function () {
        clearTimeout(this._showTimeout), this._hideAxisPointer(), this._resetLastHover(), this._alwaysShowContent || this._tooltipContent.hideLater(this._tooltipModel.get("hideDelay")), this._api.dispatchAction({
          type: "hideTip",
          from: this.uid
        }), this._lastX = this._lastY = null
      }, dispose: function (t, e) {
        if (!I.node) {
          var i = e.getZr();
          this._tooltipContent.hide(), i.off("click", this._tryShow), i.off("mousemove", this._mousemove), i.off(J, this._hide), i.off("globalout", this._hide), e.off("showTip", this._manuallyShowTip), e.off("hideTip", this._manuallyHideTip)
        }
      }
    })
  }), e("zrender/vml/Painter", [Pe, "../core/log", "./core"], function (t) {
    function e(t) {
      return parseInt(t, 10)
    }

    function n(t, e) {
      o.initVML(), this.root = t, this[de] = e;
      var i = document[y]("div"), n = document[y]("div");
      i.style.cssText = "display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;", n.style.cssText = "position:absolute;left:0;top:0;", t.appendChild(i), this._vmlRoot = n, this._vmlViewport = i, this[ge]();
      var r = e.delFromMap, a = e.addToMap;
      e.delFromMap = function (t) {
        var i = e.get(t);
        r.call(e, t), i && i.onRemove && i.onRemove(n)
      }, e.addToMap = function (t) {
        t.onAdd && t.onAdd(n), a.call(e, t)
      }, this._firstPaint = !0
    }

    function r(t) {
      return function () {
        a('In IE8.0 VML mode painter not support method "' + t + '"')
      }
    }

    var a = t("../core/log"), o = t("./core");
    n[xe] = {
      constructor: n, getViewportRoot: function () {
        return this._vmlViewport
      }, refresh: function () {
        var t = this[de].getDisplayList(!0, !0);
        this._paintList(t)
      }, _paintList: function (t) {
        for (var e = this._vmlRoot, n = 0; n < t[ne]; n++) {
          var r = t[n];
          r.invisible || r[he] ? (r.__alreadyNotVisible || r.onRemove(e), r.__alreadyNotVisible = !0) : (r.__alreadyNotVisible && r.onAdd(e), r.__alreadyNotVisible = !1, r[i] && (r.beforeBrush && r.beforeBrush(), (r.brushVML || r.brush).call(r, e), r.afterBrush && r.afterBrush())), r[i] = !1
        }
        this._firstPaint && (this._vmlViewport.appendChild(e), this._firstPaint = !1)
      }, resize: function () {
        var t = this._getWidth(), e = this._getHeight();
        if (this._width != t && this._height != e) {
          this._width = t, this._height = e;
          var i = this._vmlViewport.style;
          i.width = t + "px", i[ce] = e + "px"
        }
      }, dispose: function () {
        this.root.innerHTML = "", this._vmlRoot = this._vmlViewport = this[de] = null
      }, getWidth: function () {
        return this._width
      }, getHeight: function () {
        return this._height
      }, clear: function () {
        this.root.removeChild(this.vmlViewport)
      }, _getWidth: function () {
        var t = this.root, i = t.currentStyle;
        return (t.clientWidth || e(i.width)) - e(i.paddingLeft) - e(i.paddingRight) | 0
      }, _getHeight: function () {
        var t = this.root, i = t.currentStyle;
        return (t.clientHeight || e(i[ce])) - e(i.paddingTop) - e(i.paddingBottom) | 0
      }
    };
    for (var s = ["getLayer", "insertLayer", "eachLayer", "eachBuildinLayer", "eachOtherLayer", "getLayers", "modLayer", "delLayer", "clearLayer", "toDataURL", "pathToImage"], l = 0; l < s[ne]; l++) {
      var c = s[l];
      n[xe][c] = r(c)
    }
    return n
  }), e("echarts/component/legend/LegendModel", [Pe, Le, "../../model/Model", p], function (t) {
    var e = t(Le), i = t("../../model/Model"), n = t(p).extendComponentModel({
      type: "legend",
      dependencies: [ie],
      layoutMode: {type: "box", ignoreSize: !0},
      init: function (t, e, i) {
        this.mergeDefaultAndTheme(t, i), t.selected = t.selected || {}
      },
      mergeOption: function (t) {
        n.superCall(this, "mergeOption", t)
      },
      optionUpdated: function () {
        this._updateData(this[a]);
        var t = this._data;
        if (t[0] && "single" === this.get("selectedMode")) {
          for (var e = !1, i = 0; i < t[ne]; i++) {
            var n = t[i].get("name");
            if (this.isSelected(n)) {
              this.select(n), e = !0;
              break
            }
          }
          !e && this.select(t[0].get("name"))
        }
      },
      _updateData: function (t) {
        var n = e.map(this.get("data") || [], function (t) {
          return (typeof t === ye || typeof t === q) && (t = {name: t}), new i(t, this, this[a])
        }, this);
        this._data = n;
        var r = e.map(t.getSeries(), function (t) {
          return t.name
        });
        t.eachSeries(function (t) {
          if (t.legendDataProvider) {
            var e = t.legendDataProvider();
            r = r[g](e.mapArray(e[d]))
          }
        }), this._availableNames = r
      },
      getData: function () {
        return this._data
      },
      select: function (t) {
        var i = this[o].selected, n = this.get("selectedMode");
        if ("single" === n) {
          var r = this._data;
          e.each(r, function (t) {
            i[t.get("name")] = !1
          })
        }
        i[t] = !0
      },
      unSelect: function (t) {
        "single" !== this.get("selectedMode") && (this[o].selected[t] = !1)
      },
      toggleSelected: function (t) {
        var e = this[o].selected;
        t in e || (e[t] = !0), this[e[t] ? "unSelect" : "select"](t)
      },
      isSelected: function (t) {
        var i = this[o].selected;
        return !(t in i && !i[t]) && e[V](this._availableNames, t) >= 0
      },
      defaultOption: {
        zlevel: 0,
        z: 4,
        show: !0,
        orient: "horizontal",
        left: "center",
        top: "top",
        align: "auto",
        backgroundColor: "rgba(0,0,0,0)",
        borderColor: "#ccc",
        borderWidth: 0,
        padding: 5,
        itemGap: 10,
        itemWidth: 25,
        itemHeight: 14,
        inactiveColor: "#ccc",
        textStyle: {color: "#333"},
        selectedMode: !0,
        tooltip: {show: !1}
      }
    });
    return n
  }), e("zrender/vml/graphic", [Pe, "../core/env", "../core/vector", "../core/BoundingRect", "../core/PathProxy", "../tool/color", "../contain/text", "../graphic/mixin/RectText", "../graphic/Displayable", "../graphic/Image", "../graphic/Text", "../graphic/Path", "../graphic/Gradient", "./core"], function (t) {
    if (!t("../core/env")[fe]) {
      var e = t("../core/vector"), i = t("../core/BoundingRect"), n = t("../core/PathProxy").CMD, a = t("../tool/color"), o = t("../contain/text"), s = t("../graphic/mixin/RectText"), l = t("../graphic/Displayable"), d = t("../graphic/Image"), p = t("../graphic/Text"), v = t("../graphic/Path"), m = t("../graphic/Gradient"), g = t("./core"), x = Math.round, _ = Math.sqrt, b = Math.abs, w = Math.cos, S = Math.sin, M = Math.max, T = e[h], C = ",", A = "progid:DXImageTransform.Microsoft", L = 21600, P = L / 2, k = 1e5, z = 1e3, R = function (t) {
        t.style.cssText = "position:absolute;left:0;top:0;width:1px;height:1px;", t.coordsize = L + "," + L, t.coordorigin = "0,0"
      }, B = function (t) {
        return String(t)[U](/&/g, "&amp;")[U](/"/g, "&quot;")
      }, G = function (t, e, i) {
        return "rgb(" + [t, e, i].join(",") + ")"
      }, F = function (t, e) {
        e && t && e.parentNode !== t && t.appendChild(e)
      }, V = function (t, e) {
        e && t && e.parentNode === t && t.removeChild(e)
      }, q = function (t, e, i) {
        return (parseFloat(t) || 0) * k + (parseFloat(e) || 0) * z + i
      }, W = function (t, e) {
        return typeof t === ye ? t.lastIndexOf("%") >= 0 ? parseFloat(t) / 100 * e : parseFloat(t) : t
      }, Z = function (t, e, i) {
        var n = a.parse(e);
        i = +i, isNaN(i) && (i = 1), n && (t.color = G(n[0], n[1], n[2]), t[I] = i * n[3])
      }, X = function (t) {
        var e = a.parse(t);
        return [G(e[0], e[1], e[2]), e[3]]
      }, Y = function (t, e, i) {
        var n = e.fill;
        if (null != n)if (n instanceof m) {
          var a, o = 0, s = [0, 0], l = 0, c = 1, u = i[O](), h = u.width, d = u[ce];
          if ("linear" === n.type) {
            a = "gradient";
            var f = i[r], p = [n.x * h, n.y * d], v = [n.x2 * h, n.y2 * d];
            f && (T(p, p, f), T(v, v, f));
            var g = v[0] - p[0], y = v[1] - p[1];
            o = 180 * Math.atan2(g, y) / Math.PI, 0 > o && (o += 360), 1e-6 > o && (o = 0)
          } else {
            a = "gradientradial";
            var p = [n.x * h, n.y * d], f = i[r], x = i.scale, _ = h, b = d;
            s = [(p[0] - u.x) / _, (p[1] - u.y) / b], f && T(p, p, f), _ /= x[0] * L, b /= x[1] * L;
            var w = M(_, b);
            l = 0 / w, c = 2 * n.r / w - l
          }
          var S = n.colorStops.slice();
          S.sort(function (t, e) {
            return t.offset - e.offset
          });
          for (var C = S[ne], A = [], P = [], k = 0; C > k; k++) {
            var z = S[k], D = X(z.color);
            P.push(z.offset * c + l + " " + D[0]), (0 === k || k === C - 1) && A.push(D)
          }
          if (C >= 2) {
            var E = A[0][0], R = A[1][0], B = A[0][1] * e[I], N = A[1][1] * e[I];
            t.type = a, t.method = "none", t.focus = "100%", t.angle = o, t.color = E, t.color2 = R, t.colors = P.join(","), t[I] = N, t.opacity2 = B
          }
          "radial" === a && (t.focusposition = s.join(","))
        } else Z(t, n, e[I])
      }, $ = function (t, e) {
        null != e.lineDash && (t.dashstyle = e.lineDash.join(" ")), null == e[c] || e[c]instanceof m || Z(t, e[c], e[I])
      }, Q = function (t, e, i, n) {
        var r = "fill" == e, a = t.getElementsByTagName(e)[0];
        null != i[e] && "none" !== i[e] && (r || !r && i[u]) ? (t[r ? "filled" : "stroked"] = "true", i[e]instanceof m && V(t, a), a || (a = g.createNode(e)), r ? Y(a, i, n) : $(a, i), F(t, a)) : (t[r ? "filled" : "stroked"] = "false", V(t, a))
      }, K = [[], [], []], J = function (t, e) {
        var i, r, a, o, s, l, c = n.M, u = n.C, h = n.L, d = n.A, f = n.Q, p = [];
        for (o = 0; o < t[ne];) {
          switch (a = t[o++], r = "", i = 0, a) {
            case c:
              r = " m ", i = 1, s = t[o++], l = t[o++], K[0][0] = s, K[0][1] = l;
              break;
            case h:
              r = " l ", i = 1, s = t[o++], l = t[o++], K[0][0] = s, K[0][1] = l;
              break;
            case f:
            case u:
              r = " c ", i = 3;
              var v, m, g = t[o++], y = t[o++], b = t[o++], M = t[o++];
              a === f ? (v = b, m = M, b = (b + 2 * g) / 3, M = (M + 2 * y) / 3, g = (s + 2 * g) / 3, y = (l + 2 * y) / 3) : (v = t[o++], m = t[o++]), K[0][0] = g, K[0][1] = y, K[1][0] = b, K[1][1] = M, K[2][0] = v, K[2][1] = m, s = v, l = m;
              break;
            case d:
              var A = 0, k = 0, I = 1, z = 1, D = 0;
              e && (A = e[4], k = e[5], I = _(e[0] * e[0] + e[1] * e[1]), z = _(e[2] * e[2] + e[3] * e[3]), D = Math.atan2(-e[1] / z, e[0] / I));
              var E = t[o++], O = t[o++], R = t[o++], B = t[o++], N = t[o++] + D, G = t[o++] + N + D;
              o++;
              var F = t[o++], V = E + w(N) * R, H = O + S(N) * B, g = E + w(G) * R, y = O + S(G) * B, q = F ? " wa " : " at ";
              Math.abs(V - g) < 1e-10 && (Math.abs(G - N) > .01 ? F && (V += 270 / L) : Math.abs(H - O) < 1e-10 ? F && E > V || !F && V > E ? y -= 270 / L : y += 270 / L : F && O > H || !F && H > O ? g += 270 / L : g -= 270 / L), p.push(q, x(((E - R) * I + A) * L - P), C, x(((O - B) * z + k) * L - P), C, x(((E + R) * I + A) * L - P), C, x(((O + B) * z + k) * L - P), C, x((V * I + A) * L - P), C, x((H * z + k) * L - P), C, x((g * I + A) * L - P), C, x((y * z + k) * L - P)), s = g, l = y;
              break;
            case n.R:
              var W = K[0], Z = K[1];
              W[0] = t[o++], W[1] = t[o++], Z[0] = W[0] + t[o++], Z[1] = W[1] + t[o++], e && (T(W, W, e), T(Z, Z, e)), W[0] = x(W[0] * L - P), Z[0] = x(Z[0] * L - P), W[1] = x(W[1] * L - P), Z[1] = x(Z[1] * L - P), p.push(" m ", W[0], C, W[1], " l ", Z[0], C, W[1], " l ", Z[0], C, Z[1], " l ", W[0], C, Z[1]);
              break;
            case n.Z:
              p.push(" x ")
          }
          if (i > 0) {
            p.push(r);
            for (var U = 0; i > U; U++) {
              var j = K[U];
              e && T(j, j, e), p.push(x(j[0] * L - P), C, x(j[1] * L - P), i - 1 > U ? C : "")
            }
          }
        }
        return p.join("")
      };
      v[xe].brushVML = function (t) {
        var e = this.style, i = this._vmlEl;
        i || (i = g.createNode("shape"), R(i), this._vmlEl = i), Q(i, "fill", e, this), Q(i, c, e, this);
        var n = this[r], a = null != n, o = i.getElementsByTagName(c)[0];
        if (o) {
          var s = e[u];
          if (a && !e.strokeNoScale) {
            var l = n[0] * n[3] - n[1] * n[2];
            s *= _(b(l))
          }
          o.weight = s + "px"
        }
        var h = this.path;
        this.__dirtyPath && (h.beginPath(), this.buildPath(h, this.shape), h.toStatic(), this.__dirtyPath = !1), i.path = J(h.data, this[r]), i.style.zIndex = q(this[j], this.z, this.z2), F(t, i), e.text ? this.drawRectText(t, this[O]()) : this.removeRectText(t)
      }, v[xe].onRemove = function (t) {
        V(t, this._vmlEl), this.removeRectText(t)
      }, v[xe].onAdd = function (t) {
        F(t, this._vmlEl), this.appendRectText(t)
      };
      var te = function (t) {
        return "object" == typeof t && t.tagName && "IMG" === t.tagName.toUpperCase()
      };
      d[xe].brushVML = function (t) {
        var e, i, n = this.style, a = n.image;
        if (te(a)) {
          var o = a.src;
          if (o === this._imageSrc)e = this._imageWidth, i = this._imageHeight; else {
            var s = a.runtimeStyle, l = s.width, c = s[ce];
            s.width = "auto", s[ce] = "auto", e = a.width, i = a[ce], s.width = l, s[ce] = c, this._imageSrc = o, this._imageWidth = e, this._imageHeight = i
          }
          a = o
        } else a === this._imageSrc && (e = this._imageWidth, i = this._imageHeight);
        if (a) {
          var u = n.x || 0, h = n.y || 0, d = n.width, f = n[ce], p = n.sWidth, v = n.sHeight, m = n.sx || 0, b = n.sy || 0, w = p && v, S = this._vmlEl;
          S || (S = g.doc[y]("div"), R(S), this._vmlEl = S);
          var L, P = S.style, k = !1, z = 1, D = 1;
          if (this[r] && (L = this[r], z = _(L[0] * L[0] + L[1] * L[1]), D = _(L[2] * L[2] + L[3] * L[3]), k = L[1] || L[2]), k) {
            var E = [u, h], B = [u + d, h], N = [u, h + f], G = [u + d, h + f];
            T(E, E, L), T(B, B, L), T(N, N, L), T(G, G, L);
            var V = M(E[0], B[0], N[0], G[0]), W = M(E[1], B[1], N[1], G[1]), Z = [];
            Z.push("M11=", L[0] / z, C, "M12=", L[2] / D, C, "M21=", L[1] / z, C, "M22=", L[3] / D, C, "Dx=", x(u * z + L[4]), C, "Dy=", x(h * D + L[5])), P.padding = "0 " + x(V) + "px " + x(W) + "px 0", P[H] = A + ".Matrix(" + Z.join("") + ", SizingMethod=clip)"
          } else L && (u = u * z + L[4], h = h * D + L[5]), P[H] = "", P.left = x(u) + "px", P.top = x(h) + "px";
          var U = this._imageEl, X = this._cropEl;
          U || (U = g.doc[y]("div"), this._imageEl = U);
          var Y = U.style;
          if (w) {
            if (e && i)Y.width = x(z * e * d / p) + "px", Y[ce] = x(D * i * f / v) + "px"; else {
              var $ = new Image, Q = this;
              $.onload = function () {
                $.onload = null, e = $.width, i = $[ce], Y.width = x(z * e * d / p) + "px", Y[ce] = x(D * i * f / v) + "px", Q._imageWidth = e, Q._imageHeight = i, Q._imageSrc = a
              }, $.src = a
            }
            X || (X = g.doc[y]("div"), X.style.overflow = "hidden", this._cropEl = X);
            var K = X.style;
            K.width = x((d + m * d / p) * z), K[ce] = x((f + b * f / v) * D), K[H] = A + ".Matrix(Dx=" + -m * d / p * z + ",Dy=" + -b * f / v * D + ")", X.parentNode || S.appendChild(X), U.parentNode != X && X.appendChild(U)
          } else Y.width = x(z * d) + "px", Y[ce] = x(D * f) + "px", S.appendChild(U), X && X.parentNode && (S.removeChild(X), this._cropEl = null);
          var J = "", ee = n[I];
          1 > ee && (J += ".Alpha(opacity=" + x(100 * ee) + ") "), J += A + ".AlphaImageLoader(src=" + a + ", SizingMethod=scale)", Y[H] = J, S.style.zIndex = q(this[j], this.z, this.z2), F(t, S), n.text && this.drawRectText(t, this[O]())
        }
      }, d[xe].onRemove = function (t) {
        V(t, this._vmlEl), this._vmlEl = null, this._cropEl = null, this._imageEl = null, this.removeRectText(t)
      }, d[xe].onAdd = function (t) {
        F(t, this._vmlEl), this.appendRectText(t)
      };
      var ee, ie = f, re = {}, ae = 0, oe = 100, se = document[y]("div"), le = function (t) {
        var e = re[t];
        if (!e) {
          ae > oe && (ae = 0, re = {});
          var i, n = se.style;
          try {
            n.font = t, i = n.fontFamily.split(",")[0]
          } catch (r) {
          }
          e = {
            style: n.fontStyle || ie,
            variant: n.fontVariant || ie,
            weight: n.fontWeight || ie,
            size: 0 | parseFloat(n.fontSize || 12),
            family: i || "Microsoft YaHei"
          }, re[t] = e, ae++
        }
        return e
      };
      o.measureText = function (t, e) {
        var i = g.doc;
        ee || (ee = i[y]("div"), ee.style.cssText = "position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;", g.doc.body.appendChild(ee));
        try {
          ee.style.font = e
        } catch (n) {
        }
        return ee.innerHTML = "", ee.appendChild(i.createTextNode(t)), {width: ee.offsetWidth}
      };
      for (var he = new i, de = function (t, e, i, n) {
        var a = this.style, s = a.text;
        if (s) {
          var l, u, d = a[N], f = le(a.textFont), p = f.style + " " + f.variant + " " + f.weight + " " + f.size + 'px "' + f.family + '"', v = a.textBaseline, m = a.textVerticalAlign;
          i = i || o[O](s, p, d, v);
          var y = this[r];
          if (y && !n && (he.copy(e), he[h](y), e = he), n)l = e.x, u = e.y; else {
            var _ = a.textPosition, b = a.textDistance;
            if (_ instanceof Array)l = e.x + W(_[0], e.width), u = e.y + W(_[1], e[ce]), d = d || "left", v = v || "top"; else {
              var w = o.adjustTextPositionOnRect(_, e, i, b);
              l = w.x, u = w.y, d = d || w[N], v = v || w.textBaseline
            }
          }
          if (m) {
            switch (m) {
              case E:
                u -= i[ce] / 2;
                break;
              case ue:
                u -= i[ce]
            }
            v = "top"
          }
          var S = f.size;
          switch (v) {
            case"hanging":
            case"top":
              u += S / 1.75;
              break;
            case E:
              break;
            default:
              u -= S / 2.25
          }
          switch (d) {
            case"left":
              break;
            case D:
              l -= i.width / 2;
              break;
            case"right":
              l -= i.width
          }
          var M, A, L, P = g.createNode, k = this._textVmlEl;
          k ? (L = k.firstChild, M = L.nextSibling, A = M.nextSibling) : (k = P("line"), M = P("path"), A = P("textpath"), L = P("skew"), A.style["v-text-align"] = "left", R(k), M.textpathok = !0, A.on = !0, k.from = "0 0", k.to = "1000 0.05", F(k, L), F(k, M), F(k, A), this._textVmlEl = k);
          var z = [l, u], G = k.style;
          y && n ? (T(z, z, y), L.on = !0, L.matrix = y[0].toFixed(3) + C + y[2].toFixed(3) + C + y[1].toFixed(3) + C + y[3].toFixed(3) + ",0,0", L.offset = (x(z[0]) || 0) + "," + (x(z[1]) || 0), L.origin = "0 0", G.left = "0px", G.top = "0px") : (L.on = !1, G.left = x(l) + "px", G.top = x(u) + "px"), A[ye] = B(s);
          try {
            A.style.font = p
          } catch (V) {
          }
          Q(k, "fill", {fill: n ? a.fill : a.textFill, opacity: a[I]}, this), Q(k, c, {
            stroke: n ? a[c] : a.textStroke,
            opacity: a[I],
            lineDash: a.lineDash
          }, this), k.style.zIndex = q(this[j], this.z, this.z2), F(t, k)
        }
      }, pe = function (t) {
        V(t, this._textVmlEl), this._textVmlEl = null
      }, ve = function (t) {
        F(t, this._textVmlEl)
      }, me = [s, l, d, v, p], ge = 0; ge < me[ne]; ge++) {
        var _e = me[ge][xe];
        _e.drawRectText = de, _e.removeRectText = pe, _e.appendRectText = ve
      }
      p[xe].brushVML = function (t) {
        var e = this.style;
        e.text ? this.drawRectText(t, {
          x: e.x || 0,
          y: e.y || 0,
          width: 0,
          height: 0
        }, this[O](), !0) : this.removeRectText(t)
      }, p[xe].onRemove = function (t) {
        this.removeRectText(t)
      }, p[xe].onAdd = function (t) {
        this.appendRectText(t)
      }
    }
  }), e("echarts/component/legend/legendAction", [Pe, p, Le], function (t) {
    function e(t, e, i) {
      var r, a = {}, o = "toggleSelected" === t;
      return i.eachComponent("legend", function (i) {
        o && null != r ? i[r ? "select" : "unSelect"](e.name) : (i[t](e.name), r = i.isSelected(e.name));
        var s = i[we]();
        n.each(s, function (t) {
          var e = t.get("name");
          if ("\n" !== e && "" !== e) {
            var n = i.isSelected(e);
            a[e] = e in a ? a[e] && n : n
          }
        })
      }), {name: e.name, selected: a}
    }

    var i = t(p), n = t(Le);
    i.registerAction("legendToggleSelect", "legendselectchanged", n.curry(e, "toggleSelected")), i.registerAction("legendSelect", "legendselected", n.curry(e, "select")), i.registerAction("legendUnSelect", "legendunselected", n.curry(e, "unSelect"))
  }), e("echarts/component/legend/LegendView", [Pe, Le, "../../util/symbol", A, "../helper/listComponent", p], function (t) {
    function e(t, e) {
      e.dispatchAction({type: "legendToggleSelect", name: t})
    }

    function i(t, e, i) {
      var n = i.getZr()[de].getDisplayList()[0];
      n && n.useHoverLayer || t.get("legendHoverLink") && i.dispatchAction({
        type: "highlight",
        seriesName: t.name,
        name: e
      })
    }

    function n(t, e, i) {
      var n = i.getZr()[de].getDisplayList()[0];
      n && n.useHoverLayer || t.get("legendHoverLink") && i.dispatchAction({
        type: "downplay",
        seriesName: t.name,
        name: e
      })
    }

    var r = t(Le), a = t("../../util/symbol"), s = t(A), l = t("../helper/listComponent"), c = r.curry;
    return t(p)[Ae]({
      type: "legend", init: function () {
        this._symbolTypeStore = {}
      }, render: function (t, a, o) {
        var u = this.group;
        if (u[Ce](), t.get("show")) {
          var h = t.get("selectedMode"), d = t.get("align");
          "auto" === d && (d = "right" === t.get("left") && "vertical" === t.get("orient") ? "right" : "left");
          var f = {};
          r.each(t[we](), function (r) {
            var l = r.get("name");
            if ("" === l || "\n" === l)return void u.add(new s.Group({newline: !0}));
            var p = a.getSeriesByName(l)[0];
            if (!f[l])if (p) {
              var v = p[we](), m = v.getVisual("color");
              typeof m === W && (m = m(p[Y](0)));
              var g = v.getVisual("legendSymbol") || "roundRect", y = v.getVisual("symbol"), x = this._createItem(l, r, t, g, y, d, m, h);
              x.on("click", c(e, l, o)).on(te, c(i, p, "", o)).on(J, c(n, p, "", o)), f[l] = !0
            } else a.eachRawSeries(function (a) {
              if (!f[l] && a.legendDataProvider) {
                var s = a.legendDataProvider(), u = s.indexOfName(l);
                if (0 > u)return;
                var p = s[w](u, "color"), v = "roundRect", m = this._createItem(l, r, t, v, null, d, p, h);
                m.on("click", c(e, l, o)).on(te, c(i, a, l, o)).on(J, c(n, a, l, o)), f[l] = !0
              }
            }, this)
          }, this), l.layout(u, t, o), l.addBackground(u, t)
        }
      }, _createItem: function (t, e, i, n, l, c, u, h) {
        var d = i.get("itemWidth"), f = i.get("itemHeight"), p = i.get("inactiveColor"), v = i.isSelected(t), m = new s.Group, g = e[me](G), y = e.get("icon"), x = e[me]("tooltip");
        if (n = y || n, m.add(a.createSymbol(n, 0, 0, d, f, v ? u : p)), !y && l && (l !== n || "none" == l)) {
          var _ = .8 * f;
          "none" === l && (l = "circle"), m.add(a.createSymbol(l, (d - _) / 2, (f - _) / 2, _, _, v ? u : p))
        }
        var b = "left" === c ? d + 5 : -5, w = c, S = i.get("formatter"), M = t;
        typeof S === ye && S ? M = S[U]("{name}", t) : typeof S === W && (M = S(t));
        var T = new s.Text({
          style: {
            text: M,
            x: b,
            y: f / 2,
            fill: v ? g[R]() : p,
            textFont: g[B](),
            textAlign: w,
            textVerticalAlign: "middle"
          }
        });
        m.add(T);
        var C = new s.Rect({
          shape: m[O](),
          invisible: !0,
          tooltip: x.get("show") ? r[re]({
            content: t, formatter: function () {
              return t
            }, formatterParams: {componentType: "legend", legendIndex: i.componentIndex, name: t, $vars: ["name"]}
          }, x[o]) : null
        });
        return m.add(C), m.eachChild(function (t) {
          t.silent = !0
        }), C.silent = !h, this.group.add(m), s.setHoverStyle(m), m
      }
    })
  }), e("echarts/component/legend/legendFilter", [], function () {
    return function (t) {
      var e = t.findComponents({mainType: "legend"});
      e && e[ne] && t.filterSeries(function (t) {
        for (var i = 0; i < e[ne]; i++)if (!e[i].isSelected(t.name))return !1;
        return !0
      })
    }
  }), e("echarts/scale/Scale", [Pe, "../util/clazz"], function (t) {
    function e() {
      this._extent = [1 / 0, -1 / 0], this._interval = 0, this.init && this.init.apply(this, arguments)
    }

    var i = t("../util/clazz"), n = e[xe];
    return n.parse = function (t) {
      return t
    }, n[k] = function (t) {
      var e = this._extent;
      return t >= e[0] && t <= e[1]
    }, n.normalize = function (t) {
      var e = this._extent;
      return e[1] === e[0] ? .5 : (t - e[0]) / (e[1] - e[0])
    }, n.scale = function (t) {
      var e = this._extent;
      return t * (e[1] - e[0]) + e[0]
    }, n.unionExtent = function (t) {
      var e = this._extent;
      t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1])
    }, n[L] = function () {
      return this._extent.slice()
    }, n.setExtent = function (t, e) {
      var i = this._extent;
      isNaN(t) || (i[0] = t), isNaN(e) || (i[1] = e)
    }, n.getTicksLabels = function () {
      for (var t = [], e = this[P](), i = 0; i < e[ne]; i++)t.push(this.getLabel(e[i]));
      return t
    }, i.enableClassExtend(e), i.enableClassManagement(e, {registerWhenExtend: !0}), e
  }), e("echarts/scale/Interval", [Pe, "../util/number", "../util/format", "./Scale"], function (t) {
    var e = t("../util/number"), i = t("../util/format"), n = t("./Scale"), r = Math.floor, a = Math.ceil, o = n[re]({
      type: "interval",
      _interval: 0,
      setExtent: function (t, e) {
        var i = this._extent;
        isNaN(t) || (i[0] = parseFloat(t)), isNaN(e) || (i[1] = parseFloat(e))
      },
      unionExtent: function (t) {
        var e = this._extent;
        t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1]), o[xe].setExtent.call(this, e[0], e[1])
      },
      getInterval: function () {
        return this._interval || this.niceTicks(), this._interval
      },
      setInterval: function (t) {
        this._interval = t, this._niceExtent = this._extent.slice()
      },
      getTicks: function () {
        this._interval || this.niceTicks();
        var t = this._interval, i = this._extent, n = [], r = 1e4;
        if (t) {
          var a = this._niceExtent;
          i[0] < a[0] && n.push(i[0]);
          for (var o = a[0]; o <= a[1];)if (n.push(o), o = e.round(o + t), n[ne] > r)return [];
          i[1] > a[1] && n.push(i[1])
        }
        return n
      },
      getTicksLabels: function () {
        for (var t = [], e = this[P](), i = 0; i < e[ne]; i++)t.push(this.getLabel(e[i]));
        return t
      },
      getLabel: function (t) {
        return i.addCommas(t)
      },
      niceTicks: function (t) {
        t = t || 5;
        var i = this._extent, n = i[1] - i[0];
        if (isFinite(n)) {
          0 > n && (n = -n, i.reverse());
          var o = e.nice(n / t, !0), s = [e.round(a(i[0] / o) * o), e.round(r(i[1] / o) * o)];
          this._interval = o, this._niceExtent = s
        }
      },
      niceExtent: function (t, i, n) {
        var o = this._extent;
        if (o[0] === o[1])if (0 !== o[0]) {
          var s = o[0];
          n ? o[0] -= s / 2 : (o[1] += s / 2, o[0] -= s / 2)
        } else o[1] = 1;
        var l = o[1] - o[0];
        isFinite(l) || (o[0] = 0, o[1] = 1), this.niceTicks(t);
        var c = this._interval;
        i || (o[0] = e.round(r(o[0] / c) * c)), n || (o[1] = e.round(a(o[1] / c) * c))
      }
    });
    return o[le] = function () {
      return new o
    }, o
  }), e("zrender/graphic/Path", [Pe, "./Displayable", "../core/util", "../core/PathProxy", "../contain/path", "./Pattern"], function (t) {
    function e(t) {
      n.call(this, t), this.path = new o
    }

    var n = t("./Displayable"), a = t("../core/util"), o = t("../core/PathProxy"), s = t("../contain/path"), l = t("./Pattern"), h = l[xe].getCanvasPattern, d = Math.abs;
    return e[xe] = {
      constructor: e, type: "path", __dirtyPath: !0, strokeContainThreshold: 5, brush: function (t, e) {
        var n = this.style, r = this.path, a = n.hasStroke(), o = n.hasFill(), s = n.fill, l = n[c], u = o && !!s.colorStops, d = a && !!l.colorStops, f = o && !!s.image, p = a && !!l.image;
        if (n.bind(t, this, e), this.setTransform(t), this[i]) {
          var v = this[O]();
          u && (this._fillGradient = n.getGradient(t, s, v)), d && (this._strokeGradient = n.getGradient(t, l, v))
        }
        u ? t.fillStyle = this._fillGradient : f && (t.fillStyle = h.call(s, t)), d ? t.strokeStyle = this._strokeGradient : p && (t.strokeStyle = h.call(l, t));
        var m = n.lineDash, g = n.lineDashOffset, y = !!t.setLineDash, x = this.getGlobalScale();
        r.setScale(x[0], x[1]), this.__dirtyPath || m && !y && a ? (r = this.path.beginPath(t), m && !y && (r.setLineDash(m), r.setLineDashOffset(g)), this.buildPath(r, this.shape, !1), this.__dirtyPath = !1) : (t.beginPath(), this.path.rebuildPath(t)), o && r.fill(t), m && y && (t.setLineDash(m), t.lineDashOffset = g), a && r[c](t), m && y && t.setLineDash([]), this.restoreTransform(t), (n.text || 0 === n.text) && this.drawRectText(t, this[O]())
      }, buildPath: function () {
      }, getBoundingRect: function () {
        var t = this._rect, e = this.style, n = !t;
        if (n) {
          var r = this.path;
          this.__dirtyPath && (r.beginPath(), this.buildPath(r, this.shape, !1)), t = r[O]()
        }
        if (this._rect = t, e.hasStroke()) {
          var a = this._rectWithStroke || (this._rectWithStroke = t.clone());
          if (this[i] || n) {
            a.copy(t);
            var o = e[u], s = e.strokeNoScale ? this.getLineScale() : 1;
            e.hasFill() || (o = Math.max(o, this.strokeContainThreshold || 4)), s > 1e-10 && (a.width += o / s, a[ce] += o / s, a.x -= o / s / 2, a.y -= o / s / 2)
          }
          return a
        }
        return t
      }, contain: function (t, e) {
        var i = this.transformCoordToLocal(t, e), n = this[O](), r = this.style;
        if (t = i[0], e = i[1], n[k](t, e)) {
          var a = this.path.data;
          if (r.hasStroke()) {
            var o = r[u], l = r.strokeNoScale ? this.getLineScale() : 1;
            if (l > 1e-10 && (r.hasFill() || (o = Math.max(o, this.strokeContainThreshold)), s.containStroke(a, o / l, t, e)))return !0
          }
          if (r.hasFill())return s[k](a, t, e)
        }
        return !1
      }, dirty: function (t) {
        null == t && (t = !0), t && (this.__dirtyPath = t, this._rect = null), this[i] = !0, this.__zr && this.__zr.refresh(), this.__clipTarget && this.__clipTarget.dirty()
      }, animateShape: function (t) {
        return this.animate("shape", t)
      }, attrKV: function (t, e) {
        "shape" === t ? (this.setShape(e), this.__dirtyPath = !0, this._rect = null) : n[xe].attrKV.call(this, t, e)
      }, setShape: function (t, e) {
        var i = this.shape;
        if (i) {
          if (a[oe](t))for (var n in t)i[n] = t[n]; else i[t] = e;
          this.dirty(!0)
        }
        return this
      }, getLineScale: function () {
        var t = this[r];
        return t && d(t[0] - 1) > 1e-10 && d(t[3] - 1) > 1e-10 ? Math.sqrt(d(t[0] * t[3] - t[2] * t[1])) : 1
      }
    }, e[re] = function (t) {
      var i = function (i) {
        e.call(this, i), t.style && this.style.extendFrom(t.style, !1);
        var n = t.shape;
        if (n) {
          this.shape = this.shape || {};
          var r = this.shape;
          for (var a in n)!r.hasOwnProperty(a) && n.hasOwnProperty(a) && (r[a] = n[a])
        }
        t.init && t.init.call(this, i)
      };
      a[F](i, e);
      for (var n in t)"style" !== n && "shape" !== n && (i[xe][n] = t[n]);
      return i
    }, a[F](e, n), e
  }), e("zrender/tool/path", [Pe, "../graphic/Path", "../core/PathProxy", "./transformPath", "../core/matrix"], function (t) {
    function e(t, e, i, n, r, a, o, s, l, c, h) {
      var v = l * (p / 180), y = f(v) * (t - i) / 2 + d(v) * (e - n) / 2, x = -1 * d(v) * (t - i) / 2 + f(v) * (e - n) / 2, _ = y * y / (o * o) + x * x / (s * s);
      _ > 1 && (o *= u(_), s *= u(_));
      var b = (r === a ? -1 : 1) * u((o * o * s * s - o * o * x * x - s * s * y * y) / (o * o * x * x + s * s * y * y)) || 0, w = b * o * x / s, S = b * -s * y / o, M = (t + i) / 2 + f(v) * w - d(v) * S, T = (e + n) / 2 + d(v) * w + f(v) * S, C = g([1, 0], [(y - w) / o, (x - S) / s]), A = [(y - w) / o, (x - S) / s], L = [(-1 * y - w) / o, (-1 * x - S) / s], P = g(A, L);
      m(A, L) <= -1 && (P = p), m(A, L) >= 1 && (P = 0), 0 === a && P > 0 && (P -= 2 * p), 1 === a && 0 > P && (P += 2 * p), h.addData(c, M, T, o, s, C, P, v, a)
    }

    function n(t) {
      if (!t)return [];
      var i, n = t[U](/-/g, " -")[U](/  /g, " ")[U](/ /g, ",")[U](/,,/g, ",");
      for (i = 0; i < c[ne]; i++)n = n[U](new RegExp(c[i], "g"), "|" + c[i]);
      var r, a = n.split("|"), s = 0, l = 0, u = new o, h = o.CMD;
      for (i = 1; i < a[ne]; i++) {
        var d, f = a[i], p = f.charAt(0), v = 0, m = f.slice(1)[U](/e,-/g, "e-").split(",");
        m[ne] > 0 && "" === m[0] && m.shift();
        for (var g = 0; g < m[ne]; g++)m[g] = parseFloat(m[g]);
        for (; v < m[ne] && !isNaN(m[v]) && !isNaN(m[0]);) {
          var y, x, _, b, w, S, M, T = s, C = l;
          switch (p) {
            case"l":
              s += m[v++], l += m[v++], d = h.L, u.addData(d, s, l);
              break;
            case"L":
              s = m[v++], l = m[v++], d = h.L, u.addData(d, s, l);
              break;
            case"m":
              s += m[v++], l += m[v++], d = h.M, u.addData(d, s, l), p = "l";
              break;
            case"M":
              s = m[v++], l = m[v++], d = h.M, u.addData(d, s, l), p = "L";
              break;
            case"h":
              s += m[v++], d = h.L, u.addData(d, s, l);
              break;
            case"H":
              s = m[v++], d = h.L, u.addData(d, s, l);
              break;
            case"v":
              l += m[v++], d = h.L, u.addData(d, s, l);
              break;
            case"V":
              l = m[v++], d = h.L, u.addData(d, s, l);
              break;
            case"C":
              d = h.C, u.addData(d, m[v++], m[v++], m[v++], m[v++], m[v++], m[v++]), s = m[v - 2], l = m[v - 1];
              break;
            case"c":
              d = h.C, u.addData(d, m[v++] + s, m[v++] + l, m[v++] + s, m[v++] + l, m[v++] + s, m[v++] + l), s += m[v - 2], l += m[v - 1];
              break;
            case"S":
              y = s, x = l;
              var A = u.len(), L = u.data;
              r === h.C && (y += s - L[A - 4], x += l - L[A - 3]), d = h.C, T = m[v++], C = m[v++], s = m[v++], l = m[v++], u.addData(d, y, x, T, C, s, l);
              break;
            case"s":
              y = s, x = l;
              var A = u.len(), L = u.data;
              r === h.C && (y += s - L[A - 4], x += l - L[A - 3]), d = h.C, T = s + m[v++], C = l + m[v++], s += m[v++], l += m[v++], u.addData(d, y, x, T, C, s, l);
              break;
            case"Q":
              T = m[v++], C = m[v++], s = m[v++], l = m[v++], d = h.Q, u.addData(d, T, C, s, l);
              break;
            case"q":
              T = m[v++] + s, C = m[v++] + l, s += m[v++], l += m[v++], d = h.Q, u.addData(d, T, C, s, l);
              break;
            case"T":
              y = s, x = l;
              var A = u.len(), L = u.data;
              r === h.Q && (y += s - L[A - 4], x += l - L[A - 3]), s = m[v++], l = m[v++], d = h.Q, u.addData(d, y, x, s, l);
              break;
            case"t":
              y = s, x = l;
              var A = u.len(), L = u.data;
              r === h.Q && (y += s - L[A - 4], x += l - L[A - 3]), s += m[v++], l += m[v++], d = h.Q, u.addData(d, y, x, s, l);
              break;
            case"A":
              _ = m[v++], b = m[v++], w = m[v++], S = m[v++], M = m[v++], T = s, C = l, s = m[v++], l = m[v++], d = h.A, e(T, C, s, l, S, M, _, b, w, d, u);
              break;
            case"a":
              _ = m[v++], b = m[v++], w = m[v++], S = m[v++], M = m[v++], T = s, C = l, s += m[v++], l += m[v++], d = h.A, e(T, C, s, l, S, M, _, b, w, d, u)
          }
        }
        ("z" === p || "Z" === p) && (d = h.Z, u.addData(d)), r = d
      }
      return u.toStatic(), u
    }

    function r(t, e) {
      var i, r = n(t);
      return e = e || {}, e.buildPath = function (t) {
        t.setData(r.data), i && s(t, i);
        var e = t.getContext();
        e && t.rebuildPath(e)
      }, e[h] = function (t) {
        i || (i = l[le]()), l.mul(i, t, i)
      }, e
    }

    var a = t("../graphic/Path"), o = t("../core/PathProxy"), s = t("./transformPath"), l = t("../core/matrix"), c = ["m", "M", "l", "L", "v", "V", "h", "H", "z", "Z", "c", "C", "q", "Q", "t", "T", "s", "S", "a", "A"], u = Math.sqrt, d = Math.sin, f = Math.cos, p = Math.PI, v = function (t) {
      return Math.sqrt(t[0] * t[0] + t[1] * t[1])
    }, m = function (t, e) {
      return (t[0] * e[0] + t[1] * e[1]) / (v(t) * v(e))
    }, g = function (t, e) {
      return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(m(t, e))
    };
    return {
      createFromString: function (t, e) {
        return new a(r(t, e))
      }, extendFromString: function (t, e) {
        return a[re](r(t, e))
      }, mergePath: function (t, e) {
        for (var n = [], r = t[ne], o = 0; r > o; o++) {
          var s = t[o];
          s[i] && s.buildPath(s.path, s.shape, !0), n.push(s.path)
        }
        var l = new a(e);
        return l.buildPath = function (t) {
          t.appendPath(n);
          var e = t.getContext();
          e && t.rebuildPath(e)
        }, l
      }
    }
  }), e("zrender/graphic/Gradient", [Pe], function () {
    var t = function (t) {
      this.colorStops = t || []
    };
    return t[xe] = {
      constructor: t, addColorStop: function (t, e) {
        this.colorStops.push({offset: t, color: e})
      }
    }, t
  }), e("zrender/container/Group", [Pe, "../core/util", "../Element", "../core/BoundingRect"], function (t) {
    var e = t("../core/util"), n = t("../Element"), r = t("../core/BoundingRect"), a = function (t) {
      t = t || {}, n.call(this, t);
      for (var e in t)this[e] = t[e];
      this._children = [], this.__storage = null, this[i] = !0
    };
    return a[xe] = {
      constructor: a, isGroup: !0, type: "group", silent: !1, children: function () {
        return this._children.slice()
      }, childAt: function (t) {
        return this._children[t]
      }, childOfName: function (t) {
        for (var e = this._children, i = 0; i < e[ne]; i++)if (e[i].name === t)return e[i]
      }, childCount: function () {
        return this._children[ne]
      }, add: function (t) {
        return t && t !== this && t.parent !== this && (this._children.push(t), this._doAdd(t)), this
      }, addBefore: function (t, e) {
        if (t && t !== this && t.parent !== this && e && e.parent === this) {
          var i = this._children, n = i[V](e);
          n >= 0 && (i[ee](n, 0, t), this._doAdd(t))
        }
        return this
      }, _doAdd: function (t) {
        t.parent && t.parent[ae](t), t.parent = this;
        var e = this.__storage, i = this.__zr;
        e && e !== t.__storage && (e.addToMap(t), t instanceof a && t.addChildrenToStorage(e)), i && i.refresh()
      }, remove: function (t) {
        var i = this.__zr, n = this.__storage, r = this._children, o = e[V](r, t);
        return 0 > o ? this : (r[ee](o, 1), t.parent = null, n && (n.delFromMap(t.id), t instanceof a && t.delChildrenFromStorage(n)), i && i.refresh(), this)
      }, removeAll: function () {
        var t, e, i = this._children, n = this.__storage;
        for (e = 0; e < i[ne]; e++)t = i[e], n && (n.delFromMap(t.id), t instanceof a && t.delChildrenFromStorage(n)), t.parent = null;
        return i[ne] = 0, this
      }, eachChild: function (t, e) {
        for (var i = this._children, n = 0; n < i[ne]; n++) {
          var r = i[n];
          t.call(e, r, n)
        }
        return this
      }, traverse: function (t, e) {
        for (var i = 0; i < this._children[ne]; i++) {
          var n = this._children[i];
          t.call(e, n), "group" === n.type && n.traverse(t, e)
        }
        return this
      }, addChildrenToStorage: function (t) {
        for (var e = 0; e < this._children[ne]; e++) {
          var i = this._children[e];
          t.addToMap(i), i instanceof a && i.addChildrenToStorage(t)
        }
      }, delChildrenFromStorage: function (t) {
        for (var e = 0; e < this._children[ne]; e++) {
          var i = this._children[e];
          t.delFromMap(i.id), i instanceof a && i.delChildrenFromStorage(t)
        }
      }, dirty: function () {
        return this[i] = !0, this.__zr && this.__zr.refresh(), this
      }, getBoundingRect: function (t) {
        for (var e = null, i = new r(0, 0, 0, 0), n = t || this._children, a = [], o = 0; o < n[ne]; o++) {
          var s = n[o];
          if (!s[he] && !s.invisible) {
            var l = s[O](), c = s.getLocalTransform(a);
            c ? (i.copy(l), i[h](c), e = e || i.clone(), e.union(i)) : (e = e || l.clone(), e.union(l))
          }
        }
        return e || i
      }
    }, e[F](a, n), a
  }), e("zrender/graphic/Image", [Pe, "./Displayable", "../core/BoundingRect", "../core/util", "../core/LRU"], function (t) {
    function e(t) {
      i.call(this, t)
    }

    var i = t("./Displayable"), n = t("../core/BoundingRect"), r = t("../core/util"), a = t("../core/LRU"), o = new a(50);
    return e[xe] = {
      constructor: e, type: "image", brush: function (t, e) {
        var i, n = this.style, r = n.image;
        if (n.bind(t, this, e), i = typeof r === ye ? this._image : r, !i && r) {
          var a = o.get(r);
          if (!a)return i = new Image, i.onload = function () {
            i.onload = null;
            for (var t = 0; t < a.pending[ne]; t++)a.pending[t].dirty()
          }, a = {image: i, pending: [this]}, i.src = r, o.put(r, a), void(this._image = i);
          if (i = a.image, this._image = i, !i.width || !i[ce])return void a.pending.push(this)
        }
        if (i) {
          var s = n.width || i.width, l = n[ce] || i[ce], c = n.x || 0, u = n.y || 0;
          if (!i.width || !i[ce])return;
          if (this.setTransform(t), n.sWidth && n.sHeight) {
            var h = n.sx || 0, d = n.sy || 0;
            t.drawImage(i, h, d, n.sWidth, n.sHeight, c, u, s, l)
          } else if (n.sx && n.sy) {
            var h = n.sx, d = n.sy, f = s - h, p = l - d;
            t.drawImage(i, h, d, f, p, c, u, s, l)
          } else t.drawImage(i, c, u, s, l);
          null == n.width && (n.width = s), null == n[ce] && (n[ce] = l), this.restoreTransform(t), null != n.text && this.drawRectText(t, this[O]())
        }
      }, getBoundingRect: function () {
        var t = this.style;
        return this._rect || (this._rect = new n(t.x || 0, t.y || 0, t.width || 0, t[ce] || 0)), this._rect
      }
    }, r[F](e, i), e
  }), e("zrender/graphic/shape/Circle", [Pe, "../Path"], function (t) {
    return t("../Path")[re]({
      type: "circle", shape: {cx: 0, cy: 0, r: 0}, buildPath: function (t, e, i) {
        i && t[n](e.cx + e.r, e.cy), t.arc(e.cx, e.cy, e.r, 0, 2 * Math.PI, !0)
      }
    })
  }), e("zrender/graphic/shape/Sector", [Pe, "../Path"], function (t) {
    return t("../Path")[re]({
      type: "sector",
      shape: {cx: 0, cy: 0, r0: 0, r: 0, startAngle: 0, endAngle: 2 * Math.PI, clockwise: !0},
      buildPath: function (t, e) {
        var i = e.cx, r = e.cy, a = Math.max(e.r0 || 0, 0), o = Math.max(e.r, 0), s = e.startAngle, l = e.endAngle, c = e.clockwise, u = Math.cos(s), h = Math.sin(s);
        t[n](u * a + i, h * a + r), t.lineTo(u * o + i, h * o + r), t.arc(i, r, o, s, l, !c), t.lineTo(Math.cos(l) * a + i, Math.sin(l) * a + r), 0 !== a && t.arc(i, r, a, l, s, c), t.closePath()
      }
    })
  }), e("zrender/graphic/shape/Polygon", [Pe, "../helper/poly", "../Path"], function (t) {
    var e = t("../helper/poly");
    return t("../Path")[re]({
      type: "polygon",
      shape: {points: null, smooth: !1, smoothConstraint: null},
      buildPath: function (t, i) {
        e.buildPath(t, i, !0)
      }
    })
  }), e("zrender/graphic/Text", [Pe, "./Displayable", "../core/util", "../contain/text"], function (t) {
    var e = t("./Displayable"), i = t("../core/util"), n = t("../contain/text"), r = function (t) {
      e.call(this, t)
    };
    return r[xe] = {
      constructor: r, type: "text", brush: function (t, e) {
        var i = this.style, r = i.x || 0, a = i.y || 0, o = i.text;
        if (null != o && (o += ""), i.bind(t, this, e), o) {
          this.setTransform(t);
          var s, l = i[N], c = i.textFont || i.font;
          if (i.textVerticalAlign) {
            var u = n[O](o, c, i[N], "top");
            switch (s = E, i.textVerticalAlign) {
              case E:
                a -= u[ce] / 2 - u.lineHeight / 2;
                break;
              case ue:
                a -= u[ce] - u.lineHeight / 2;
                break;
              default:
                a += u.lineHeight / 2
            }
          } else s = i.textBaseline;
          t.font = c, t[N] = l || "left", t[N] !== l && (t[N] = "left"), t.textBaseline = s || "alphabetic", t.textBaseline !== s && (t.textBaseline = "alphabetic");
          for (var h = n.measureText("", t.font).width, d = o.split("\n"), f = 0; f < d[ne]; f++)i.hasFill() && t.fillText(d[f], r, a), i.hasStroke() && t.strokeText(d[f], r, a), a += h;
          this.restoreTransform(t)
        }
      }, getBoundingRect: function () {
        if (!this._rect) {
          var t = this.style, e = t.textVerticalAlign, i = n[O](t.text + "", t.textFont || t.font, t[N], e ? "top" : t.textBaseline);
          switch (e) {
            case E:
              i.y -= i[ce] / 2;
              break;
            case ue:
              i.y -= i[ce]
          }
          i.x += t.x || 0, i.y += t.y || 0, this._rect = i
        }
        return this._rect
      }
    }, i[F](r, e), r
  }), e("zrender/graphic/shape/Ring", [Pe, "../Path"], function (t) {
    return t("../Path")[re]({
      type: "ring", shape: {cx: 0, cy: 0, r: 0, r0: 0}, buildPath: function (t, e) {
        var i = e.cx, r = e.cy, a = 2 * Math.PI;
        t[n](i + e.r, r), t.arc(i, r, e.r, 0, a, !1), t[n](i + e.r0, r), t.arc(i, r, e.r0, 0, a, !0)
      }
    })
  }), e("zrender/graphic/shape/Rect", [Pe, "../helper/roundRect", "../Path"], function (t) {
    var e = t("../helper/roundRect");
    return t("../Path")[re]({
      type: "rect", shape: {r: 0, x: 0, y: 0, width: 0, height: 0}, buildPath: function (t, i) {
        var n = i.x, r = i.y, a = i.width, o = i[ce];
        i.r ? e.buildPath(t, i) : t.rect(n, r, a, o), t.closePath()
      }
    })
  }), e("zrender/graphic/shape/Polyline", [Pe, "../helper/poly", "../Path"], function (t) {
    var e = t("../helper/poly");
    return t("../Path")[re]({
      type: "polyline",
      shape: {points: null, smooth: !1, smoothConstraint: null},
      style: {stroke: "#000", fill: null},
      buildPath: function (t, i) {
        e.buildPath(t, i, !1)
      }
    })
  }), e("zrender/graphic/shape/Arc", [Pe, "../Path"], function (t) {
    return t("../Path")[re]({
      type: "arc",
      shape: {cx: 0, cy: 0, r: 0, startAngle: 0, endAngle: 2 * Math.PI, clockwise: !0},
      style: {stroke: "#000", fill: null},
      buildPath: function (t, e) {
        var i = e.cx, r = e.cy, a = Math.max(e.r, 0), o = e.startAngle, s = e.endAngle, l = e.clockwise, c = Math.cos(o), u = Math.sin(o);
        t[n](c * a + i, u * a + r), t.arc(i, r, a, o, s, !l)
      }
    })
  }), e("zrender/graphic/shape/Line", [Pe, "../Path"], function (t) {
    return t("../Path")[re]({
      type: "line",
      shape: {x1: 0, y1: 0, x2: 0, y2: 0, percent: 1},
      style: {stroke: "#000", fill: null},
      buildPath: function (t, e) {
        var i = e.x1, r = e.y1, a = e.x2, o = e.y2, s = e.percent;
        0 !== s && (t[n](i, r), 1 > s && (a = i * (1 - s) + a * s, o = r * (1 - s) + o * s), t.lineTo(a, o))
      },
      pointAt: function (t) {
        var e = this.shape;
        return [e.x1 * (1 - t) + e.x2 * t, e.y1 * (1 - t) + e.y2 * t]
      }
    })
  }), e("zrender/graphic/shape/BezierCurve", [Pe, "../../core/curve", "../../core/vector", "../Path"], function (t) {
    function e(t, e, i) {
      var n = t.cpx2, r = t.cpy2;
      return null === n || null === r ? [(i ? u : l)(t.x1, t.cpx1, t.cpx2, t.x2, e), (i ? u : l)(t.y1, t.cpy1, t.cpy2, t.y2, e)] : [(i ? c : s)(t.x1, t.cpx1, t.x2, e), (i ? c : s)(t.y1, t.cpy1, t.y2, e)]
    }

    var i = t("../../core/curve"), r = t("../../core/vector"), a = i.quadraticSubdivide, o = i.cubicSubdivide, s = i.quadraticAt, l = i.cubicAt, c = i.quadraticDerivativeAt, u = i.cubicDerivativeAt, h = [];
    return t("../Path")[re]({
      type: "bezier-curve",
      shape: {x1: 0, y1: 0, x2: 0, y2: 0, cpx1: 0, cpy1: 0, percent: 1},
      style: {stroke: "#000", fill: null},
      buildPath: function (t, e) {
        var i = e.x1, r = e.y1, s = e.x2, l = e.y2, c = e.cpx1, u = e.cpy1, d = e.cpx2, f = e.cpy2, p = e.percent;
        0 !== p && (t[n](i, r), null == d || null == f ? (1 > p && (a(i, c, s, p, h), c = h[1], s = h[2], a(r, u, l, p, h), u = h[1], l = h[2]), t.quadraticCurveTo(c, u, s, l)) : (1 > p && (o(i, c, d, s, p, h), c = h[1], d = h[2], s = h[3], o(r, u, f, l, p, h), u = h[1], f = h[2], l = h[3]), t.bezierCurveTo(c, u, d, f, s, l)))
      },
      pointAt: function (t) {
        return e(this.shape, t, !1)
      },
      tangentAt: function (t) {
        var i = e(this.shape, t, !0);
        return r.normalize(i, i)
      }
    })
  }), e("zrender/graphic/CompoundPath", [Pe, "./Path"], function (t) {
    var e = t("./Path");
    return e[re]({
      type: "compound", shape: {paths: null}, _updatePathDirty: function () {
        for (var t = this.__dirtyPath, e = this.shape.paths, n = 0; n < e[ne]; n++)t = t || e[n].__dirtyPath;
        this.__dirtyPath = t, this[i] = this[i] || t
      }, beforeBrush: function () {
        this._updatePathDirty();
        for (var t = this.shape.paths || [], e = this.getGlobalScale(), i = 0; i < t[ne]; i++)t[i].path.setScale(e[0], e[1])
      }, buildPath: function (t, e) {
        for (var i = e.paths || [], n = 0; n < i[ne]; n++)i[n].buildPath(t, i[n].shape, !0)
      }, afterBrush: function () {
        for (var t = this.shape.paths, e = 0; e < t[ne]; e++)t[e].__dirtyPath = !1
      }, getBoundingRect: function () {
        return this._updatePathDirty(), e[xe][O].call(this)
      }
    })
  }), e("zrender/graphic/LinearGradient", [Pe, "../core/util", "./Gradient"], function (t) {
    var e = t("../core/util"), i = t("./Gradient"), n = function (t, e, n, r, a, o) {
      this.x = null == t ? 0 : t, this.y = null == e ? 0 : e, this.x2 = null == n ? 1 : n, this.y2 = null == r ? 0 : r, this.type = "linear", this.global = o || !1, i.call(this, a)
    };
    return n[xe] = {constructor: n}, e[F](n, i), n
  }), e("zrender/graphic/RadialGradient", [Pe, "../core/util", "./Gradient"], function (t) {
    var e = t("../core/util"), i = t("./Gradient"), n = function (t, e, n, r, a) {
      this.x = null == t ? .5 : t, this.y = null == e ? .5 : e, this.r = null == n ? .5 : n, this.type = "radial", this.global = a || !1, i.call(this, r)
    };
    return n[xe] = {constructor: n}, e[F](n, i), n
  }), e("zrender/core/BoundingRect", [Pe, "./vector", "./matrix"], function (t) {
    function e(t, e, i, n) {
      this.x = t, this.y = e, this.width = i, this[ce] = n
    }

    var i = t("./vector"), n = t("./matrix"), r = i[h], a = Math.min, o = Math.abs, s = Math.max;
    return e[xe] = {
      constructor: e, union: function (t) {
        var e = a(t.x, this.x), i = a(t.y, this.y);
        this.width = s(t.x + t.width, this.x + this.width) - e, this[ce] = s(t.y + t[ce], this.y + this[ce]) - i, this.x = e, this.y = i
      }, applyTransform: function () {
        var t = [], e = [];
        return function (i) {
          i && (t[0] = this.x, t[1] = this.y, e[0] = this.x + this.width, e[1] = this.y + this[ce], r(t, t, i), r(e, e, i), this.x = a(t[0], e[0]), this.y = a(t[1], e[1]), this.width = o(e[0] - t[0]), this[ce] = o(e[1] - t[1]))
        }
      }(), calculateTransform: function (t) {
        var e = this, i = t.width / e.width, r = t[ce] / e[ce], a = n[le]();
        return n.translate(a, a, [-e.x, -e.y]), n.scale(a, a, [i, r]), n.translate(a, a, [t.x, t.y]), a
      }, intersect: function (t) {
        var e = this, i = e.x, n = e.x + e.width, r = e.y, a = e.y + e[ce], o = t.x, s = t.x + t.width, l = t.y, c = t.y + t[ce];
        return !(o > n || i > s || l > a || r > c)
      }, contain: function (t, e) {
        var i = this;
        return t >= i.x && t <= i.x + i.width && e >= i.y && e <= i.y + i[ce]
      }, clone: function () {
        return new e(this.x, this.y, this.width, this[ce])
      }, copy: function (t) {
        this.x = t.x, this.y = t.y, this.width = t.width, this[ce] = t[ce]
      }
    }, e
  }), e("echarts/coord/cartesian/Axis2D", [Pe, Le, "../Axis", "./axisLabelInterval"], function (t) {
    var e = t(Le), i = t("../Axis"), n = t("./axisLabelInterval"), r = function (t, e, n, r, a) {
      i.call(this, t, e, n), this.type = r || "value", this[z] = a || ue
    };
    return r[xe] = {
      constructor: r, index: 0, onZero: !1, model: null, isHorizontal: function () {
        var t = this[z];
        return "top" === t || t === ue
      }, getGlobalExtent: function () {
        var t = this[L]();
        return t[0] = this.toGlobalCoord(t[0]), t[1] = this.toGlobalCoord(t[1]), t
      }, getLabelInterval: function () {
        var t = this._labelInterval;
        return t || (t = this._labelInterval = n(this)), t
      }, isLabelIgnored: function (t) {
        if (this.type === s) {
          var e = this.getLabelInterval();
          return typeof e === W && !e(t, this.scale.getLabel(t)) || t % (e + 1)
        }
      }, toLocalCoord: null, toGlobalCoord: null
    }, e[F](r, i), r
  }), e("echarts/coord/cartesian/Cartesian2D", [Pe, Le, "./Cartesian"], function (t) {
    function e(t) {
      n.call(this, t)
    }

    var i = t(Le), n = t("./Cartesian");
    return e[xe] = {
      constructor: e, type: "cartesian2d", dimensions: ["x", "y"], getBaseAxis: function () {
        return this.getAxesByScale(x)[0] || this.getAxesByScale("time")[0] || this.getAxis("x")
      }, containPoint: function (t) {
        var e = this.getAxis("x"), i = this.getAxis("y");
        return e[k](e.toLocalCoord(t[0])) && i[k](i.toLocalCoord(t[1]))
      }, containData: function (t) {
        return this.getAxis("x").containData(t[0]) && this.getAxis("y").containData(t[1])
      }, dataToPoints: function (t, e) {
        return t.mapArray(["x", "y"], function (t, e) {
          return this[M]([t, e])
        }, e, this)
      }, dataToPoint: function (t, e) {
        var i = this.getAxis("x"), n = this.getAxis("y");
        return [i.toGlobalCoord(i[b](t[0], e)), n.toGlobalCoord(n[b](t[1], e))]
      }, pointToData: function (t, e) {
        var i = this.getAxis("x"), n = this.getAxis("y");
        return [i.coordToData(i.toLocalCoord(t[0]), e), n.coordToData(n.toLocalCoord(t[1]), e)]
      }, getOtherAxis: function (t) {
        return this.getAxis("x" === t.dim ? "y" : "x")
      }
    }, i[F](e, n), e
  }), e("echarts/coord/axisHelper", [Pe, "../scale/Ordinal", "../scale/Interval", "../scale/Time", "../scale/Log", "../scale/Scale", "../util/number", Le, "zrender/contain/text"], function (t) {
    var e = t("../scale/Ordinal"), i = t("../scale/Interval");
    t("../scale/Time"), t("../scale/Log");
    var n = t("../scale/Scale"), r = t("../util/number"), a = t(Le), o = t("zrender/contain/text"), l = {};
    return l.getScaleExtent = function (t, e) {
      var i = t.scale, n = i[L](), o = n[1] - n[0];
      if (i.type === x)return isFinite(o) ? n : [0, 0];
      var s = e.getMin ? e.getMin() : e.get("min"), l = e.getMax ? e.getMax() : e.get("max"), c = e.getNeedCrossZero ? e.getNeedCrossZero() : !e.get("scale"), u = e.get("boundaryGap");
      a[Z](u) || (u = [u || 0, u || 0]), u[0] = r.parsePercent(u[0], 1), u[1] = r.parsePercent(u[1], 1);
      var h = !0, d = !0;
      return null == s && (s = n[0] - u[0] * o, h = !1), null == l && (l = n[1] + u[1] * o, d = !1), "dataMin" === s && (s = n[0]), "dataMax" === l && (l = n[1]), c && (s > 0 && l > 0 && !h && (s = 0), 0 > s && 0 > l && !d && (l = 0)), [s, l]
    }, l.niceScaleExtent = function (t, e) {
      var i = t.scale, n = l.getScaleExtent(t, e), r = null != (e.getMin ? e.getMin() : e.get("min")), a = null != (e.getMax ? e.getMax() : e.get("max")), o = e.get("splitNumber");
      i.setExtent(n[0], n[1]), i.niceExtent(o, r, a);
      var s = e.get("minInterval");
      if (isFinite(s) && !r && !a && "interval" === i.type) {
        var c = i.getInterval(), u = Math.max(Math.abs(c), s) / c;
        n = i[L](), i.setExtent(u * n[0], n[1] * u), i.niceExtent(o)
      }
      var c = e.get("interval");
      null != c && i.setInterval && i.setInterval(c)
    }, l.createScaleByModel = function (t, r) {
      if (r = r || t.get("type"))switch (r) {
        case s:
          return new e(t.getCategories(), [1 / 0, -1 / 0]);
        case"value":
          return new i;
        default:
          return (n.getClass(r) || i)[le](t)
      }
    }, l.ifAxisCrossZero = function (t) {
      var e = t.scale[L](), i = e[0], n = e[1];
      return !(i > 0 && n > 0 || 0 > i && 0 > n)
    }, l.getAxisLabelInterval = function (t, e, i, n) {
      var r, a = 0, s = 0, l = 1;
      e[ne] > 40 && (l = Math.floor(e[ne] / 40));
      for (var c = 0; c < t[ne]; c += l) {
        var u = t[c], h = o[O](e[c], i, D, "top");
        h[n ? "x" : "y"] += u, h[n ? "width" : ce] *= 1.3, r ? r.intersect(h) ? (s++, a = Math.max(a, s)) : (r.union(h), s = 0) : r = h.clone()
      }
      return 0 === a && l > 1 ? l : (a + 1) * l - 1
    }, l.getFormattedLabels = function (t, e) {
      var i = t.scale, n = i.getTicksLabels(), r = i[P]();
      return typeof e === ye ? (e = function (t) {
        return function (e) {
          return t[U]("{value}", e)
        }
      }(e), a.map(n, e)) : typeof e === W ? a.map(r, function (n, r) {
        return e(t.type === s ? i.getLabel(n) : n, r)
      }, this) : n
    }, l
  }), e("echarts/coord/cartesian/GridModel", [Pe, "./AxisModel", "../../model/Component"], function (t) {
    t("./AxisModel");
    var e = t("../../model/Component");
    return e[re]({
      type: "grid",
      dependencies: ["xAxis", "yAxis"],
      layoutMode: "box",
      coordinateSystem: null,
      defaultOption: {
        show: !1,
        zlevel: 0,
        z: 0,
        left: "10%",
        top: 60,
        right: "10%",
        bottom: 60,
        containLabel: !1,
        backgroundColor: "rgba(0,0,0,0)",
        borderWidth: 1,
        borderColor: "#ccc"
      }
    })
  }), e("echarts/model/globalDefault", [], function () {
    var t = "";
    return "undefined" != typeof navigator && (t = navigator.platform || ""), {
      color: ["#c23531", "#2f4554", "#61a0a8", "#d48265", "#91c7ae", "#749f83", "#ca8622", "#bda29a", "#6e7074", "#546570", "#c4ccd3"],
      grid: {},
      textStyle: {
        fontFamily: t.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
        fontSize: 12,
        fontStyle: "normal",
        fontWeight: "normal"
      },
      blendMode: null,
      animation: !0,
      animationDuration: 1e3,
      animationDurationUpdate: 300,
      animationEasing: "exponentialOut",
      animationEasingUpdate: "cubicOut",
      animationThreshold: 2e3,
      progressiveThreshold: 3e3,
      progressive: 400,
      hoverLayerThreshold: 3e3
    }
  }), e("zrender/contain/text", [Pe, "../core/util", "../core/BoundingRect"], function (t) {
    function e(t, e) {
      var i = t + ":" + e;
      if (o[i])return o[i];
      for (var n = (t + "").split("\n"), r = 0, a = 0, l = n[ne]; l > a; a++)r = Math.max(f.measureText(n[a], e).width, r);
      return s > c && (s = 0, o = {}), s++, o[i] = r, r
    }

    function i(t, i, n, r) {
      var a = ((t || "") + "").split("\n")[ne], o = e(t, i), s = e("", i), l = a * s, c = new h(0, 0, o, l);
      switch (c.lineHeight = s, r) {
        case ue:
        case"alphabetic":
          c.y -= s;
          break;
        case E:
          c.y -= s / 2
      }
      switch (n) {
        case"end":
        case"right":
          c.x -= c.width;
          break;
        case D:
          c.x -= c.width / 2
      }
      return c
    }

    function n(t, e, i, n) {
      var r = e.x, a = e.y, o = e[ce], s = e.width, c = i[ce], u = o / 2 - c / 2, h = "left";
      switch (t) {
        case"left":
          r -= n, a += u, h = "right";
          break;
        case"right":
          r += n + s, a += u, h = "left";
          break;
        case"top":
          r += s / 2, a -= n + c, h = D;
          break;
        case ue:
          r += s / 2, a += o + n, h = D;
          break;
        case l:
          r += s / 2, a += u, h = D;
          break;
        case"insideLeft":
          r += n, a += u, h = "left";
          break;
        case"insideRight":
          r += s - n, a += u, h = "right";
          break;
        case"insideTop":
          r += s / 2, a += n, h = D;
          break;
        case"insideBottom":
          r += s / 2, a += o - c - n, h = D;
          break;
        case"insideTopLeft":
          r += n, a += n, h = "left";
          break;
        case"insideTopRight":
          r += s - n, a += n, h = "right";
          break;
        case"insideBottomLeft":
          r += n, a += o - c - n;
          break;
        case"insideBottomRight":
          r += s - n, a += o - c - n, h = "right"
      }
      return {x: r, y: a, textAlign: h, textBaseline: "top"}
    }

    function r(t, i, n, r, o) {
      if (!i)return "";
      o = o || {}, r = d(r, "...");
      for (var s = d(o.maxIterations, 2), l = d(o.minChar, 0), c = e("", n), u = e("a", n), h = d(o.placeholder, ""), f = i = Math.max(0, i - 1), p = 0; l > p && f >= u; p++)f -= u;
      var v = e(r);
      v > f && (r = "", v = 0), f = i - v;
      for (var m = (t + "").split("\n"), p = 0, g = m[ne]; g > p; p++) {
        var y = m[p], x = e(y, n);
        if (!(i >= x)) {
          for (var _ = 0; ; _++) {
            if (f >= x || _ >= s) {
              y += r;
              break
            }
            var b = 0 === _ ? a(y, f, u, c) : x > 0 ? Math.floor(y[ne] * f / x) : 0;
            y = y.substr(0, b), x = e(y, n)
          }
          "" === y && (y = h), m[p] = y
        }
      }
      return m.join("\n")
    }

    function a(t, e, i, n) {
      for (var r = 0, a = 0, o = t[ne]; o > a && e > r; a++) {
        var s = t.charCodeAt(a);
        r += s >= 0 && 127 >= s ? i : n
      }
      return a
    }

    var o = {}, s = 0, c = 5e3, u = t("../core/util"), h = t("../core/BoundingRect"), d = u.retrieve, f = {
      getWidth: e,
      getBoundingRect: i,
      adjustTextPositionOnRect: n,
      truncateText: r,
      measureText: function (t, e) {
        var i = u.getContext();
        return i.font = e || "12px sans-serif", i.measureText(t)
      }
    };
    return f
  }), e("echarts/model/mixin/colorPalette", [], function () {
    return {
      clearColorPalette: function () {
        this._colorIdx = 0, this._colorNameMap = {}
      }, getColorFromPalette: function (t, e) {
        e = e || this;
        var i = e._colorIdx || 0, n = e._colorNameMap || (e._colorNameMap = {});
        if (n[t])return n[t];
        var r = this.get("color", !0) || [];
        if (r[ne]) {
          var a = r[i];
          return t && (n[t] = a), e._colorIdx = (i + 1) % r[ne], a
        }
      }
    }
  }), e("echarts/util/model", [Pe, "./format", "./number", "../model/Model", Le], function (t) {
    var e = t("./format"), i = t("./number"), n = t("../model/Model"), r = t(Le), a = ["x", "y", "z", T, "angle"], s = {};
    return s.createNameEach = function (t, e) {
      t = t.slice();
      var i = r.map(t, s.capitalFirst);
      e = (e || []).slice();
      var n = r.map(e, s.capitalFirst);
      return function (a, o) {
        r.each(t, function (t, r) {
          for (var s = {name: t, capital: i[r]}, l = 0; l < e[ne]; l++)s[e[l]] = t + n[l];
          a.call(o, s)
        })
      }
    }, s.capitalFirst = function (t) {
      return t ? t.charAt(0).toUpperCase() + t.substr(1) : t
    }, s.eachAxisDim = s.createNameEach(a, ["axisIndex", "axis", "index"]), s.normalizeToArray = function (t) {
      return t instanceof Array ? t : null == t ? [] : [t]
    }, s.createLinkedNodesFinder = function (t, e, i) {
      function n(t, e) {
        return r[V](e.nodes, t) >= 0
      }

      function a(t, n) {
        var a = !1;
        return e(function (e) {
          r.each(i(t, e) || [], function (t) {
            n.records[e.name][t] && (a = !0)
          })
        }), a
      }

      function o(t, n) {
        n.nodes.push(t), e(function (e) {
          r.each(i(t, e) || [], function (t) {
            n.records[e.name][t] = !0
          })
        })
      }

      return function (i) {
        function r(t) {
          !n(t, s) && a(t, s) && (o(t, s), l = !0)
        }

        var s = {nodes: [], records: {}};
        if (e(function (t) {
            s.records[t.name] = {}
          }), !i)return s;
        o(i, s);
        var l;
        do l = !1, t(r); while (l);
        return s
      }
    }, s.defaultEmphasis = function (t, e) {
      if (t) {
        var i = t.emphasis = t.emphasis || {}, n = t[f] = t[f] || {};
        r.each(e, function (t) {
          var e = r.retrieve(i[t], n[t]);
          null != e && (i[t] = e)
        })
      }
    }, s.LABEL_OPTIONS = [z, "show", G, "distance", "formatter"], s.getDataItemValue = function (t) {
      return t && (null == t.value ? t : t.value)
    }, s.isDataItemOption = function (t) {
      return r[oe](t) && !(t instanceof Array)
    }, s.converDataValue = function (t, e) {
      var n = e && e.type;
      return n === x ? t : ("time" !== n || isFinite(t) || null == t || "-" === t || (t = +i.parseDate(t)), null == t || "" === t ? 0 / 0 : +t)
    }, s.createDataFormatModel = function (t, e) {
      var i = new n;
      return r.mixin(i, s.dataFormatMixin), i[$] = e[$], i.name = e.name || "", i.mainType = e.mainType, i.subType = e.subType, i[we] = function () {
        return t
      }, i
    }, s.dataFormatMixin = {
      getDataParams: function (t, e) {
        var i = this[we](e), n = this[$], r = this.name, a = this.getRawValue(t, e), o = i.getRawIndex(t), s = i[d](t, !0), l = i.getRawDataItem(t);
        return {
          componentType: this.mainType,
          componentSubType: this.subType,
          seriesType: this.mainType === ie ? this.subType : null,
          seriesIndex: n,
          seriesName: r,
          name: s,
          dataIndex: o,
          data: l,
          dataType: e,
          value: a,
          color: i[w](t, "color"),
          $vars: ["seriesName", "name", "value"]
        }
      }, getFormattedLabel: function (t, i, n, r) {
        i = i || f;
        var a = this[we](n), o = a[m](t), s = this[Y](t, n);
        null != r && s.value instanceof Array && (s.value = s.value[r]);
        var l = o.get(["label", i, "formatter"]);
        return typeof l === W ? (s.status = i, l(s)) : typeof l === ye ? e.formatTpl(l, s) : void 0
      }, getRawValue: function (t, e) {
        var i = this[we](e), n = i.getRawDataItem(t);
        return null != n ? !r[oe](n) || n instanceof Array ? n : n.value : void 0
      }, formatTooltip: r.noop
    }, s.mappingToExists = function (t, e) {
      e = (e || []).slice();
      var i = r.map(t || [], function (t) {
        return {exist: t}
      });
      return r.each(e, function (t, n) {
        if (r[oe](t))for (var a = 0; a < i[ne]; a++) {
          var l = i[a].exist;
          if (!i[a][o] && (null != t.id && l.id === t.id + "" || null != t.name && !s.isIdInner(t) && !s.isIdInner(l) && l.name === t.name + "")) {
            i[a][o] = t, e[n] = null;
            break
          }
        }
      }), r.each(e, function (t) {
        if (r[oe](t)) {
          for (var e = 0; e < i[ne]; e++) {
            var n = i[e].exist;
            if (!i[e][o] && !s.isIdInner(n) && null == t.id) {
              i[e][o] = t;
              break
            }
          }
          e >= i[ne] && i.push({option: t})
        }
      }), i
    }, s.isIdInner = function (t) {
      return r[oe](t) && t.id && 0 === (t.id + "")[V]("\x00_ec_\x00")
    }, s.compressBatches = function (t, e) {
      function i(t, e, i) {
        for (var n = 0, r = t[ne]; r > n; n++)for (var a = t[n].seriesId, o = s.normalizeToArray(t[n][Q]), l = i && i[a], c = 0, u = o[ne]; u > c; c++) {
          var h = o[c];
          l && l[h] ? l[h] = null : (e[a] || (e[a] = {}))[h] = 1
        }
      }

      function n(t, e) {
        var i = [];
        for (var r in t)if (t.hasOwnProperty(r) && null != t[r])if (e)i.push(+r); else {
          var a = n(t[r], !0);
          a[ne] && i.push({seriesId: r, dataIndex: a})
        }
        return i
      }

      var r = {}, a = {};
      return i(t || [], r), i(e || [], a, r), [n(r), n(a)]
    }, s
  }), e("echarts/util/clazz", [Pe, Le], function (t) {
    function e(t, e) {
      var i = n.slice(arguments, 2);
      return this.superClass[xe][e].apply(t, i)
    }

    function i(t, e, i) {
      return this.superClass[xe][e].apply(t, i)
    }

    var n = t(Le), r = {}, a = ".", o = "___EC__COMPONENT__CONTAINER___", s = r.parseClassType = function (t) {
      var e = {main: "", sub: ""};
      return t && (t = t.split(a), e.main = t[0] || "", e.sub = t[1] || ""), e
    };
    return r.enableClassExtend = function (t) {
      t.$constructor = t, t[re] = function (t) {
        var r = this, a = function () {
          t.$constructor ? t.$constructor.apply(this, arguments) : r.apply(this, arguments)
        };
        return n[re](a[xe], t), a[re] = this[re], a.superCall = e, a.superApply = i, n[F](a, this), a.superClass = r, a
      }
    }, r.enableClassManagement = function (t, e) {
      function i(t) {
        var e = r[t.main];
        return e && e[o] || (e = r[t.main] = {}, e[o] = !0), e
      }

      e = e || {};
      var r = {};
      if (t.registerClass = function (t, e) {
          if (e)if (e = s(e), e.sub) {
            if (e.sub !== o) {
              var n = i(e);
              n[e.sub] = t
            }
          } else r[e.main] = t;
          return t
        }, t.getClass = function (t, e, i) {
          var n = r[t];
          if (n && n[o] && (n = e ? n[e] : null), i && !n)throw new Error("Component " + t + "." + (e || "") + " not exists. Load it first.");
          return n
        }, t.getClassesByMainType = function (t) {
          t = s(t);
          var e = [], i = r[t.main];
          return i && i[o] ? n.each(i, function (t, i) {
            i !== o && e.push(t)
          }) : e.push(i), e
        }, t.hasClass = function (t) {
          return t = s(t), !!r[t.main]
        }, t.getAllClassMainTypes = function () {
          var t = [];
          return n.each(r, function (e, i) {
            t.push(i)
          }), t
        }, t.hasSubTypes = function (t) {
          t = s(t);
          var e = r[t.main];
          return e && e[o]
        }, t.parseClassType = s, e.registerWhenExtend) {
        var a = t[re];
        a && (t[re] = function (e) {
          var i = a.call(this, e);
          return t.registerClass(i, e.type)
        })
      }
      return t
    }, r.setReadOnly = function () {
    }, r
  }), e("echarts/model/mixin/textStyle", [Pe, "zrender/contain/text"], function (t) {
    function e(t, e) {
      return t && t[v](e)
    }

    var i = t("zrender/contain/text");
    return {
      getTextColor: function () {
        var t = this[a];
        return this[v]("color") || t && t.get("textStyle.color")
      }, getFont: function () {
        var t = this[a], i = t && t[me](G);
        return [this[v]("fontStyle") || e(i, "fontStyle"), this[v]("fontWeight") || e(i, "fontWeight"), (this[v]("fontSize") || e(i, "fontSize") || 12) + "px", this[v]("fontFamily") || e(i, "fontFamily") || "sans-serif"].join(" ")
      }, getTextRect: function (t) {
        var e = this.get(G) || {};
        return i[O](t, this[B](), e.align, e.baseline)
      }, truncateText: function (t, e, n, r) {
        return i.truncateText(t, e, this[B](), n, r)
      }
    }
  }), e("echarts/model/mixin/lineStyle", [Pe, "./makeStyleMapper"], function (t) {
    var e = t("./makeStyleMapper")([[u, "width"], [c, "color"], [I], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]);
    return {
      getLineStyle: function (t) {
        var i = e.call(this, t), n = this.getLineDash();
        return n && (i.lineDash = n), i
      }, getLineDash: function () {
        var t = this.get("type");
        return "solid" === t || null == t ? null : "dashed" === t ? [5, 5] : [1, 1]
      }
    }
  }), e("echarts/model/mixin/itemStyle", [Pe, "./makeStyleMapper"], function (t) {
    var e = t("./makeStyleMapper")([["fill", "color"], [c, "borderColor"], [u, "borderWidth"], [I], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]);
    return {
      getItemStyle: function (t) {
        var i = e.call(this, t), n = this.getBorderLineDash();
        return n && (i.lineDash = n), i
      }, getBorderLineDash: function () {
        var t = this.get("borderType");
        return "solid" === t || null == t ? null : "dashed" === t ? [5, 5] : [1, 1]
      }
    }
  }), e("echarts/model/mixin/areaStyle", [Pe, "./makeStyleMapper"], function (t) {
    return {getAreaStyle: t("./makeStyleMapper")([["fill", "color"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], [I], ["shadowColor"]])}
  }), e("zrender/core/PathProxy", [Pe, "./curve", "./vector", "./bbox", "./BoundingRect", "../config"], function (t) {
    var e = t("./curve"), i = t("./vector"), r = t("./bbox"), a = t("./BoundingRect"), o = t("../config").devicePixelRatio, s = {
      M: 1,
      L: 2,
      C: 3,
      Q: 4,
      A: 5,
      Z: 6,
      R: 7
    }, l = [], u = [], h = [], d = [], f = Math.min, p = Math.max, v = Math.cos, m = Math.sin, g = Math.sqrt, y = Math.abs, x = "undefined" != typeof Float32Array, _ = function () {
      this.data = [], this._len = 0, this._ctx = null, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0, this._ux = 0, this._uy = 0
    };
    return _[xe] = {
      constructor: _,
      _lineDash: null,
      _dashOffset: 0,
      _dashIdx: 0,
      _dashSum: 0,
      setScale: function (t, e) {
        this._ux = y(1 / o / t) || 0, this._uy = y(1 / o / e) || 0
      },
      getContext: function () {
        return this._ctx
      },
      beginPath: function (t) {
        return this._ctx = t, t && t.beginPath(), this._len = 0, this._lineDash && (this._lineDash = null, this._dashOffset = 0), this
      },
      moveTo: function (t, e) {
        return this.addData(s.M, t, e), this._ctx && this._ctx[n](t, e), this._x0 = t, this._y0 = e, this._xi = t, this._yi = e, this
      },
      lineTo: function (t, e) {
        var i = y(t - this._xi) > this._ux || y(e - this._yi) > this._uy || this._len < 5;
        return this.addData(s.L, t, e), this._ctx && i && (this._needsDash() ? this._dashedLineTo(t, e) : this._ctx.lineTo(t, e)), i && (this._xi = t, this._yi = e), this
      },
      bezierCurveTo: function (t, e, i, n, r, a) {
        return this.addData(s.C, t, e, i, n, r, a), this._ctx && (this._needsDash() ? this._dashedBezierTo(t, e, i, n, r, a) : this._ctx.bezierCurveTo(t, e, i, n, r, a)), this._xi = r, this._yi = a, this
      },
      quadraticCurveTo: function (t, e, i, n) {
        return this.addData(s.Q, t, e, i, n), this._ctx && (this._needsDash() ? this._dashedQuadraticTo(t, e, i, n) : this._ctx.quadraticCurveTo(t, e, i, n)), this._xi = i, this._yi = n, this
      },
      arc: function (t, e, i, n, r, a) {
        return this.addData(s.A, t, e, i, i, n, r - n, 0, a ? 0 : 1), this._ctx && this._ctx.arc(t, e, i, n, r, a), this._xi = v(r) * i + t, this._xi = m(r) * i + t, this
      },
      arcTo: function (t, e, i, n, r) {
        return this._ctx && this._ctx.arcTo(t, e, i, n, r), this
      },
      rect: function (t, e, i, n) {
        return this._ctx && this._ctx.rect(t, e, i, n), this.addData(s.R, t, e, i, n), this
      },
      closePath: function () {
        this.addData(s.Z);
        var t = this._ctx, e = this._x0, i = this._y0;
        return t && (this._needsDash() && this._dashedLineTo(e, i), t.closePath()), this._xi = e, this._yi = i, this
      },
      fill: function (t) {
        t && t.fill(), this.toStatic()
      },
      stroke: function (t) {
        t && t[c](), this.toStatic()
      },
      setLineDash: function (t) {
        if (t instanceof Array) {
          this._lineDash = t, this._dashIdx = 0;
          for (var e = 0, i = 0; i < t[ne]; i++)e += t[i];
          this._dashSum = e
        }
        return this
      },
      setLineDashOffset: function (t) {
        return this._dashOffset = t, this
      },
      len: function () {
        return this._len
      },
      setData: function (t) {
        var e = t[ne];
        this.data && this.data[ne] == e || !x || (this.data = new Float32Array(e));
        for (var i = 0; e > i; i++)this.data[i] = t[i];
        this._len = e
      },
      appendPath: function (t) {
        t instanceof Array || (t = [t]);
        for (var e = t[ne], i = 0, n = this._len, r = 0; e > r; r++)i += t[r].len();
        x && this.data instanceof Float32Array && (this.data = new Float32Array(n + i));
        for (var r = 0; e > r; r++)for (var a = t[r].data, o = 0; o < a[ne]; o++)this.data[n++] = a[o];
        this._len = n
      },
      addData: function (t) {
        var e = this.data;
        this._len + arguments[ne] > e[ne] && (this._expandData(), e = this.data);
        for (var i = 0; i < arguments[ne]; i++)e[this._len++] = arguments[i];
        this._prevCmd = t
      },
      _expandData: function () {
        if (!(this.data instanceof Array)) {
          for (var t = [], e = 0; e < this._len; e++)t[e] = this.data[e];
          this.data = t
        }
      },
      _needsDash: function () {
        return this._lineDash
      },
      _dashedLineTo: function (t, e) {
        var i, r, a = this._dashSum, o = this._dashOffset, s = this._lineDash, l = this._ctx, c = this._xi, u = this._yi, h = t - c, d = e - u, v = g(h * h + d * d), m = c, y = u, x = s[ne];
        for (h /= v, d /= v, 0 > o && (o = a + o), o %= a, m -= o * h, y -= o * d; h > 0 && t >= m || 0 > h && m >= t || 0 == h && (d > 0 && e >= y || 0 > d && y >= e);)r = this._dashIdx, i = s[r], m += h * i, y += d * i, this._dashIdx = (r + 1) % x, h > 0 && c > m || 0 > h && m > c || d > 0 && u > y || 0 > d && y > u || l[r % 2 ? n : "lineTo"](h >= 0 ? f(m, t) : p(m, t), d >= 0 ? f(y, e) : p(y, e));
        h = m - t, d = y - e, this._dashOffset = -g(h * h + d * d)
      },
      _dashedBezierTo: function (t, i, r, a, o, s) {
        var l, c, u, h, d, f = this._dashSum, p = this._dashOffset, v = this._lineDash, m = this._ctx, y = this._xi, x = this._yi, _ = e.cubicAt, b = 0, w = this._dashIdx, S = v[ne], M = 0;
        for (0 > p && (p = f + p), p %= f, l = 0; 1 > l; l += .1)c = _(y, t, r, o, l + .1) - _(y, t, r, o, l), u = _(x, i, a, s, l + .1) - _(x, i, a, s, l), b += g(c * c + u * u);
        for (; S > w && (M += v[w], !(M > p)); w++);
        for (l = (M - p) / b; 1 >= l;)h = _(y, t, r, o, l), d = _(x, i, a, s, l), w % 2 ? m[n](h, d) : m.lineTo(h, d), l += v[w] / b, w = (w + 1) % S;
        w % 2 !== 0 && m.lineTo(o, s), c = o - h, u = s - d, this._dashOffset = -g(c * c + u * u)
      },
      _dashedQuadraticTo: function (t, e, i, n) {
        var r = i, a = n;
        i = (i + 2 * t) / 3, n = (n + 2 * e) / 3, t = (this._xi + 2 * t) / 3, e = (this._yi + 2 * e) / 3, this._dashedBezierTo(t, e, i, n, r, a)
      },
      toStatic: function () {
        var t = this.data;
        t instanceof Array && (t[ne] = this._len, x && (this.data = new Float32Array(t)))
      },
      getBoundingRect: function () {
        l[0] = l[1] = h[0] = h[1] = Number.MAX_VALUE, u[0] = u[1] = d[0] = d[1] = -Number.MAX_VALUE;
        for (var t = this.data, e = 0, n = 0, o = 0, c = 0, f = 0; f < t[ne];) {
          var p = t[f++];
          switch (1 == f && (e = t[f], n = t[f + 1], o = e, c = n), p) {
            case s.M:
              o = t[f++], c = t[f++], e = o, n = c, h[0] = o, h[1] = c, d[0] = o, d[1] = c;
              break;
            case s.L:
              r.fromLine(e, n, t[f], t[f + 1], h, d), e = t[f++], n = t[f++];
              break;
            case s.C:
              r.fromCubic(e, n, t[f++], t[f++], t[f++], t[f++], t[f], t[f + 1], h, d), e = t[f++], n = t[f++];
              break;
            case s.Q:
              r.fromQuadratic(e, n, t[f++], t[f++], t[f], t[f + 1], h, d), e = t[f++], n = t[f++];
              break;
            case s.A:
              var g = t[f++], y = t[f++], x = t[f++], _ = t[f++], b = t[f++], w = t[f++] + b, S = (t[f++], 1 - t[f++]);
              1 == f && (o = v(b) * x + g, c = m(b) * _ + y), r.fromArc(g, y, x, _, b, w, S, h, d), e = v(w) * x + g, n = m(w) * _ + y;
              break;
            case s.R:
              o = e = t[f++], c = n = t[f++];
              var M = t[f++], T = t[f++];
              r.fromLine(o, c, o + M, c + T, h, d);
              break;
            case s.Z:
              e = o, n = c
          }
          i.min(l, l, h), i.max(u, u, d)
        }
        return 0 === f && (l[0] = l[1] = u[0] = u[1] = 0), new a(l[0], l[1], u[0] - l[0], u[1] - l[1])
      },
      rebuildPath: function (t) {
        for (var e, i, r, a, o, l, c = this.data, u = this._ux, h = this._uy, d = this._len, f = 0; d > f;) {
          var p = c[f++];
          switch (1 == f && (r = c[f], a = c[f + 1], e = r, i = a), p) {
            case s.M:
              e = r = c[f++], i = a = c[f++], t[n](r, a);
              break;
            case s.L:
              o = c[f++], l = c[f++], (y(o - r) > u || y(l - a) > h || f === d - 1) && (t.lineTo(o, l), r = o, a = l);
              break;
            case s.C:
              t.bezierCurveTo(c[f++], c[f++], c[f++], c[f++], c[f++], c[f++]), r = c[f - 2], a = c[f - 1];
              break;
            case s.Q:
              t.quadraticCurveTo(c[f++], c[f++], c[f++], c[f++]), r = c[f - 2], a = c[f - 1];
              break;
            case s.A:
              var g = c[f++], x = c[f++], _ = c[f++], b = c[f++], w = c[f++], S = c[f++], M = c[f++], T = c[f++], C = _ > b ? _ : b, A = _ > b ? 1 : _ / b, L = _ > b ? b / _ : 1, P = Math.abs(_ - b) > .001, k = w + S;
              P ? (t.translate(g, x), t.rotate(M), t.scale(A, L), t.arc(0, 0, C, w, k, 1 - T), t.scale(1 / A, 1 / L), t.rotate(-M), t.translate(-g, -x)) : t.arc(g, x, C, w, k, 1 - T), 1 == f && (e = v(w) * _ + g, i = m(w) * b + x), r = v(k) * _ + g, a = m(k) * b + x;
              break;
            case s.R:
              e = r = c[f], i = a = c[f + 1], t.rect(c[f++], c[f++], c[f++], c[f++]);
              break;
            case s.Z:
              t.closePath(), r = e, a = i
          }
        }
      }
    }, _.CMD = s, _
  }),e("zrender/graphic/mixin/RectText", [Pe, "../../contain/text", "../../core/BoundingRect"], function (t) {
    function e(t, e) {
      return typeof t === ye ? t.lastIndexOf("%") >= 0 ? parseFloat(t) / 100 * e : parseFloat(t) : t
    }

    var i = t("../../contain/text"), n = t("../../core/BoundingRect"), a = new n, o = function () {
    };
    return o[xe] = {
      constructor: o, drawRectText: function (t, n, o) {
        var s = this.style, l = s.text;
        if (null != l && (l += ""), l) {
          t.save();
          var c, u, d = s.textPosition, f = s.textDistance, p = s[N], v = s.textFont || s.font, m = s.textBaseline, g = s.textVerticalAlign;
          o = o || i[O](l, v, p, m);
          var y = this[r];
          if (y && (a.copy(n), a[h](y), n = a), d instanceof Array) {
            if (c = n.x + e(d[0], n.width), u = n.y + e(d[1], n[ce]), p = p || "left", m = m || "top", g) {
              switch (g) {
                case E:
                  u -= o[ce] / 2 - o.lineHeight / 2;
                  break;
                case ue:
                  u -= o[ce] - o.lineHeight / 2;
                  break;
                default:
                  u += o.lineHeight / 2
              }
              m = E
            }
          } else {
            var x = i.adjustTextPositionOnRect(d, n, o, f);
            c = x.x, u = x.y, p = p || x[N], m = m || x.textBaseline
          }
          t[N] = p || "left", t.textBaseline = m || "alphabetic";
          var _ = s.textFill, b = s.textStroke;
          _ && (t.fillStyle = _), b && (t.strokeStyle = b), t.font = v, t.shadowBlur = s.textShadowBlur, t.shadowColor = s.textShadowColor || "transparent", t.shadowOffsetX = s.textShadowOffsetX, t.shadowOffsetY = s.textShadowOffsetY;
          for (var w = l.split("\n"), S = 0; S < w[ne]; S++)_ && t.fillText(w[S], c, u), b && t.strokeText(w[S], c, u), u += o.lineHeight;
          t.restore()
        }
      }
    }, o
  }),e("zrender/graphic/Displayable", [Pe, "../core/util", "./Style", "../Element", "./mixin/RectText"], function (t) {
    function e(t) {
      t = t || {}, a.call(this, t);
      for (var e in t)t.hasOwnProperty(e) && "style" !== e && (this[e] = t[e]);
      this.style = new r(t.style), this._rect = null, this.__clipPaths = []
    }

    var n = t("../core/util"), r = t("./Style"), a = t("../Element"), o = t("./mixin/RectText");
    return e[xe] = {
      constructor: e,
      type: "displayable",
      __dirty: !0,
      invisible: !1,
      z: 0,
      z2: 0,
      zlevel: 0,
      draggable: !1,
      dragging: !1,
      silent: !1,
      culling: !1,
      cursor: "pointer",
      rectHover: !1,
      progressive: -1,
      beforeBrush: function () {
      },
      afterBrush: function () {
      },
      brush: function () {
      },
      getBoundingRect: function () {
      },
      contain: function (t, e) {
        return this.rectContain(t, e)
      },
      traverse: function (t, e) {
        t.call(e, this)
      },
      rectContain: function (t, e) {
        var i = this.transformCoordToLocal(t, e), n = this[O]();
        return n[k](i[0], i[1])
      },
      dirty: function () {
        this[i] = !0, this._rect = null, this.__zr && this.__zr.refresh()
      },
      animateStyle: function (t) {
        return this.animate("style", t)
      },
      attrKV: function (t, e) {
        "style" !== t ? a[xe].attrKV.call(this, t, e) : this.style.set(e)
      },
      setStyle: function (t, e) {
        return this.style.set(t, e), this.dirty(!1), this
      },
      useStyle: function (t) {
        return this.style = new r(t), this.dirty(!1), this
      }
    }, n[F](e, a), n.mixin(e, o), e
  }),e("zrender/vml/core", [Pe, "exports", "module", "../core/env"], function (t, e, i) {
    if (!t("../core/env")[fe]) {
      var n, r = "urn:schemas-microsoft-com:vml", a = window, o = a.document, s = !1;
      try {
        !o.namespaces.zrvml && o.namespaces.add("zrvml", r), n = function (t) {
          return o[y]("<zrvml:" + t + ' class="zrvml">')
        }
      } catch (l) {
        n = function (t) {
          return o[y]("<" + t + ' xmlns="' + r + '" class="zrvml">')
        }
      }
      var c = function () {
        if (!s) {
          s = !0;
          var t = o.styleSheets;
          t[ne] < 31 ? o.createStyleSheet().addRule(".zrvml", "behavior:url(#default#VML)") : t[0].addRule(".zrvml", "behavior:url(#default#VML)")
        }
      };
      i.exports = {doc: o, initVML: c, createNode: n}
    }
  }),e("zrender/graphic/Pattern", [Pe], function () {
    var t = function (t, e) {
      this.image = t, this.repeat = e, this.type = "pattern"
    };
    return t[xe].getCanvasPattern = function (t) {
      return this._canvasPattern || (this._canvasPattern = t.createPattern(this.image, this.repeat))
    }, t
  }),e("zrender/contain/path", [Pe, "../core/PathProxy", "./line", "./cubic", "./quadratic", "./arc", "./util", "../core/curve", "./windingLine"], function (t) {
    function e(t, e) {
      return Math.abs(t - e) < g
    }

    function i() {
      var t = x[0];
      x[0] = x[1], x[1] = t
    }

    function n(t, e, n, r, a, o, s, l, c, u) {
      if (u > e && u > r && u > o && u > l || e > u && r > u && o > u && l > u)return 0;
      var h = f.cubicRootAt(e, r, o, l, u, y);
      if (0 === h)return 0;
      for (var d, p, v = 0, m = -1, g = 0; h > g; g++) {
        var _ = y[g], b = 0 === _ || 1 === _ ? .5 : 1, w = f.cubicAt(t, n, a, s, _);
        c > w || (0 > m && (m = f.cubicExtrema(e, r, o, l, x), x[1] < x[0] && m > 1 && i(), d = f.cubicAt(e, r, o, l, x[0]), m > 1 && (p = f.cubicAt(e, r, o, l, x[1]))), v += 2 == m ? _ < x[0] ? e > d ? b : -b : _ < x[1] ? d > p ? b : -b : p > l ? b : -b : _ < x[0] ? e > d ? b : -b : d > l ? b : -b)
      }
      return v
    }

    function r(t, e, i, n, r, a, o, s) {
      if (s > e && s > n && s > a || e > s && n > s && a > s)return 0;
      var l = f.quadraticRootAt(e, n, a, s, y);
      if (0 === l)return 0;
      var c = f.quadraticExtremum(e, n, a);
      if (c >= 0 && 1 >= c) {
        for (var u = 0, h = f.quadraticAt(e, n, a, c), d = 0; l > d; d++) {
          var p = 0 === y[d] || 1 === y[d] ? .5 : 1, v = f.quadraticAt(t, i, r, y[d]);
          o > v || (u += y[d] < c ? e > h ? p : -p : h > a ? p : -p)
        }
        return u
      }
      var p = 0 === y[0] || 1 === y[0] ? .5 : 1, v = f.quadraticAt(t, i, r, y[0]);
      return o > v ? 0 : e > a ? p : -p
    }

    function a(t, e, i, n, r, a, o, s) {
      if (s -= e, s > i || -i > s)return 0;
      var l = Math.sqrt(i * i - s * s);
      y[0] = -l, y[1] = l;
      var c = Math.abs(n - r);
      if (1e-4 > c)return 0;
      if (1e-4 > c % m) {
        n = 0, r = m;
        var u = a ? 1 : -1;
        return o >= y[0] + t && o <= y[1] + t ? u : 0
      }
      if (a) {
        var l = n;
        n = d(r), r = d(l)
      } else n = d(n), r = d(r);
      n > r && (r += m);
      for (var h = 0, f = 0; 2 > f; f++) {
        var p = y[f];
        if (p + t > o) {
          var v = Math.atan2(s, p), u = a ? 1 : -1;
          0 > v && (v = m + v), (v >= n && r >= v || v + m >= n && r >= v + m) && (v > Math.PI / 2 && v < 1.5 * Math.PI && (u = -u), h += u)
        }
      }
      return h
    }

    function o(t, i, o, l, d) {
      for (var f = 0, m = 0, g = 0, y = 0, x = 0, _ = 0; _ < t[ne];) {
        var b = t[_++];
        switch (b === s.M && _ > 1 && (o || (f += p(m, g, y, x, l, d))), 1 == _ && (m = t[_], g = t[_ + 1], y = m, x = g), b) {
          case s.M:
            y = t[_++], x = t[_++], m = y, g = x;
            break;
          case s.L:
            if (o) {
              if (v(m, g, t[_], t[_ + 1], i, l, d))return !0
            } else f += p(m, g, t[_], t[_ + 1], l, d) || 0;
            m = t[_++], g = t[_++];
            break;
          case s.C:
            if (o) {
              if (c.containStroke(m, g, t[_++], t[_++], t[_++], t[_++], t[_], t[_ + 1], i, l, d))return !0
            } else f += n(m, g, t[_++], t[_++], t[_++], t[_++], t[_], t[_ + 1], l, d) || 0;
            m = t[_++], g = t[_++];
            break;
          case s.Q:
            if (o) {
              if (u.containStroke(m, g, t[_++], t[_++], t[_], t[_ + 1], i, l, d))return !0
            } else f += r(m, g, t[_++], t[_++], t[_], t[_ + 1], l, d) || 0;
            m = t[_++], g = t[_++];
            break;
          case s.A:
            var w = t[_++], S = t[_++], M = t[_++], T = t[_++], C = t[_++], A = t[_++], L = (t[_++], 1 - t[_++]), P = Math.cos(C) * M + w, k = Math.sin(C) * T + S;
            _ > 1 ? f += p(m, g, P, k, l, d) : (y = P, x = k);
            var I = (l - w) * T / M + w;
            if (o) {
              if (h.containStroke(w, S, T, C, C + A, L, i, I, d))return !0
            } else f += a(w, S, T, C, C + A, L, I, d);
            m = Math.cos(C + A) * M + w, g = Math.sin(C + A) * T + S;
            break;
          case s.R:
            y = m = t[_++], x = g = t[_++];
            var z = t[_++], D = t[_++], P = y + z, k = x + D;
            if (o) {
              if (v(y, x, P, x, i, l, d) || v(P, x, P, k, i, l, d) || v(P, k, y, k, i, l, d) || v(y, k, y, x, i, l, d))return !0
            } else f += p(P, x, P, k, l, d), f += p(y, k, y, x, l, d);
            break;
          case s.Z:
            if (o) {
              if (v(m, g, y, x, i, l, d))return !0
            } else f += p(m, g, y, x, l, d);
            m = y, g = x
        }
      }
      return o || e(g, x) || (f += p(m, g, y, x, l, d) || 0), 0 !== f
    }

    var s = t("../core/PathProxy").CMD, l = t("./line"), c = t("./cubic"), u = t("./quadratic"), h = t("./arc"), d = t("./util").normalizeRadian, f = t("../core/curve"), p = t("./windingLine"), v = l.containStroke, m = 2 * Math.PI, g = 1e-4, y = [-1, -1, -1], x = [-1, -1];
    return {
      contain: function (t, e, i) {
        return o(t, 0, !1, e, i)
      }, containStroke: function (t, e, i, n) {
        return o(t, e, !0, i, n)
      }
    }
  }),e("zrender/tool/transformPath", [Pe, "../core/PathProxy", "../core/vector"], function (t) {
    function e(t, e) {
      var n, l, c, u, h, d, f = t.data, p = i.M, v = i.C, m = i.L, g = i.R, y = i.A, x = i.Q;
      for (c = 0, u = 0; c < f[ne];) {
        switch (n = f[c++], u = c, l = 0, n) {
          case p:
            l = 1;
            break;
          case m:
            l = 1;
            break;
          case v:
            l = 3;
            break;
          case x:
            l = 2;
            break;
          case y:
            var _ = e[4], b = e[5], w = o(e[0] * e[0] + e[1] * e[1]), S = o(e[2] * e[2] + e[3] * e[3]), M = s(-e[1] / S, e[0] / w);
            f[c++] += _, f[c++] += b, f[c++] *= w, f[c++] *= S, f[c++] += M, f[c++] += M, c += 2, u = c;
            break;
          case g:
            d[0] = f[c++], d[1] = f[c++], r(d, d, e), f[u++] = d[0], f[u++] = d[1], d[0] += f[c++], d[1] += f[c++], r(d, d, e), f[u++] = d[0], f[u++] = d[1]
        }
        for (h = 0; l > h; h++) {
          var d = a[h];
          d[0] = f[c++], d[1] = f[c++], r(d, d, e), f[u++] = d[0], f[u++] = d[1]
        }
      }
    }

    var i = t("../core/PathProxy").CMD, n = t("../core/vector"), r = n[h], a = [[], [], []], o = Math.sqrt, s = Math.atan2;
    return e
  }),e("echarts/scale/Ordinal", [Pe, Le, "./Scale"], function (t) {
    var e = t(Le), i = t("./Scale"), n = i[xe], r = i[re]({
      type: "ordinal", init: function (t, e) {
        this._data = t, this._extent = e || [0, t[ne] - 1]
      }, parse: function (t) {
        return typeof t === ye ? e[V](this._data, t) : Math.round(t)
      }, contain: function (t) {
        return t = this.parse(t), n[k].call(this, t) && null != this._data[t]
      }, normalize: function (t) {
        return n.normalize.call(this, this.parse(t))
      }, scale: function (t) {
        return Math.round(n.scale.call(this, t))
      }, getTicks: function () {
        for (var t = [], e = this._extent, i = e[0]; i <= e[1];)t.push(i), i++;
        return t
      }, getLabel: function (t) {
        return this._data[t]
      }, count: function () {
        return this._extent[1] - this._extent[0] + 1
      }, niceTicks: e.noop, niceExtent: e.noop
    });
    return r[le] = function () {
      return new r
    }, r
  }),e("echarts/model/mixin/makeStyleMapper", [Pe, Le], function (t) {
    var e = t(Le);
    return function (t) {
      for (var i = 0; i < t[ne]; i++)t[i][1] || (t[i][1] = t[i][0]);
      return function (i) {
        for (var n = {}, r = 0; r < t[ne]; r++) {
          var a = t[r][1];
          if (!(i && e[V](i, a) >= 0)) {
            var o = this[v](a);
            null != o && (n[t[r][0]] = o)
          }
        }
        return n
      }
    }
  }),e("zrender/core/bbox", [Pe, "./vector", "./curve"], function (t) {
    var e = t("./vector"), i = t("./curve"), n = {}, r = Math.min, a = Math.max, o = Math.sin, s = Math.cos, l = e[le](), c = e[le](), u = e[le](), h = 2 * Math.PI;
    n.fromPoints = function (t, e, i) {
      if (0 !== t[ne]) {
        var n, o = t[0], s = o[0], l = o[0], c = o[1], u = o[1];
        for (n = 1; n < t[ne]; n++)o = t[n], s = r(s, o[0]), l = a(l, o[0]), c = r(c, o[1]), u = a(u, o[1]);
        e[0] = s, e[1] = c, i[0] = l, i[1] = u
      }
    }, n.fromLine = function (t, e, i, n, o, s) {
      o[0] = r(t, i), o[1] = r(e, n), s[0] = a(t, i), s[1] = a(e, n)
    };
    var d = [], f = [];
    return n.fromCubic = function (t, e, n, o, s, l, c, u, h, p) {
      var v, m = i.cubicExtrema, g = i.cubicAt, y = m(t, n, s, c, d);
      for (h[0] = 1 / 0, h[1] = 1 / 0, p[0] = -1 / 0, p[1] = -1 / 0, v = 0; y > v; v++) {
        var x = g(t, n, s, c, d[v]);
        h[0] = r(x, h[0]), p[0] = a(x, p[0])
      }
      for (y = m(e, o, l, u, f), v = 0; y > v; v++) {
        var _ = g(e, o, l, u, f[v]);
        h[1] = r(_, h[1]), p[1] = a(_, p[1])
      }
      h[0] = r(t, h[0]), p[0] = a(t, p[0]), h[0] = r(c, h[0]), p[0] = a(c, p[0]), h[1] = r(e, h[1]), p[1] = a(e, p[1]), h[1] = r(u, h[1]), p[1] = a(u, p[1])
    }, n.fromQuadratic = function (t, e, n, o, s, l, c, u) {
      var h = i.quadraticExtremum, d = i.quadraticAt, f = a(r(h(t, n, s), 1), 0), p = a(r(h(e, o, l), 1), 0), v = d(t, n, s, f), m = d(e, o, l, p);
      c[0] = r(t, s, v), c[1] = r(e, l, m), u[0] = a(t, s, v), u[1] = a(e, l, m)
    }, n.fromArc = function (t, i, n, r, a, d, f, p, v) {
      var m = e.min, g = e.max, y = Math.abs(a - d);
      if (1e-4 > y % h && y > 1e-4)return p[0] = t - n, p[1] = i - r, v[0] = t + n, void(v[1] = i + r);
      if (l[0] = s(a) * n + t, l[1] = o(a) * r + i, c[0] = s(d) * n + t, c[1] = o(d) * r + i, m(p, l, c), g(v, l, c), a %= h, 0 > a && (a += h), d %= h, 0 > d && (d += h), a > d && !f ? d += h : d > a && f && (a += h), f) {
        var x = d;
        d = a, a = x
      }
      for (var _ = 0; d > _; _ += Math.PI / 2)_ > a && (u[0] = s(_) * n + t, u[1] = o(_) * r + i, m(p, u, p), g(v, u, v))
    }, n
  }),e("zrender/core/curve", [Pe, "./vector"], function (t) {
    function e(t) {
      return t > -_ && _ > t
    }

    function i(t) {
      return t > _ || -_ > t
    }

    function n(t, e, i, n, r) {
      var a = 1 - r;
      return a * a * (a * t + 3 * r * e) + r * r * (r * n + 3 * a * i)
    }

    function r(t, e, i, n, r) {
      var a = 1 - r;
      return 3 * (((e - t) * a + 2 * (i - e) * r) * a + (n - i) * r * r)
    }

    function a(t, i, n, r, a, o) {
      var s = r + 3 * (i - n) - t, l = 3 * (n - 2 * i + t), c = 3 * (i - t), u = t - a, h = l * l - 3 * s * c, d = l * c - 9 * s * u, f = c * c - 3 * l * u, p = 0;
      if (e(h) && e(d))if (e(l))o[0] = 0; else {
        var v = -c / l;
        v >= 0 && 1 >= v && (o[p++] = v)
      } else {
        var m = d * d - 4 * h * f;
        if (e(m)) {
          var g = d / h, v = -l / s + g, _ = -g / 2;
          v >= 0 && 1 >= v && (o[p++] = v), _ >= 0 && 1 >= _ && (o[p++] = _)
        } else if (m > 0) {
          var b = x(m), M = h * l + 1.5 * s * (-d + b), T = h * l + 1.5 * s * (-d - b);
          M = 0 > M ? -y(-M, S) : y(M, S), T = 0 > T ? -y(-T, S) : y(T, S);
          var v = (-l - (M + T)) / (3 * s);
          v >= 0 && 1 >= v && (o[p++] = v)
        } else {
          var C = (2 * h * l - 3 * s * d) / (2 * x(h * h * h)), A = Math.acos(C) / 3, L = x(h), P = Math.cos(A), v = (-l - 2 * L * P) / (3 * s), _ = (-l + L * (P + w * Math.sin(A))) / (3 * s), k = (-l + L * (P - w * Math.sin(A))) / (3 * s);
          v >= 0 && 1 >= v && (o[p++] = v), _ >= 0 && 1 >= _ && (o[p++] = _), k >= 0 && 1 >= k && (o[p++] = k)
        }
      }
      return p
    }

    function o(t, n, r, a, o) {
      var s = 6 * r - 12 * n + 6 * t, l = 9 * n + 3 * a - 3 * t - 9 * r, c = 3 * n - 3 * t, u = 0;
      if (e(l)) {
        if (i(s)) {
          var h = -c / s;
          h >= 0 && 1 >= h && (o[u++] = h)
        }
      } else {
        var d = s * s - 4 * l * c;
        if (e(d))o[0] = -s / (2 * l); else if (d > 0) {
          var f = x(d), h = (-s + f) / (2 * l), p = (-s - f) / (2 * l);
          h >= 0 && 1 >= h && (o[u++] = h), p >= 0 && 1 >= p && (o[u++] = p)
        }
      }
      return u
    }

    function s(t, e, i, n, r, a) {
      var o = (e - t) * r + t, s = (i - e) * r + e, l = (n - i) * r + i, c = (s - o) * r + o, u = (l - s) * r + s, h = (u - c) * r + c;
      a[0] = t, a[1] = o, a[2] = c, a[3] = h, a[4] = h, a[5] = u, a[6] = l, a[7] = n
    }

    function l(t, e, i, r, a, o, s, l, c, u, h) {
      var d, f, p, v, m, y = .005, _ = 1 / 0;
      M[0] = c, M[1] = u;
      for (var w = 0; 1 > w; w += .05)T[0] = n(t, i, a, s, w), T[1] = n(e, r, o, l, w), v = g(M, T), _ > v && (d = w, _ = v);
      _ = 1 / 0;
      for (var S = 0; 32 > S && !(b > y); S++)f = d - y, p = d + y, T[0] = n(t, i, a, s, f), T[1] = n(e, r, o, l, f), v = g(T, M), f >= 0 && _ > v ? (d = f, _ = v) : (C[0] = n(t, i, a, s, p), C[1] = n(e, r, o, l, p), m = g(C, M), 1 >= p && _ > m ? (d = p, _ = m) : y *= .5);
      return h && (h[0] = n(t, i, a, s, d), h[1] = n(e, r, o, l, d)), x(_)
    }

    function c(t, e, i, n) {
      var r = 1 - n;
      return r * (r * t + 2 * n * e) + n * n * i
    }

    function u(t, e, i, n) {
      return 2 * ((1 - n) * (e - t) + n * (i - e))
    }

    function h(t, n, r, a, o) {
      var s = t - 2 * n + r, l = 2 * (n - t), c = t - a, u = 0;
      if (e(s)) {
        if (i(l)) {
          var h = -c / l;
          h >= 0 && 1 >= h && (o[u++] = h)
        }
      } else {
        var d = l * l - 4 * s * c;
        if (e(d)) {
          var h = -l / (2 * s);
          h >= 0 && 1 >= h && (o[u++] = h)
        } else if (d > 0) {
          var f = x(d), h = (-l + f) / (2 * s), p = (-l - f) / (2 * s);
          h >= 0 && 1 >= h && (o[u++] = h), p >= 0 && 1 >= p && (o[u++] = p)
        }
      }
      return u
    }

    function d(t, e, i) {
      var n = t + i - 2 * e;
      return 0 === n ? .5 : (t - e) / n
    }

    function f(t, e, i, n, r) {
      var a = (e - t) * n + t, o = (i - e) * n + e, s = (o - a) * n + a;
      r[0] = t, r[1] = a, r[2] = s, r[3] = s, r[4] = o, r[5] = i
    }

    function p(t, e, i, n, r, a, o, s, l) {
      var u, h = .005, d = 1 / 0;
      M[0] = o, M[1] = s;
      for (var f = 0; 1 > f; f += .05) {
        T[0] = c(t, i, r, f), T[1] = c(e, n, a, f);
        var p = g(M, T);
        d > p && (u = f, d = p)
      }
      d = 1 / 0;
      for (var v = 0; 32 > v && !(b > h); v++) {
        var m = u - h, y = u + h;
        T[0] = c(t, i, r, m), T[1] = c(e, n, a, m);
        var p = g(T, M);
        if (m >= 0 && d > p)u = m, d = p; else {
          C[0] = c(t, i, r, y), C[1] = c(e, n, a, y);
          var _ = g(C, M);
          1 >= y && d > _ ? (u = y, d = _) : h *= .5
        }
      }
      return l && (l[0] = c(t, i, r, u), l[1] = c(e, n, a, u)), x(d)
    }

    var v = t("./vector"), m = v[le], g = v.distSquare, y = Math.pow, x = Math.sqrt, _ = 1e-8, b = 1e-4, w = x(3), S = 1 / 3, M = m(), T = m(), C = m();
    return {
      cubicAt: n,
      cubicDerivativeAt: r,
      cubicRootAt: a,
      cubicExtrema: o,
      cubicSubdivide: s,
      cubicProjectPoint: l,
      quadraticAt: c,
      quadraticDerivativeAt: u,
      quadraticRootAt: h,
      quadraticExtremum: d,
      quadraticSubdivide: f,
      quadraticProjectPoint: p
    }
  }),e("zrender/config", [], function () {
    var t = 1;
    "undefined" != typeof window && (t = Math.max(window.devicePixelRatio || 1, 1));
    var e = {debugMode: 0, devicePixelRatio: t};
    return e
  }),e("zrender/Element", [Pe, "./core/guid", "./mixin/Eventful", "./mixin/Transformable", "./mixin/Animatable", "./core/util"], function (t) {
    var e = t("./core/guid"), i = t("./mixin/Eventful"), n = t("./mixin/Transformable"), a = t("./mixin/Animatable"), o = t("./core/util"), s = function (t) {
      n.call(this, t), i.call(this, t), a.call(this, t), this.id = t.id || e()
    };
    return s[xe] = {
      type: "element", name: "", __zr: null, ignore: !1, clipPath: null, drift: function (t, e) {
        switch (this.draggable) {
          case"horizontal":
            e = 0;
            break;
          case"vertical":
            t = 0
        }
        var i = this[r];
        i || (i = this[r] = [1, 0, 0, 1, 0, 0]), i[4] += t, i[5] += e, this.decomposeTransform(), this.dirty(!1)
      }, beforeUpdate: function () {
      }, afterUpdate: function () {
      }, update: function () {
        this.updateTransform()
      }, traverse: function () {
      }, attrKV: function (t, e) {
        if (t === z || "scale" === t || "origin" === t) {
          if (e) {
            var i = this[t];
            i || (i = this[t] = []), i[0] = e[0], i[1] = e[1]
          }
        } else this[t] = e
      }, hide: function () {
        this[he] = !0, this.__zr && this.__zr.refresh()
      }, show: function () {
        this[he] = !1, this.__zr && this.__zr.refresh()
      }, attr: function (t, e) {
        if (typeof t === ye)this.attrKV(t, e); else if (o[oe](t))for (var i in t)t.hasOwnProperty(i) && this.attrKV(i, t[i]);
        return this.dirty(!1), this
      }, setClipPath: function (t) {
        var e = this.__zr;
        e && t.addSelfToZr(e), this.clipPath && this.clipPath !== t && this.removeClipPath(), this.clipPath = t, t.__zr = e, t.__clipTarget = this, this.dirty(!1)
      }, removeClipPath: function () {
        var t = this.clipPath;
        t && (t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__clipTarget = null, this.clipPath = null, this.dirty(!1))
      }, addSelfToZr: function (t) {
        this.__zr = t;
        var e = this.animators;
        if (e)for (var i = 0; i < e[ne]; i++)t[_].addAnimator(e[i]);
        this.clipPath && this.clipPath.addSelfToZr(t)
      }, removeSelfFromZr: function (t) {
        this.__zr = null;
        var e = this.animators;
        if (e)for (var i = 0; i < e[ne]; i++)t[_].removeAnimator(e[i]);
        this.clipPath && this.clipPath.removeSelfFromZr(t)
      }
    }, o.mixin(s, a), o.mixin(s, n), o.mixin(s, i), s
  }),e("zrender/graphic/Style", [Pe], function () {
    function t(t, e, i) {
      var n = e.x, r = e.x2, a = e.y, o = e.y2;
      e.global || (n = n * i.width + i.x, r = r * i.width + i.x, a = a * i[ce] + i.y, o = o * i[ce] + i.y);
      var s = t.createLinearGradient(n, a, r, o);
      return s
    }

    function e(t, e, i) {
      var n = i.width, r = i[ce], a = Math.min(n, r), o = e.x, s = e.y, l = e.r;
      e.global || (o = o * n + i.x, s = s * r + i.y, l *= a);
      var c = t.createRadialGradient(o, s, 0, o, s, l);
      return c
    }

    var i = [["shadowBlur", 0], ["shadowOffsetX", 0], ["shadowOffsetY", 0], ["shadowColor", "#000"], ["lineCap", "butt"], ["lineJoin", "miter"], ["miterLimit", 10]], n = function (t) {
      this.extendFrom(t)
    };
    n[xe] = {
      constructor: n,
      fill: "#000000",
      stroke: null,
      opacity: 1,
      lineDash: null,
      lineDashOffset: 0,
      shadowBlur: 0,
      shadowOffsetX: 0,
      shadowOffsetY: 0,
      lineWidth: 1,
      strokeNoScale: !1,
      text: null,
      textFill: "#000",
      textStroke: null,
      textPosition: "inside",
      textBaseline: null,
      textAlign: null,
      textVerticalAlign: null,
      textDistance: 5,
      textShadowBlur: 0,
      textShadowOffsetX: 0,
      textShadowOffsetY: 0,
      blend: null,
      bind: function (t, e, n) {
        for (var r = this, a = n && n.style, o = !a, s = 0; s < i[ne]; s++) {
          var l = i[s], h = l[0];
          (o || r[h] !== a[h]) && (t[h] = r[h] || l[1])
        }
        if ((o || r.fill !== a.fill) && (t.fillStyle = r.fill), (o || r[c] !== a[c]) && (t.strokeStyle = r[c]), (o || r[I] !== a[I]) && (t.globalAlpha = null == r[I] ? 1 : r[I]), (o || r.blend !== a.blend) && (t.globalCompositeOperation = r.blend || "source-over"), this.hasStroke()) {
          var d = r[u];
          t[u] = d / (this.strokeNoScale && e && e.getLineScale ? e.getLineScale() : 1)
        }
      },
      hasFill: function () {
        var t = this.fill;
        return null != t && "none" !== t
      },
      hasStroke: function () {
        var t = this[c];
        return null != t && "none" !== t && this[u] > 0
      },
      extendFrom: function (t, e) {
        if (t) {
          var i = this;
          for (var n in t)!t.hasOwnProperty(n) || !e && i.hasOwnProperty(n) || (i[n] = t[n])
        }
      },
      set: function (t, e) {
        typeof t === ye ? this[t] = e : this.extendFrom(t, !0)
      },
      clone: function () {
        var t = new this.constructor;
        return t.extendFrom(this, !0), t
      },
      getGradient: function (i, n, r) {
        for (var a = "radial" === n.type ? e : t, o = a(i, n, r), s = n.colorStops, l = 0; l < s[ne]; l++)o.addColorStop(s[l].offset, s[l].color);
        return o
      }
    };
    for (var r = n[xe], a = 0; a < i[ne]; a++) {
      var o = i[a];
      o[0]in r || (r[o[0]] = o[1])
    }
    return n.getGradient = r.getGradient, n
  }),e("echarts/coord/cartesian/Cartesian", [Pe, Le], function (t) {
    function e(t) {
      return this._axes[t]
    }

    var i = t(Le), n = function (t) {
      this._axes = {}, this._dimList = [], this.name = t || ""
    };
    return n[xe] = {
      constructor: n, type: "cartesian", getAxis: function (t) {
        return this._axes[t]
      }, getAxes: function () {
        return i.map(this._dimList, e, this)
      }, getAxesByScale: function (t) {
        return t = t[_e](), i[H](this.getAxes(), function (e) {
          return e.scale.type === t
        })
      }, addAxis: function (t) {
        var e = t.dim;
        this._axes[e] = t, this._dimList.push(e)
      }, dataToCoord: function (t) {
        return this._dataCoordConvert(t, b)
      }, coordToData: function (t) {
        return this._dataCoordConvert(t, "coordToData")
      }, _dataCoordConvert: function (t, e) {
        for (var i = this._dimList, n = t instanceof Array ? [] : {}, r = 0; r < i[ne]; r++) {
          var a = i[r], o = this._axes[a];
          n[a] = o[e](t[a])
        }
        return n
      }
    }, n
  }),e("echarts/util/component", [Pe, Le, "./clazz"], function (t) {
    var e = t(Le), i = t("./clazz"), n = i.parseClassType, r = 0, a = {}, o = "_";
    return a.getUID = function (t) {
      return [t || "", r++, Math.random()].join(o)
    }, a.enableSubTypeDefaulter = function (t) {
      var e = {};
      return t.registerSubTypeDefaulter = function (t, i) {
        t = n(t), e[t.main] = i
      }, t.determineSubType = function (i, r) {
        var a = r.type;
        if (!a) {
          var o = n(i).main;
          t.hasSubTypes(i) && e[o] && (a = e[o](r))
        }
        return a
      }, t
    }, a.enableTopologicalTravel = function (t, i) {
      function n(t) {
        var n = {}, o = [];
        return e.each(t, function (s) {
          var l = r(n, s), c = l.originalDeps = i(s), u = a(c, t);
          l.entryCount = u[ne], 0 === l.entryCount && o.push(s), e.each(u, function (t) {
            e[V](l.predecessor, t) < 0 && l.predecessor.push(t);
            var i = r(n, t);
            e[V](i.successor, t) < 0 && i.successor.push(s)
          })
        }), {graph: n, noEntryList: o}
      }

      function r(t, e) {
        return t[e] || (t[e] = {predecessor: [], successor: []}), t[e]
      }

      function a(t, i) {
        var n = [];
        return e.each(t, function (t) {
          e[V](i, t) >= 0 && n.push(t)
        }), n
      }

      t.topologicalTravel = function (t, i, r, a) {
        function o(t) {
          c[t].entryCount--, 0 === c[t].entryCount && u.push(t)
        }

        function s(t) {
          h[t] = !0, o(t)
        }

        if (t[ne]) {
          var l = n(i), c = l.graph, u = l.noEntryList, h = {};
          for (e.each(t, function (t) {
            h[t] = !0
          }); u[ne];) {
            var d = u.pop(), f = c[d], p = !!h[d];
            p && (r.call(a, d, f.originalDeps.slice()), delete h[d]), e.each(f.successor, p ? s : o)
          }
          e.each(h, function () {
            throw new Error("Circle dependency may exists")
          })
        }
      }
    }, a
  }),e("echarts/model/mixin/boxLayout", [Pe], function () {
    return {
      getBoxLayoutParams: function () {
        return {
          left: this.get("left"),
          top: this.get("top"),
          right: this.get("right"),
          bottom: this.get(ue),
          width: this.get("width"),
          height: this.get(ce)
        }
      }
    }
  }),e("echarts/coord/cartesian/axisLabelInterval", [Pe, Le, "../axisHelper"], function (t) {
    var e = t(Le), i = t("../axisHelper");
    return function (t) {
      var n = t.model, r = n[me]("axisLabel"), a = r.get("interval");
      return t.type !== s || "auto" !== a ? "auto" === a ? 0 : a : i.getAxisLabelInterval(e.map(t.scale[P](), t[b], t), n.getFormattedLabels(), r[me](G)[B](), t.isHorizontal())
    }
  }),e("zrender/core/guid", [], function () {
    var t = 2311;
    return function () {
      return t++
    }
  }),e("zrender/mixin/Animatable", [Pe, "../animation/Animator", "../core/util", "../core/log"], function (t) {
    var e = t("../animation/Animator"), i = t("../core/util"), n = i.isString, r = i.isFunction, a = i[oe], o = t("../core/log"), s = function () {
      this.animators = []
    };
    return s[xe] = {
      constructor: s, animate: function (t, n) {
        var r, a = !1, s = this, l = this.__zr;
        if (t) {
          var c = t.split("."), u = s;
          a = "shape" === c[0];
          for (var h = 0, d = c[ne]; d > h; h++)u && (u = u[c[h]]);
          u && (r = u)
        } else r = s;
        if (!r)return void o('Property "' + t + '" is not existed in element ' + s.id);
        var f = s.animators, p = new e(r, n);
        return p.during(function () {
          s.dirty(a)
        }).done(function () {
          f[ee](i[V](f, p), 1)
        }), f.push(p), l && l[_].addAnimator(p), p
      }, stopAnimation: function (t) {
        for (var e = this.animators, i = e[ne], n = 0; i > n; n++)e[n].stop(t);
        return e[ne] = 0, this
      }, animateTo: function (t, e, i, a, o) {
        function s() {
          c--, c || o && o()
        }

        n(i) ? (o = a, a = i, i = 0) : r(a) ? (o = a, a = "linear", i = 0) : r(i) ? (o = i, i = 0) : r(e) ? (o = e, e = 500) : e || (e = 500), this.stopAnimation(), this._animateToShallow("", this, t, e, i, a, o);
        var l = this.animators.slice(), c = l[ne];
        c || o && o();
        for (var u = 0; u < l[ne]; u++)l[u].done(s).start(a)
      }, _animateToShallow: function (t, e, n, r, o) {
        var s = {}, l = 0;
        for (var c in n)if (null != e[c])a(n[c]) && !i.isArrayLike(n[c]) ? this._animateToShallow(t ? t + "." + c : c, e[c], n[c], r, o) : (s[c] = n[c], l++); else if (null != n[c])if (t) {
          var u = {};
          u[t] = {}, u[t][c] = n[c], this.attr(u)
        } else this.attr(c, n[c]);
        return l > 0 && this.animate(t, !1).when(null == r ? 500 : r, s).delay(o || 0), this
      }
    }, s
  }),e("zrender/mixin/Transformable", [Pe, "../core/matrix", "../core/vector"], function (t) {
    function e(t) {
      return t > o || -o > t
    }

    var i = t("../core/matrix"), n = t("../core/vector"), a = i.identity, o = 5e-5, s = function (t) {
      t = t || {}, t[z] || (this[z] = [0, 0]), null == t.rotation && (this.rotation = 0), t.scale || (this.scale = [1, 1]), this.origin = this.origin || null
    }, l = s[xe];
    l[r] = null, l.needLocalTransform = function () {
      return e(this.rotation) || e(this[z][0]) || e(this[z][1]) || e(this.scale[0] - 1) || e(this.scale[1] - 1)
    }, l.updateTransform = function () {
      var t = this.parent, e = t && t[r], n = this.needLocalTransform(), o = this[r];
      return n || e ? (o = o || i[le](), n ? this.getLocalTransform(o) : a(o), e && (n ? i.mul(o, t[r], o) : i.copy(o, t[r])), this[r] = o, this.invTransform = this.invTransform || i[le](), void i.invert(this.invTransform, o)) : void(o && a(o))
    }, l.getLocalTransform = function (t) {
      t = t || [], a(t);
      var e = this.origin, n = this.scale, r = this.rotation, o = this[z];
      return e && (t[4] -= e[0], t[5] -= e[1]), i.scale(t, t, n), r && i.rotate(t, t, r), e && (t[4] += e[0], t[5] += e[1]), t[4] += o[0], t[5] += o[1], t
    }, l.setTransform = function (t) {
      var e = this[r];
      e && t[r](e[0], e[1], e[2], e[3], e[4], e[5])
    }, l.restoreTransform = function (t) {
      var e = this.invTransform;
      e && t[r](e[0], e[1], e[2], e[3], e[4], e[5])
    };
    var c = [];
    return l.decomposeTransform = function () {
      if (this[r]) {
        var t = this.parent, n = this[r];
        t && t[r] && (i.mul(c, t.invTransform, n), n = c);
        var a = n[0] * n[0] + n[1] * n[1], o = n[2] * n[2] + n[3] * n[3], s = this[z], l = this.scale;
        e(a - 1) && (a = Math.sqrt(a)), e(o - 1) && (o = Math.sqrt(o)), n[0] < 0 && (a = -a), n[3] < 0 && (o = -o), s[0] = n[4], s[1] = n[5], l[0] = a, l[1] = o, this.rotation = Math.atan2(-n[1] / o, n[0] / a)
      }
    }, l.getGlobalScale = function () {
      var t = this[r];
      if (!t)return [1, 1];
      var e = Math.sqrt(t[0] * t[0] + t[1] * t[1]), i = Math.sqrt(t[2] * t[2] + t[3] * t[3]);
      return t[0] < 0 && (e = -e), t[3] < 0 && (i = -i), [e, i]
    }, l.transformCoordToLocal = function (t, e) {
      var i = [t, e], r = this.invTransform;
      return r && n[h](i, i, r), i
    }, l.transformCoordToGlobal = function (t, e) {
      var i = [t, e], a = this[r];
      return a && n[h](i, i, a), i
    }, s
  }),e("echarts/coord/Axis", [Pe, "../util/number", Le], function (t) {
    function e(t, e) {
      var i = t[1] - t[0], n = e, r = i / n / 2;
      t[0] += r, t[1] -= r
    }

    var i = t("../util/number"), n = i.linearMap, r = t(Le), a = [0, 1], o = function (t, e, i) {
      this.dim = t, this.scale = e, this._extent = i || [0, 0], this.inverse = !1, this.onBand = !1
    };
    return o[xe] = {
      constructor: o, contain: function (t) {
        var e = this._extent, i = Math.min(e[0], e[1]), n = Math.max(e[0], e[1]);
        return t >= i && n >= t
      }, containData: function (t) {
        return this[k](this[b](t))
      }, getExtent: function () {
        var t = this._extent.slice();
        return t
      }, getPixelPrecision: function (t) {
        return i.getPixelPrecision(t || this.scale[L](), this._extent)
      }, setExtent: function (t, e) {
        var i = this._extent;
        i[0] = t, i[1] = e
      }, dataToCoord: function (t, i) {
        var r = this._extent, o = this.scale;
        return t = o.normalize(t), this.onBand && o.type === x && (r = r.slice(), e(r, o.count())), n(t, a, r, i)
      }, coordToData: function (t, i) {
        var r = this._extent, o = this.scale;
        this.onBand && o.type === x && (r = r.slice(), e(r, o.count()));
        var s = n(t, r, a, i);
        return this.scale.scale(s)
      }, getTicksCoords: function (t) {
        if (this.onBand && !t) {
          for (var e = this.getBands(), i = [], n = 0; n < e[ne]; n++)i.push(e[n][0]);
          return e[n - 1] && i.push(e[n - 1][1]), i
        }
        return r.map(this.scale[P](), this[b], this)
      }, getLabelsCoords: function () {
        return r.map(this.scale[P](), this[b], this)
      }, getBands: function () {
        for (var t = this[L](), e = [], i = this.scale.count(), n = t[0], r = t[1], a = r - n, o = 0; i > o; o++)e.push([a * o / i + n, a * (o + 1) / i + n]);
        return e
      }, getBandWidth: function () {
        var t = this._extent, e = this.scale[L](), i = e[1] - e[0] + (this.onBand ? 1 : 0);
        0 === i && (i = 1);
        var n = Math.abs(t[1] - t[0]);
        return Math.abs(n) / i
      }
    }, o
  }),e("zrender/animation/Animator", [Pe, "./Clip", "../tool/color", "../core/util"], function (t) {
    function e(t, e) {
      return t[e]
    }

    function i(t, e, i) {
      t[e] = i
    }

    function n(t, e, i) {
      return (e - t) * i + t
    }

    function r(t, e, i) {
      return i > .5 ? e : t
    }

    function a(t, e, i, r, a) {
      var o = t[ne];
      if (1 == a)for (var s = 0; o > s; s++)r[s] = n(t[s], e[s], i); else for (var l = t[0][ne], s = 0; o > s; s++)for (var c = 0; l > c; c++)r[s][c] = n(t[s][c], e[s][c], i)
    }

    function o(t, e, i) {
      var n = t[ne], r = e[ne];
      if (n !== r) {
        var a = n > r;
        if (a)t[ne] = r; else for (var o = n; r > o; o++)t.push(1 === i ? e[o] : g.call(e[o]))
      }
      for (var s = t[0] && t[0][ne], o = 0; o < t[ne]; o++)if (1 === i)isNaN(t[o]) && (t[o] = e[o]); else for (var l = 0; s > l; l++)isNaN(t[o][l]) && (t[o][l] = e[o][l])
    }

    function s(t, e, i) {
      if (t === e)return !0;
      var n = t[ne];
      if (n !== e[ne])return !1;
      if (1 === i) {
        for (var r = 0; n > r; r++)if (t[r] !== e[r])return !1
      } else for (var a = t[0][ne], r = 0; n > r; r++)for (var o = 0; a > o; o++)if (t[r][o] !== e[r][o])return !1;
      return !0
    }

    function l(t, e, i, n, r, a, o, s, l) {
      var u = t[ne];
      if (1 == l)for (var h = 0; u > h; h++)s[h] = c(t[h], e[h], i[h], n[h], r, a, o); else for (var d = t[0][ne], h = 0; u > h; h++)for (var f = 0; d > f; f++)s[h][f] = c(t[h][f], e[h][f], i[h][f], n[h][f], r, a, o)
    }

    function c(t, e, i, n, r, a, o) {
      var s = .5 * (i - t), l = .5 * (n - e);
      return (2 * (e - i) + s + l) * o + (-3 * (e - i) - 2 * s - l) * a + s * r + e
    }

    function u(t) {
      if (m(t)) {
        var e = t[ne];
        if (m(t[0])) {
          for (var i = [], n = 0; e > n; n++)i.push(g.call(t[n]));
          return i
        }
        return g.call(t)
      }
      return t
    }

    function h(t) {
      return t[0] = Math.floor(t[0]), t[1] = Math.floor(t[1]), t[2] = Math.floor(t[2]), "rgba(" + t.join(",") + ")"
    }

    function d(t, e, i, u, d) {
      var v = t._getter, g = t._setter, y = "spline" === e, x = u[ne];
      if (x) {
        var _, b = u[0].value, w = m(b), S = !1, M = !1, T = w && m(b[0]) ? 2 : 1;
        u.sort(function (t, e) {
          return t.time - e.time
        }), _ = u[x - 1].time;
        for (var C = [], A = [], L = u[0].value, P = !0, k = 0; x > k; k++) {
          C.push(u[k].time / _);
          var I = u[k].value;
          if (w && s(I, L, T) || !w && I === L || (P = !1), L = I, typeof I == ye) {
            var z = p.parse(I);
            z ? (I = z, S = !0) : M = !0
          }
          A.push(I)
        }
        if (!P) {
          for (var D = A[x - 1], k = 0; x - 1 > k; k++)w ? o(A[k], D, T) : !isNaN(A[k]) || isNaN(D) || M || S || (A[k] = D);
          w && o(v(t._target, d), D, T);
          var E, O, R, B, N, G, F = 0, V = 0;
          if (S)var H = [0, 0, 0, 0];
          var q = function (t, e) {
            var i;
            if (V > e) {
              for (E = Math.min(F + 1, x - 1), i = E; i >= 0 && !(C[i] <= e); i--);
              i = Math.min(i, x - 2)
            } else {
              for (i = F; x > i && !(C[i] > e); i++);
              i = Math.min(i - 1, x - 2)
            }
            F = i, V = e;
            var o = C[i + 1] - C[i];
            if (0 !== o)if (O = (e - C[i]) / o, y)if (B = A[i], R = A[0 === i ? i : i - 1], N = A[i > x - 2 ? x - 1 : i + 1], G = A[i > x - 3 ? x - 1 : i + 2], w)l(R, B, N, G, O, O * O, O * O * O, v(t, d), T); else {
              var s;
              if (S)s = l(R, B, N, G, O, O * O, O * O * O, H, 1), s = h(H); else {
                if (M)return r(B, N, O);
                s = c(R, B, N, G, O, O * O, O * O * O)
              }
              g(t, d, s)
            } else if (w)a(A[i], A[i + 1], O, v(t, d), T); else {
              var s;
              if (S)a(A[i], A[i + 1], O, H, 1), s = h(H); else {
                if (M)return r(A[i], A[i + 1], O);
                s = n(A[i], A[i + 1], O)
              }
              g(t, d, s)
            }
          }, W = new f({target: t._target, life: _, loop: t._loop, delay: t._delay, onframe: q, ondestroy: i});
          return e && "spline" !== e && (W.easing = e), W
        }
      }
    }

    var f = t("./Clip"), p = t("../tool/color"), v = t("../core/util"), m = v.isArrayLike, g = Array[xe].slice, y = function (t, n, r, a) {
      this._tracks = {}, this._target = t, this._loop = n || !1, this._getter = r || e, this._setter = a || i, this._clipCount = 0, this._delay = 0, this._doneList = [], this._onframeList = [], this._clipList = []
    };
    return y[xe] = {
      when: function (t, e) {
        var i = this._tracks;
        for (var n in e) {
          if (!i[n]) {
            i[n] = [];
            var r = this._getter(this._target, n);
            if (null == r)continue;
            0 !== t && i[n].push({time: 0, value: u(r)})
          }
          i[n].push({time: t, value: e[n]})
        }
        return this
      }, during: function (t) {
        return this._onframeList.push(t), this
      }, _doneCallback: function () {
        this._tracks = {}, this._clipList[ne] = 0;
        for (var t = this._doneList, e = t[ne], i = 0; e > i; i++)t[i].call(this)
      }, start: function (t) {
        var e, i = this, n = 0, r = function () {
          n--, n || i._doneCallback()
        };
        for (var a in this._tracks) {
          var o = d(this, t, r, this._tracks[a], a);
          o && (this._clipList.push(o), n++, this[_] && this[_].addClip(o), e = o)
        }
        if (e) {
          var s = e.onframe;
          e.onframe = function (t, e) {
            s(t, e);
            for (var n = 0; n < i._onframeList[ne]; n++)i._onframeList[n](t, e)
          }
        }
        return n || this._doneCallback(), this
      }, stop: function (t) {
        for (var e = this._clipList, i = this[_], n = 0; n < e[ne]; n++) {
          var r = e[n];
          t && r.onframe(this._target, 1), i && i.removeClip(r)
        }
        e[ne] = 0
      }, delay: function (t) {
        return this._delay = t, this
      }, done: function (t) {
        return t && this._doneList.push(t), this
      }, getClips: function () {
        return this._clipList
      }
    }, y
  }),e("zrender/core/log", [Pe, "../config"], function (t) {
    var e = t("../config");
    return function () {
      if (0 !== e.debugMode)if (1 == e.debugMode)for (var t in arguments)throw new Error(arguments[t]); else if (e.debugMode > 1)for (var t in arguments)console.log(arguments[t])
    }
  }),e("echarts/coord/cartesian/AxisModel", [Pe, "../../model/Component", Le, "../axisModelCreator", "../axisModelCommonMixin"], function (t) {
    function e(t, e) {
      return e.type || (e.data ? s : "value")
    }

    var i = t("../../model/Component"), n = t(Le), r = t("../axisModelCreator"), a = i[re]({
      type: "cartesian2dAxis",
      axis: null,
      init: function () {
        a.superApply(this, "init", arguments), this._resetRange()
      },
      mergeOption: function () {
        a.superApply(this, "mergeOption", arguments), this._resetRange()
      },
      restoreData: function () {
        a.superApply(this, "restoreData", arguments), this._resetRange()
      },
      setRange: function (t, e) {
        this[o].rangeStart = t, this[o].rangeEnd = e
      },
      getMin: function () {
        var t = this[o];
        return null != t.rangeStart ? t.rangeStart : t.min
      },
      getMax: function () {
        var t = this[o];
        return null != t.rangeEnd ? t.rangeEnd : t.max
      },
      getNeedCrossZero: function () {
        var t = this[o];
        return null != t.rangeStart || null != t.rangeEnd ? !1 : !t.scale
      },
      _resetRange: function () {
        this[o].rangeStart = this[o].rangeEnd = null
      }
    });
    n.merge(a[xe], t("../axisModelCommonMixin"));
    var l = {gridIndex: 0, offset: 0};
    return r("x", a, e, l), r("y", a, e, l), a
  }),e("zrender/animation/Clip", [Pe, "./easing"], function (t) {
    function e(t) {
      this._target = t[K], this._life = t.life || 1e3, this._delay = t.delay || 0, this._initialized = !1, this.loop = null == t.loop ? !1 : t.loop, this.gap = t.gap || 0, this.easing = t.easing || "Linear", this.onframe = t.onframe, this.ondestroy = t.ondestroy, this.onrestart = t.onrestart
    }

    var i = t("./easing");
    return e[xe] = {
      constructor: e, step: function (t) {
        this._initialized || (this._startTime = (new Date).getTime() + this._delay, this._initialized = !0);
        var e = (t - this._startTime) / this._life;
        if (!(0 > e)) {
          e = Math.min(e, 1);
          var n = this.easing, r = typeof n == ye ? i[n] : n, a = typeof r === W ? r(e) : e;
          return this.fire("frame", a), 1 == e ? this.loop ? (this.restart(), "restart") : (this._needsRemove = !0, "destroy") : null
        }
      }, restart: function () {
        var t = (new Date).getTime(), e = (t - this._startTime) % this._life;
        this._startTime = (new Date).getTime() - e + this.gap, this._needsRemove = !1
      }, fire: function (t, e) {
        t = "on" + t, this[t] && this[t](this._target, e)
      }
    }, e
  }),e("echarts/coord/axisModelCreator", [Pe, "./axisDefault", Le, "../model/Component", "../util/layout"], function (t) {
    var e = t("./axisDefault"), i = t(Le), n = t("../model/Component"), r = t("../util/layout"), a = ["value", s, "time", "log"];
    return function (t, o, s, l) {
      i.each(a, function (n) {
        o[re]({
          type: t + "Axis." + n, mergeDefaultAndTheme: function (e, a) {
            var o = this.layoutMode, l = o ? r.getLayoutParams(e) : {}, c = a.getTheme();
            i.merge(e, c.get(n + "Axis")), i.merge(e, this.getDefaultOption()), e.type = s(t, e), o && r.mergeLayoutParam(e, l, o)
          }, defaultOption: i.mergeAll([{}, e[n + "Axis"], l], !0)
        })
      }), n.registerSubTypeDefaulter(t + "Axis", i.curry(s, t))
    }
  }),e("echarts/coord/axisModelCommonMixin", [Pe, Le, "./axisHelper"], function (t) {
    function e(t) {
      return r[oe](t) && null != t.value ? t.value : t
    }

    function i() {
      return this.get("type") === s && r.map(this.get("data"), e)
    }

    function n() {
      return a.getFormattedLabels(this.axis, this.get("axisLabel.formatter"))
    }

    var r = t(Le), a = t("./axisHelper");
    return {getFormattedLabels: n, getCategories: i}
  }),e("zrender/animation/easing", [], function () {
    var t = {
      linear: function (t) {
        return t
      }, quadraticIn: function (t) {
        return t * t
      }, quadraticOut: function (t) {
        return t * (2 - t)
      }, quadraticInOut: function (t) {
        return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
      }, cubicIn: function (t) {
        return t * t * t
      }, cubicOut: function (t) {
        return --t * t * t + 1
      }, cubicInOut: function (t) {
        return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
      }, quarticIn: function (t) {
        return t * t * t * t
      }, quarticOut: function (t) {
        return 1 - --t * t * t * t
      }, quarticInOut: function (t) {
        return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
      }, quinticIn: function (t) {
        return t * t * t * t * t
      }, quinticOut: function (t) {
        return --t * t * t * t * t + 1
      }, quinticInOut: function (t) {
        return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
      }, sinusoidalIn: function (t) {
        return 1 - Math.cos(t * Math.PI / 2)
      }, sinusoidalOut: function (t) {
        return Math.sin(t * Math.PI / 2)
      }, sinusoidalInOut: function (t) {
        return .5 * (1 - Math.cos(Math.PI * t))
      }, exponentialIn: function (t) {
        return 0 === t ? 0 : Math.pow(1024, t - 1)
      }, exponentialOut: function (t) {
        return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
      }, exponentialInOut: function (t) {
        return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (-Math.pow(2, -10 * (t - 1)) + 2)
      }, circularIn: function (t) {
        return 1 - Math.sqrt(1 - t * t)
      }, circularOut: function (t) {
        return Math.sqrt(1 - --t * t)
      }, circularInOut: function (t) {
        return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
      }, elasticIn: function (t) {
        var e, i = .1, n = .4;
        return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), -(i * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / n)))
      }, elasticOut: function (t) {
        var e, i = .1, n = .4;
        return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * t) * Math.sin(2 * (t - e) * Math.PI / n) + 1)
      }, elasticInOut: function (t) {
        var e, i = .1, n = .4;
        return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), (t *= 2) < 1 ? -.5 * i * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / n) : i * Math.pow(2, -10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / n) * .5 + 1)
      }, backIn: function (t) {
        var e = 1.70158;
        return t * t * ((e + 1) * t - e)
      }, backOut: function (t) {
        var e = 1.70158;
        return --t * t * ((e + 1) * t + e) + 1
      }, backInOut: function (t) {
        var e = 2.5949095;
        return (t *= 2) < 1 ? .5 * t * t * ((e + 1) * t - e) : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2)
      }, bounceIn: function (e) {
        return 1 - t.bounceOut(1 - e)
      }, bounceOut: function (t) {
        return 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
      }, bounceInOut: function (e) {
        return .5 > e ? .5 * t.bounceIn(2 * e) : .5 * t.bounceOut(2 * e - 1) + .5
      }
    };
    return t
  }),e("echarts/coord/axisDefault", [Pe, Le], function (t) {
    var e = t(Le), i = {
      show: !0,
      zlevel: 0,
      z: 0,
      inverse: !1,
      name: "",
      nameLocation: "end",
      nameRotate: null,
      nameTruncate: {maxWidth: null, ellipsis: "...", placeholder: "."},
      nameTextStyle: {},
      nameGap: 15,
      silent: !1,
      triggerEvent: !1,
      tooltip: {show: !1},
      axisLine: {show: !0, onZero: !0, lineStyle: {color: "#333", width: 1, type: "solid"}},
      axisTick: {show: !0, inside: !1, length: 5, lineStyle: {width: 1}},
      axisLabel: {show: !0, inside: !1, rotate: 0, margin: 8, textStyle: {fontSize: 12}},
      splitLine: {show: !0, lineStyle: {color: ["#ccc"], width: 1, type: "solid"}},
      splitArea: {show: !1, areaStyle: {color: ["rgba(250,250,250,0.3)", "rgba(200,200,200,0.3)"]}}
    }, n = e.merge({
      boundaryGap: !0,
      splitLine: {show: !1},
      axisTick: {alignWithLabel: !1, interval: "auto"},
      axisLabel: {interval: "auto"}
    }, i), r = e.merge({boundaryGap: [0, 0], splitNumber: 5}, i), a = e[Me]({
      scale: !0,
      min: "dataMin",
      max: "dataMax"
    }, r), o = e[Me]({}, r);
    return o.scale = !0, {categoryAxis: n, valueAxis: r, timeAxis: a, logAxis: o}
  }),e("zrender/contain/cubic", [Pe, "../core/curve"], function (t) {
    var e = t("../core/curve");
    return {
      containStroke: function (t, i, n, r, a, o, s, l, c, u, h) {
        if (0 === c)return !1;
        var d = c;
        if (h > i + d && h > r + d && h > o + d && h > l + d || i - d > h && r - d > h && o - d > h && l - d > h || u > t + d && u > n + d && u > a + d && u > s + d || t - d > u && n - d > u && a - d > u && s - d > u)return !1;
        var f = e.cubicProjectPoint(t, i, n, r, a, o, s, l, u, h, null);
        return d / 2 >= f
      }
    }
  }),e("zrender/contain/arc", [Pe, "./util"], function (t) {
    var e = t("./util").normalizeRadian, i = 2 * Math.PI;
    return {
      containStroke: function (t, n, r, a, o, s, l, c, u) {
        if (0 === l)return !1;
        var h = l;
        c -= t, u -= n;
        var d = Math.sqrt(c * c + u * u);
        if (d - h > r || r > d + h)return !1;
        if (Math.abs(a - o) % i < 1e-4)return !0;
        if (s) {
          var f = a;
          a = e(o), o = e(f)
        } else a = e(a), o = e(o);
        a > o && (o += i);
        var p = Math.atan2(u, c);
        return 0 > p && (p += i), p >= a && o >= p || p + i >= a && o >= p + i
      }
    }
  }),e("zrender/contain/line", [], function () {
    return {
      containStroke: function (t, e, i, n, r, a, o) {
        if (0 === r)return !1;
        var s = r, l = 0, c = t;
        if (o > e + s && o > n + s || e - s > o && n - s > o || a > t + s && a > i + s || t - s > a && i - s > a)return !1;
        if (t === i)return Math.abs(a - t) <= s / 2;
        l = (e - n) / (t - i), c = (t * n - i * e) / (t - i);
        var u = l * a - o + c, h = u * u / (l * l + 1);
        return s / 2 * s / 2 >= h
      }
    }
  }),e("zrender/contain/quadratic", [Pe, "../core/curve"], function (t) {
    var e = t("../core/curve");
    return {
      containStroke: function (t, i, n, r, a, o, s, l, c) {
        if (0 === s)return !1;
        var u = s;
        if (c > i + u && c > r + u && c > o + u || i - u > c && r - u > c && o - u > c || l > t + u && l > n + u && l > a + u || t - u > l && n - u > l && a - u > l)return !1;
        var h = e.quadraticProjectPoint(t, i, n, r, a, o, l, c, null);
        return u / 2 >= h
      }
    }
  }),e("zrender/contain/windingLine", [], function () {
    return function (t, e, i, n, r, a) {
      if (a > e && a > n || e > a && n > a)return 0;
      if (n === e)return 0;
      var o = e > n ? 1 : -1, s = (a - e) / (n - e);
      (1 === s || 0 === s) && (o = e > n ? .5 : -.5);
      var l = s * (i - t) + t;
      return l > r ? o : 0
    }
  }),e("zrender/contain/util", [Pe], function () {
    var t = 2 * Math.PI;
    return {
      normalizeRadian: function (e) {
        return e %= t, 0 > e && (e += t), e
      }
    }
  }),e("echarts/chart/helper/createListFromArray", [Pe, "../../data/List", "../../data/helper/completeDimensions", Le, "../../util/model", "../../CoordinateSystem"], function (t) {
    function e(t) {
      for (var e = 0; e < t[ne] && null == t[e];)e++;
      return t[e]
    }

    function i(t) {
      var i = e(t);
      return null != i && !u[Z](f(i))
    }

    function n(t, e, n) {
      t = t || [];
      var r = e.get(Te), a = v[r], s = d.get(r), m = a && a(t, e, n), y = m && m[S];
      y || (y = s && s[S] || ["x", "y"], y = c(y, t, y[g](["value"])));
      var x = m ? m.categoryIndex : -1, _ = new l(y, e), b = o(m, t), w = {}, M = x >= 0 && i(t) ? function (t, e, i, n) {
        return h.isDataItemOption(t) && (_.hasItemOption = !0), n === x ? i : p(f(t), y[n])
      } : function (t, e, i, n) {
        var r = f(t), a = p(r && r[n], y[n]);
        h.isDataItemOption(t) && (_.hasItemOption = !0);
        var o = m && m.categoryAxesModels;
        return o && o[e] && typeof a === ye && (w[e] = w[e] || o[e].getCategories(), a = u[V](w[e], a), 0 > a && !isNaN(a) && (a = +a)), a
      };
      return _.hasItemOption = !1, _.initData(t, b, M), _
    }

    function r(t) {
      return t !== s && "time" !== t
    }

    function a(t) {
      return t === s ? x : "time" === t ? "time" : "float"
    }

    function o(t, e) {
      var i, n = [], r = t && t[S][t.categoryIndex];
      if (r && (i = t.categoryAxesModels[r.name]), i) {
        var a = i.getCategories();
        if (a) {
          var o = e[ne];
          if (u[Z](e[0]) && e[0][ne] > 1) {
            n = [];
            for (var s = 0; o > s; s++)n[s] = a[e[s][t.categoryIndex || 0]]
          } else n = a.slice(0)
        }
      }
      return n
    }

    var l = t("../../data/List"), c = t("../../data/helper/completeDimensions"), u = t(Le), h = t("../../util/model"), d = t("../../CoordinateSystem"), f = h.getDataItemValue, p = h.converDataValue, v = {
      cartesian2d: function (t, e, i) {
        var n = i.getComponent("xAxis", e.get("xAxisIndex")), o = i.getComponent("yAxis", e.get("yAxisIndex")), l = n.get("type"), u = o.get("type"), h = [{
          name: "x",
          type: a(l),
          stackable: r(l)
        }, {name: "y", type: a(u), stackable: r(u)}], d = l === s, f = u === s;
        c(h, t, ["x", "y", "z"]);
        var p = {};
        return d && (p.x = n), f && (p.y = o), {dimensions: h, categoryIndex: d ? 0 : f ? 1 : -1, categoryAxesModels: p}
      }, polar: function (t, e, i) {
        var n = e.get("polarIndex") || 0, o = function (t) {
          return t.get("polarIndex") === n
        }, l = i.findComponents({mainType: "angleAxis", filter: o})[0], u = i.findComponents({
          mainType: "radiusAxis",
          filter: o
        })[0], h = u.get("type"), d = l.get("type"), f = [{name: "radius", type: a(h), stackable: r(h)}, {
          name: "angle",
          type: a(d),
          stackable: r(d)
        }], p = d === s, v = h === s;
        c(f, t, [T, "angle", "value"]);
        var m = {};
        return v && (m[T] = u), p && (m.angle = l), {
          dimensions: f,
          categoryIndex: p ? 1 : v ? 0 : -1,
          categoryAxesModels: m
        }
      }, geo: function (t) {
        return {dimensions: c([{name: "lng"}, {name: "lat"}], t, ["lng", "lat", "value"])}
      }
    };
    return n
  }),e("zrender/core/LRU", [Pe], function () {
    var t = function () {
      this.head = null, this.tail = null, this._len = 0
    }, e = t[xe];
    e.insert = function (t) {
      var e = new i(t);
      return this.insertEntry(e), e
    }, e.insertEntry = function (t) {
      this.head ? (this.tail.next = t, t.prev = this.tail, this.tail = t) : this.head = this.tail = t, this._len++
    }, e[ae] = function (t) {
      var e = t.prev, i = t.next;
      e ? e.next = i : this.head = i, i ? i.prev = e : this.tail = e, t.next = t.prev = null, this._len--
    }, e.len = function () {
      return this._len
    };
    var i = function (t) {
      this.value = t, this.next, this.prev
    }, n = function (e) {
      this._list = new t, this._map = {}, this._maxSize = e || 10
    }, r = n[xe];
    return r.put = function (t, e) {
      var i = this._list, n = this._map;
      if (null == n[t]) {
        var r = i.len();
        if (r >= this._maxSize && r > 0) {
          var a = i.head;
          i[ae](a), delete n[a.key]
        }
        var o = i.insert(e);
        o.key = t, n[t] = o
      }
    }, r.get = function (t) {
      var e = this._map[t], i = this._list;
      return null != e ? (e !== i.tail && (i[ae](e), i.insertEntry(e)), e.value) : void 0
    }, r.clear = function () {
      this._list.clear(), this._map = {}
    }, n
  }),e("echarts/data/DataDiffer", [Pe], function () {
    function t(t) {
      return t
    }

    function e(e, i, n, r) {
      this._old = e, this._new = i, this._oldKeyGetter = n || t, this._newKeyGetter = r || t
    }

    function i(t, e, i, n) {
      for (var r = 0; r < t[ne]; r++) {
        var a = n(t[r], r), o = e[a];
        null == o ? (i.push(a), e[a] = r) : (o[ne] || (e[a] = o = [o]), o.push(r))
      }
    }

    return e[xe] = {
      constructor: e, add: function (t) {
        return this._add = t, this
      }, update: function (t) {
        return this._update = t, this
      }, remove: function (t) {
        return this._remove = t, this
      }, execute: function () {
        var t, e = this._old, n = this._new, r = this._oldKeyGetter, a = this._newKeyGetter, o = {}, s = {}, l = [], c = [];
        for (i(e, o, l, r), i(n, s, c, a), t = 0; t < e[ne]; t++) {
          var u = l[t], h = s[u];
          if (null != h) {
            var d = h[ne];
            d ? (1 === d && (s[u] = null), h = h.unshift()) : s[u] = null, this._update && this._update(h, t)
          } else this._remove && this._remove(t)
        }
        for (var t = 0; t < c[ne]; t++) {
          var u = c[t];
          if (s.hasOwnProperty(u)) {
            var h = s[u];
            if (null == h)continue;
            if (h[ne])for (var f = 0, d = h[ne]; d > f; f++)this._add && this._add(h[f]); else this._add && this._add(h)
          }
        }
      }
    }, e
  }),e("zrender/Handler", [Pe, "./core/util", "./mixin/Draggable", "./mixin/Eventful"], function (t) {
    function e(t, e, i) {
      return {
        type: t,
        event: i,
        target: e,
        cancelBubble: !1,
        offsetX: i.zrX,
        offsetY: i.zrY,
        gestureEvent: i.gestureEvent,
        pinchX: i.pinchX,
        pinchY: i.pinchY,
        pinchScale: i.pinchScale,
        wheelDelta: i.zrDelta
      }
    }

    function i() {
    }

    function n(t, e, i) {
      if (t[t.rectHover ? "rectContain" : k](e, i)) {
        for (var n = t; n;) {
          if (n.silent || n.clipPath && !n.clipPath[k](e, i))return !1;
          n = n.parent
        }
        return !0
      }
      return !1
    }

    var r = t("./core/util"), a = t("./mixin/Draggable"), o = t("./mixin/Eventful");
    i[xe].dispose = function () {
    };
    var s = ["click", "dblclick", "mousewheel", J, "mouseup", "mousedown", "mousemove"], l = function (t, e, n) {
      o.call(this), this[de] = t, this.painter = e, n = n || new i, this.proxy = n, n.handler = this, this._hovered, this._lastTouchMoment, this._lastX, this._lastY, a.call(this), r.each(s, function (t) {
        n.on && n.on(t, this[t], this)
      }, this)
    };
    return l[xe] = {
      constructor: l, mousemove: function (t) {
        var e = t.zrX, i = t.zrY, n = this.findHover(e, i, null), r = this._hovered, a = this.proxy;
        this._hovered = n, a.setCursor && a.setCursor(n ? n.cursor : "default"), r && n !== r && r.__zr && this.dispatchToElement(r, J, t), this.dispatchToElement(n, "mousemove", t), n && n !== r && this.dispatchToElement(n, te, t)
      }, mouseout: function (t) {
        this.dispatchToElement(this._hovered, J, t), this.trigger("globalout", {event: t})
      }, resize: function () {
        this._hovered = null
      }, dispatch: function (t, e) {
        var i = this[t];
        i && i.call(this, e)
      }, dispose: function () {
        this.proxy.dispose(), this[de] = this.proxy = this.painter = null
      }, setCursorStyle: function (t) {
        var e = this.proxy;
        e.setCursor && e.setCursor(t)
      }, dispatchToElement: function (t, i, n) {
        for (var r = "on" + i, a = e(i, t, n), o = t; o && (o[r] && (a.cancelBubble = o[r].call(o, a)), o.trigger(i, a), o = o.parent, !a.cancelBubble););
        a.cancelBubble || (this.trigger(i, a), this.painter && this.painter.eachOtherLayer(function (t) {
          typeof t[r] == W && t[r].call(t, a), t.trigger && t.trigger(i, a)
        }))
      }, findHover: function (t, e, i) {
        for (var r = this[de].getDisplayList(), a = r[ne] - 1; a >= 0; a--)if (!r[a].silent && r[a] !== i && !r[a][he] && n(r[a], t, e))return r[a]
      }
    }, r.each(["click", "mousedown", "mouseup", "mousewheel", "dblclick"], function (t) {
      l[xe][t] = function (e) {
        var i = this.findHover(e.zrX, e.zrY, null);
        if ("mousedown" === t)this._downel = i, this._upel = i; else if ("mosueup" === t)this._upel = i; else if ("click" === t && this._downel !== this._upel)return;
        this.dispatchToElement(i, t, e)
      }
    }), r.mixin(l, o), r.mixin(l, a), l
  }),e("echarts/data/helper/completeDimensions", [Pe, Le], function (t) {
    function e(t, e, a, o) {
      if (!e)return t;
      var s = i(e[0]), l = n[Z](s) && s[ne] || 1;
      a = a || [], o = o || "extra";
      for (var c = 0; l > c; c++)if (!t[c]) {
        var u = a[c] || o + (c - a[ne]);
        t[c] = r(e, c) ? {type: "ordinal", name: u} : u
      }
      return t
    }

    function i(t) {
      return n[Z](t) ? t : n[oe](t) ? t.value : t
    }

    var n = t(Le), r = e.guessOrdinal = function (t, e) {
      for (var r = 0, a = t[ne]; a > r; r++) {
        var o = i(t[r]);
        if (!n[Z](o))return !1;
        var o = o[e];
        if (null != o && isFinite(o))return !1;
        if (n.isString(o) && "-" !== o)return !0
      }
      return !1
    };
    return e
  }),e("zrender/animation/Animation", [Pe, "../core/util", "../core/event", "./requestAnimationFrame", "./Animator"], function (t) {
    var e = t("../core/util"), i = t("../core/event").Dispatcher, n = t("./requestAnimationFrame"), r = t("./Animator"), a = function (t) {
      t = t || {}, this.stage = t.stage || {}, this.onframe = t.onframe || function () {
      }, this._clips = [], this._running = !1, this._time = 0, i.call(this)
    };
    return a[xe] = {
      constructor: a, addClip: function (t) {
        this._clips.push(t)
      }, addAnimator: function (t) {
        t[_] = this;
        for (var e = t.getClips(), i = 0; i < e[ne]; i++)this.addClip(e[i])
      }, removeClip: function (t) {
        var i = e[V](this._clips, t);
        i >= 0 && this._clips[ee](i, 1)
      }, removeAnimator: function (t) {
        for (var e = t.getClips(), i = 0; i < e[ne]; i++)this.removeClip(e[i]);
        t[_] = null
      }, _update: function () {
        for (var t = (new Date).getTime(), e = t - this._time, i = this._clips, n = i[ne], r = [], a = [], o = 0; n > o; o++) {
          var s = i[o], l = s.step(t);
          l && (r.push(l), a.push(s))
        }
        for (var o = 0; n > o;)i[o]._needsRemove ? (i[o] = i[n - 1], i.pop(), n--) : o++;
        n = r[ne];
        for (var o = 0; n > o; o++)a[o].fire(r[o]);
        this._time = t, this.onframe(e), this.trigger("frame", e), this.stage[se] && this.stage[se]()
      }, start: function () {
        function t() {
          e._running && (n(t), e._update())
        }

        var e = this;
        this._running = !0, this._time = (new Date).getTime(), n(t)
      }, stop: function () {
        this._running = !1
      }, clear: function () {
        this._clips = []
      }, animate: function (t, e) {
        e = e || {};
        var i = new r(t, e.loop, e.getter, e.setter);
        return i
      }
    }, e.mixin(a, i), a
  }),e("zrender/graphic/helper/poly", [Pe, "./smoothSpline", "./smoothBezier"], function (t) {
    var e = t("./smoothSpline"), i = t("./smoothBezier");
    return {
      buildPath: function (t, r, a) {
        var o = r.points, s = r.smooth;
        if (o && o[ne] >= 2) {
          if (s && "spline" !== s) {
            var l = i(o, s, a, r.smoothConstraint);
            t[n](o[0][0], o[0][1]);
            for (var c = o[ne], u = 0; (a ? c : c - 1) > u; u++) {
              var h = l[2 * u], d = l[2 * u + 1], f = o[(u + 1) % c];
              t.bezierCurveTo(h[0], h[1], d[0], d[1], f[0], f[1])
            }
          } else {
            "spline" === s && (o = e(o, a)), t[n](o[0][0], o[0][1]);
            for (var u = 1, p = o[ne]; p > u; u++)t.lineTo(o[u][0], o[u][1])
          }
          a && t.closePath()
        }
      }
    }
  }),e("zrender/Storage", [Pe, "./core/util", "./core/env", "./container/Group", "./core/timsort"], function (t) {
    function e(t, e) {
      return t[j] === e[j] ? t.z === e.z ? t.z2 - e.z2 : t.z - e.z : t[j] - e[j]
    }

    var n = t("./core/util"), r = t("./core/env"), a = t("./container/Group"), o = t("./core/timsort"), s = function () {
      this._elements = {}, this._roots = [], this._displayList = [], this._displayListLen = 0
    };
    return s[xe] = {
      constructor: s, traverse: function (t, e) {
        for (var i = 0; i < this._roots[ne]; i++)this._roots[i].traverse(t, e)
      }, getDisplayList: function (t, e) {
        return e = e || !1, t && this.updateDisplayList(e), this._displayList
      }, updateDisplayList: function (t) {
        this._displayListLen = 0;
        for (var i = this._roots, n = this._displayList, a = 0, s = i[ne]; s > a; a++)this._updateAndAddDisplayable(i[a], null, t);
        n[ne] = this._displayListLen, r[fe] && o(n, e)
      }, _updateAndAddDisplayable: function (t, e, n) {
        if (!t[he] || n) {
          t.beforeUpdate(), t[i] && t[se](), t.afterUpdate();
          var r = t.clipPath;
          if (r && (r.parent = t, r.updateTransform(), e ? (e = e.slice(), e.push(r)) : e = [r]), t.isGroup) {
            for (var a = t._children, o = 0; o < a[ne]; o++) {
              var s = a[o];
              t[i] && (s[i] = !0), this._updateAndAddDisplayable(s, e, n)
            }
            t[i] = !1
          } else t.__clipPaths = e, this._displayList[this._displayListLen++] = t
        }
      }, addRoot: function (t) {
        this._elements[t.id] || (t instanceof a && t.addChildrenToStorage(this), this.addToMap(t), this._roots.push(t))
      }, delRoot: function (t) {
        if (null == t) {
          for (var e = 0; e < this._roots[ne]; e++) {
            var i = this._roots[e];
            i instanceof a && i.delChildrenFromStorage(this)
          }
          return this._elements = {}, this._roots = [], this._displayList = [], void(this._displayListLen = 0)
        }
        if (t instanceof Array)for (var e = 0, r = t[ne]; r > e; e++)this.delRoot(t[e]); else {
          var o;
          o = typeof t == ye ? this._elements[t] : t;
          var s = n[V](this._roots, o);
          s >= 0 && (this.delFromMap(o.id), this._roots[ee](s, 1), o instanceof a && o.delChildrenFromStorage(this))
        }
      }, addToMap: function (t) {
        return t instanceof a && (t.__storage = this), t.dirty(), this._elements[t.id] = t, this
      }, get: function (t) {
        return this._elements[t]
      }, delFromMap: function (t) {
        var e = this._elements, i = e[t];
        return i && (delete e[t], i instanceof a && (i.__storage = null)), this
      }, dispose: function () {
        this._elements = this._renderList = this._roots = null
      }, displayableSortFunc: e
    }, s
  }),e("zrender/dom/HandlerProxy", [Pe, "../core/event", "../core/util", "../mixin/Eventful", "../core/env", "../core/GestureMgr"], function (t) {
    function e(t) {
      return "mousewheel" === t && u.browser.firefox ? "DOMMouseScroll" : t
    }

    function i(t, e, i) {
      var n = t._gestureMgr;
      "start" === i && n.clear();
      var r = n.recognize(e, t.handler.findHover(e.zrX, e.zrY, null), t.dom);
      if ("end" === i && n.clear(), r) {
        var a = r.type;
        e.gestureEvent = a, t.handler.dispatchToElement(r[K], a, r.event)
      }
    }

    function n(t) {
      t._touching = !0, clearTimeout(t._touchTimer), t._touchTimer = setTimeout(function () {
        t._touching = !1
      }, 700)
    }

    function r() {
      return u.touchEventsSupported
    }

    function a(t) {
      function e(t, e) {
        return function () {
          return e._touching ? void 0 : t.apply(e, arguments)
        }
      }

      for (var i = 0; i < y[ne]; i++) {
        var n = y[i];
        t._handlers[n] = l.bind(x[n], t)
      }
      for (var i = 0; i < m[ne]; i++) {
        var n = m[i];
        t._handlers[n] = e(x[n], t)
      }
    }

    function o(t) {
      function i(i, n) {
        l.each(i, function (i) {
          d(t, e(i), n._handlers[i])
        }, n)
      }

      c.call(this), this.dom = t, this._touching = !1, this._touchTimer, this._gestureMgr = new h, this._handlers = {}, a(this), r() && i(y, this), i(m, this)
    }

    var s = t("../core/event"), l = t("../core/util"), c = t("../mixin/Eventful"), u = t("../core/env"), h = t("../core/GestureMgr"), d = s.addEventListener, f = s.removeEventListener, p = s.normalizeEvent, v = 300, m = ["click", "dblclick", "mousewheel", J, "mouseup", "mousedown", "mousemove"], y = ["touchstart", "touchend", "touchmove"], x = {
      mousemove: function (t) {
        t = p(this.dom, t), this.trigger("mousemove", t)
      }, mouseout: function (t) {
        t = p(this.dom, t);
        var e = t.toElement || t.relatedTarget;
        if (e != this.dom)for (; e && 9 != e.nodeType;) {
          if (e === this.dom)return;
          e = e.parentNode
        }
        this.trigger(J, t)
      }, touchstart: function (t) {
        t = p(this.dom, t), this._lastTouchMoment = new Date, i(this, t, "start"), x.mousemove.call(this, t), x.mousedown.call(this, t), n(this)
      }, touchmove: function (t) {
        t = p(this.dom, t), i(this, t, "change"), x.mousemove.call(this, t), n(this)
      }, touchend: function (t) {
        t = p(this.dom, t), i(this, t, "end"), x.mouseup.call(this, t), +new Date - this._lastTouchMoment < v && x.click.call(this, t), n(this)
      }
    };
    l.each(["click", "mousedown", "mouseup", "mousewheel", "dblclick"], function (t) {
      x[t] = function (e) {
        e = p(this.dom, e), this.trigger(t, e)
      }
    });
    var _ = o[xe];
    return _.dispose = function () {
      for (var t = m[g](y), i = 0; i < t[ne]; i++) {
        var n = t[i];
        f(this.dom, e(n), this._handlers[n])
      }
    }, _.setCursor = function (t) {
      this.dom.style.cursor = t || "default"
    }, l.mixin(o, c), o
  }),e("zrender/mixin/Draggable", [Pe], function () {
    function t() {
      this.on("mousedown", this._dragStart, this), this.on("mousemove", this._drag, this), this.on("mouseup", this._dragEnd, this), this.on("globalout", this._dragEnd, this)
    }

    return t[xe] = {
      constructor: t, _dragStart: function (t) {
        var e = t[K];
        e && e.draggable && (this._draggingTarget = e, e.dragging = !0, this._x = t.offsetX, this._y = t.offsetY, this.dispatchToElement(e, "dragstart", t.event))
      }, _drag: function (t) {
        var e = this._draggingTarget;
        if (e) {
          var i = t.offsetX, n = t.offsetY, r = i - this._x, a = n - this._y;
          this._x = i, this._y = n, e.drift(r, a, t), this.dispatchToElement(e, "drag", t.event);
          var o = this.findHover(i, n, e), s = this._dropTarget;
          this._dropTarget = o, e !== o && (s && o !== s && this.dispatchToElement(s, "dragleave", t.event), o && o !== s && this.dispatchToElement(o, "dragenter", t.event))
        }
      }, _dragEnd: function (t) {
        var e = this._draggingTarget;
        e && (e.dragging = !1), this.dispatchToElement(e, "dragend", t.event), this._dropTarget && this.dispatchToElement(this._dropTarget, "drop", t.event), this._draggingTarget = null, this._dropTarget = null
      }
    }, t
  }),e("echarts/chart/bar/barItemStyle", [Pe, "../../model/mixin/makeStyleMapper"], function (t) {
    var e = t("../../model/mixin/makeStyleMapper")([["fill", "color"], [c, "borderColor"], [u, "borderWidth"], [c, "barBorderColor"], [u, "barBorderWidth"], [I], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]);
    return {
      getBarItemStyle: function (t) {
        var i = e.call(this, t);
        if (this.getBorderLineDash) {
          var n = this.getBorderLineDash();
          n && (i.lineDash = n)
        }
        return i
      }
    }
  }),e("zrender/Painter", [Pe, "./config", "./core/util", "./core/log", "./core/BoundingRect", "./core/timsort", "./Layer", "./animation/requestAnimationFrame", "./graphic/Image"], function (t) {
    function e(t) {
      return parseInt(t, 10)
    }

    function n(t) {
      return t ? t.isBuildin ? !0 : typeof t[ge] !== W || typeof t.refresh !== W ? !1 : !0 : !1
    }

    function a(t) {
      t.__unusedCount++
    }

    function o(t) {
      1 == t.__unusedCount && t.clear()
    }

    function s(t, e, i) {
      return b.copy(t[O]()), t[r] && b[h](t[r]), w.width = e, w[ce] = i, !b.intersect(w)
    }

    function l(t, e) {
      if (t == e)return !1;
      if (!t || !e || t[ne] !== e[ne])return !0;
      for (var i = 0; i < t[ne]; i++)if (t[i] !== e[i])return !0
    }

    function c(t, e) {
      for (var i = 0; i < t[ne]; i++) {
        var n, a = t[i];
        a[r] && (n = a[r], e[r](n[0], n[1], n[2], n[3], n[4], n[5]));
        var o = a.path;
        o.beginPath(e), a.buildPath(o, a.shape), e.clip(), a[r] && (n = a.invTransform, e[r](n[0], n[1], n[2], n[3], n[4], n[5]))
      }
    }

    function u(t, e) {
      var i = document[y]("div"), n = i.style;
      return n[z] = "relative", n.overflow = "hidden", n.width = t + "px", n[ce] = e + "px", i
    }

    var d = t("./config"), f = t("./core/util"), p = t("./core/log"), v = t("./core/BoundingRect"), m = t("./core/timsort"), g = t("./Layer"), x = t("./animation/requestAnimationFrame"), _ = 5, b = new v(0, 0, 0, 0), w = new v(0, 0, 0, 0), S = function (t, e, i) {
      var n = !t.nodeName || "CANVAS" === t.nodeName.toUpperCase();
      i = i || {}, this.dpr = i.devicePixelRatio || d.devicePixelRatio, this._singleCanvas = n, this.root = t;
      var r = t.style;
      r && (r["-webkit-tap-highlight-color"] = "transparent", r["-webkit-user-select"] = r["user-select"] = r["-webkit-touch-callout"] = "none", t.innerHTML = ""), this[de] = e;
      var a = this._zlevelList = [], o = this._layers = {};
      if (this._layerConfig = {}, n) {
        var s = t.width, l = t[ce];
        this._width = s, this._height = l;
        var c = new g(t, this, 1);
        c.initContext(), o[0] = c, a.push(0)
      } else {
        this._width = this._getWidth(), this._height = this._getHeight();
        var h = this._domRoot = u(this._width, this._height);
        t.appendChild(h)
      }
      this.pathToImage = this._createPathToImage(), this._progressiveLayers = [], this._hoverlayer, this._hoverElements = []
    };
    return S[xe] = {
      constructor: S, isSingleCanvas: function () {
        return this._singleCanvas
      }, getViewportRoot: function () {
        return this._singleCanvas ? this._layers[0].dom : this._domRoot
      }, refresh: function (t) {
        var e = this[de].getDisplayList(!0), i = this._zlevelList;
        this._paintList(e, t);
        for (var n = 0; n < i[ne]; n++) {
          var r = i[n], a = this._layers[r];
          !a.isBuildin && a.refresh && a.refresh()
        }
        return this.refreshHover(), this._progressiveLayers[ne] && this._startProgessive(), this
      }, addHover: function (t, e) {
        if (!t.__hoverMir) {
          var i = new t.constructor({style: t.style, shape: t.shape});
          i.__from = t, t.__hoverMir = i, i[X](e), this._hoverElements.push(i)
        }
      }, removeHover: function (t) {
        var e = t.__hoverMir, i = this._hoverElements, n = f[V](i, e);
        n >= 0 && i[ee](n, 1), t.__hoverMir = null
      }, clearHover: function () {
        for (var t = this._hoverElements, e = 0; e < t[ne]; e++) {
          var i = t[e].__from;
          i && (i.__hoverMir = null)
        }
        t[ne] = 0
      }, refreshHover: function () {
        var t = this._hoverElements, e = t[ne], i = this._hoverlayer;
        if (i && i.clear(), e) {
          m(t, this[de].displayableSortFunc), i || (i = this._hoverlayer = this.getLayer(1e5));
          var n = {};
          i.ctx.save();
          for (var a = 0; e > a;) {
            var o = t[a], s = o.__from;
            s && s.__zr ? (a++, s.invisible || (o[r] = s[r], o.invTransform = s.invTransform, o.__clipPaths = s.__clipPaths, this._doPaintEl(o, i, !0, n))) : (t[ee](a, 1), s.__hoverMir = null, e--)
          }
          i.ctx.restore()
        }
      }, _startProgessive: function () {
        function t() {
          i === e._progressiveToken && e[de] && (e._doPaintList(e[de].getDisplayList()), e._furtherProgressive ? (e._progress++, x(t)) : e._progressiveToken = -1)
        }

        var e = this;
        if (e._furtherProgressive) {
          var i = e._progressiveToken = +new Date;
          e._progress++, x(t)
        }
      }, _clearProgressive: function () {
        this._progressiveToken = -1, this._progress = 0, f.each(this._progressiveLayers, function (t) {
          t[i] && t.clear()
        })
      }, _paintList: function (t, e) {
        null == e && (e = !1), this._updateLayerStatus(t), this._clearProgressive(), this.eachBuildinLayer(a), this._doPaintList(t, e), this.eachBuildinLayer(o)
      }, _doPaintList: function (t, e) {
        function n(t) {
          o.save(), o.globalAlpha = 1, o.shadowBlur = 0, r[i] = !0, o.drawImage(t.dom, 0, 0, h, d), o.restore(), r.ctx.restore()
        }

        for (var r, a, o, s, l, c, u = 0, h = this._width, d = this._height, v = this._progress, m = 0, g = t[ne]; g > m; m++) {
          var y = t[m], x = this._singleCanvas ? 0 : y[j], b = y.__frame;
          if (0 > b && l && (n(l), l = null), a !== x && (o && o.restore(), s = {}, a = x, r = this.getLayer(a), r.isBuildin || p("ZLevel " + a + " has been used by unkown layer " + r.id), o = r.ctx, o.save(), r.__unusedCount = 0, (r[i] || e) && r.clear()), r[i] || e) {
            if (b >= 0) {
              if (!l) {
                if (l = this._progressiveLayers[Math.min(u++, _ - 1)], l.ctx.save(), l.renderScope = {}, l && l.__progress > l.__maxProgress) {
                  m = l.__nextIdxNotProg - 1;
                  continue
                }
                c = l.__progress, l[i] || (v = c), l.__progress = v + 1
              }
              b === v && this._doPaintEl(y, l, !0, l.renderScope)
            } else this._doPaintEl(y, r, e, s);
            y[i] = !1
          }
        }
        l && n(l), o && o.restore(), this._furtherProgressive = !1, f.each(this._progressiveLayers, function (t) {
          t.__maxProgress >= t.__progress && (this._furtherProgressive = !0)
        }, this)
      }, _doPaintEl: function (t, e, n, r) {
        var a = e.ctx;
        if ((e[i] || n) && !t.invisible && 0 !== t.style[I] && t.scale[0] && t.scale[1] && (!t.culling || !s(t, this._width, this._height))) {
          var o = t.__clipPaths;
          (r.prevClipLayer !== e || l(o, r.prevElClipPaths)) && (r.prevElClipPaths && (r.prevClipLayer.ctx.restore(), r.prevClipLayer = r.prevElClipPaths = null, r.prevEl = null), o && (a.save(), c(o, a), r.prevClipLayer = e, r.prevElClipPaths = o)), t.beforeBrush && t.beforeBrush(a), t.brush(a, r.prevEl || null), r.prevEl = t, t.afterBrush && t.afterBrush(a)
        }
      }, getLayer: function (t) {
        if (this._singleCanvas)return this._layers[0];
        var e = this._layers[t];
        return e || (e = new g("zr_" + t, this, this.dpr), e.isBuildin = !0, this._layerConfig[t] && f.merge(e, this._layerConfig[t], !0), this.insertLayer(t, e), e.initContext()), e
      }, insertLayer: function (t, e) {
        var i = this._layers, r = this._zlevelList, a = r[ne], o = null, s = -1, l = this._domRoot;
        if (i[t])return void p("ZLevel " + t + " has been used already");
        if (!n(e))return void p("Layer of zlevel " + t + " is not valid");
        if (a > 0 && t > r[0]) {
          for (s = 0; a - 1 > s && !(r[s] < t && r[s + 1] > t); s++);
          o = i[r[s]]
        }
        if (r[ee](s + 1, 0, t), o) {
          var c = o.dom;
          c.nextSibling ? l.insertBefore(e.dom, c.nextSibling) : l.appendChild(e.dom)
        } else l.firstChild ? l.insertBefore(e.dom, l.firstChild) : l.appendChild(e.dom);
        i[t] = e
      }, eachLayer: function (t, e) {
        var i, n, r = this._zlevelList;
        for (n = 0; n < r[ne]; n++)i = r[n], t.call(e, this._layers[i], i)
      }, eachBuildinLayer: function (t, e) {
        var i, n, r, a = this._zlevelList;
        for (r = 0; r < a[ne]; r++)n = a[r], i = this._layers[n], i.isBuildin && t.call(e, i, n)
      }, eachOtherLayer: function (t, e) {
        var i, n, r, a = this._zlevelList;
        for (r = 0; r < a[ne]; r++)n = a[r], i = this._layers[n], i.isBuildin || t.call(e, i, n)
      }, getLayers: function () {
        return this._layers
      }, _updateLayerStatus: function (t) {
        var e = this._layers, n = this._progressiveLayers, r = {}, a = {};
        this.eachBuildinLayer(function (t, e) {
          r[e] = t.elCount, t.elCount = 0, t[i] = !1
        }), f.each(n, function (t, e) {
          a[e] = t.elCount, t.elCount = 0, t[i] = !1
        });
        for (var o, s, l = 0, c = 0, u = 0, h = t[ne]; h > u; u++) {
          var d = t[u], p = this._singleCanvas ? 0 : d[j], v = e[p], m = d.progressive;
          if (v && (v.elCount++, v[i] = v[i] || d[i]), m >= 0) {
            s !== m && (s = m, c++);
            var y = d.__frame = c - 1;
            if (!o) {
              var x = Math.min(l, _ - 1);
              o = n[x], o || (o = n[x] = new g("progressive", this, this.dpr), o.initContext()), o.__maxProgress = 0
            }
            o[i] = o[i] || d[i], o.elCount++, o.__maxProgress = Math.max(o.__maxProgress, y), o.__maxProgress >= o.__progress && (v[i] = !0)
          } else d.__frame = -1, o && (o.__nextIdxNotProg = u, l++, o = null)
        }
        o && (l++, o.__nextIdxNotProg = u), this.eachBuildinLayer(function (t, e) {
          r[e] !== t.elCount && (t[i] = !0)
        }), n[ne] = Math.min(l, _), f.each(n, function (t, e) {
          a[e] !== t.elCount && (d[i] = !0), t[i] && (t.__progress = 0)
        })
      }, clear: function () {
        return this.eachBuildinLayer(this._clearLayer), this
      }, _clearLayer: function (t) {
        t.clear()
      }, configLayer: function (t, e) {
        if (e) {
          var i = this._layerConfig;
          i[t] ? f.merge(i[t], e, !0) : i[t] = e;
          var n = this._layers[t];
          n && f.merge(n, i[t], !0)
        }
      }, delLayer: function (t) {
        var e = this._layers, i = this._zlevelList, n = e[t];
        n && (n.dom.parentNode.removeChild(n.dom), delete e[t], i[ee](f[V](i, t), 1))
      }, resize: function (t, e) {
        var i = this._domRoot;
        if (i.style.display = "none", t = t || this._getWidth(), e = e || this._getHeight(), i.style.display = "", this._width != t || e != this._height) {
          i.style.width = t + "px", i.style[ce] = e + "px";
          for (var n in this._layers)this._layers[n][ge](t, e);
          this.refresh(!0)
        }
        return this._width = t, this._height = e, this
      }, clearLayer: function (t) {
        var e = this._layers[t];
        e && e.clear()
      }, dispose: function () {
        this.root.innerHTML = "", this.root = this[de] = this._domRoot = this._layers = null
      }, getRenderedCanvas: function (t) {
        if (t = t || {}, this._singleCanvas)return this._layers[0].dom;
        var e = new g("image", this, t.pixelRatio || this.dpr);
        e.initContext(), e.clearColor = t.backgroundColor, e.clear();
        for (var i = this[de].getDisplayList(!0), n = {}, r = 0; r < i[ne]; r++) {
          var a = i[r];
          this._doPaintEl(a, e, !0, n)
        }
        return e.dom
      }, getWidth: function () {
        return this._width
      }, getHeight: function () {
        return this._height
      }, _getWidth: function () {
        var t = this.root, i = document.defaultView.getComputedStyle(t);
        return (t.clientWidth || e(i.width) || e(t.style.width)) - (e(i.paddingLeft) || 0) - (e(i.paddingRight) || 0) | 0
      }, _getHeight: function () {
        var t = this.root, i = document.defaultView.getComputedStyle(t);
        return (t.clientHeight || e(i[ce]) || e(t.style[ce])) - (e(i.paddingTop) || 0) - (e(i.paddingBottom) || 0) | 0
      }, _pathToImage: function (e, i, n, r, a) {
        var o = document[y]("canvas"), s = o.getContext("2d");
        o.width = n * a, o[ce] = r * a, s.clearRect(0, 0, n * a, r * a);
        var l = {position: i[z], rotation: i.rotation, scale: i.scale};
        i[z] = [0, 0, 0], i.rotation = 0, i.scale = [1, 1], i && i.brush(s);
        var c = t("./graphic/Image"), u = new c({id: e, style: {x: 0, y: 0, image: o}});
        return null != l[z] && (u[z] = i[z] = l[z]), null != l.rotation && (u.rotation = i.rotation = l.rotation), null != l.scale && (u.scale = i.scale = l.scale), u
      }, _createPathToImage: function () {
        var t = this;
        return function (e, i, n, r) {
          return t._pathToImage(e, i, n, r, t.dpr)
        }
      }
    }, S
  }),e("zrender/graphic/helper/smoothBezier", [Pe, "../../core/vector"], function (t) {
    var e = t("../../core/vector"), i = e.min, n = e.max, r = e.scale, a = e.distance, o = e.add;
    return function (t, s, l, c) {
      var u, h, d, f, p = [], v = [], m = [], g = [];
      if (c) {
        d = [1 / 0, 1 / 0], f = [-1 / 0, -1 / 0];
        for (var y = 0, x = t[ne]; x > y; y++)i(d, d, t[y]), n(f, f, t[y]);
        i(d, d, c[0]), n(f, f, c[1])
      }
      for (var y = 0, x = t[ne]; x > y; y++) {
        var _ = t[y];
        if (l)u = t[y ? y - 1 : x - 1], h = t[(y + 1) % x]; else {
          if (0 === y || y === x - 1) {
            p.push(e.clone(t[y]));
            continue
          }
          u = t[y - 1], h = t[y + 1]
        }
        e.sub(v, h, u), r(v, v, s);
        var b = a(_, u), w = a(_, h), S = b + w;
        0 !== S && (b /= S, w /= S), r(m, v, -b), r(g, v, w);
        var M = o([], _, m), T = o([], _, g);
        c && (n(M, M, d), i(M, M, f), n(T, T, d), i(T, T, f)), p.push(M), p.push(T)
      }
      return l && p.push(p.shift()), p
    }
  }),e("zrender/graphic/helper/smoothSpline", [Pe, "../../core/vector"], function (t) {
    function e(t, e, i, n, r, a, o) {
      var s = .5 * (i - t), l = .5 * (n - e);
      return (2 * (e - i) + s + l) * o + (-3 * (e - i) - 2 * s - l) * a + s * r + e
    }

    var i = t("../../core/vector");
    return function (t, n) {
      for (var r = t[ne], a = [], o = 0, s = 1; r > s; s++)o += i.distance(t[s - 1], t[s]);
      var l = o / 2;
      l = r > l ? r : l;
      for (var s = 0; l > s; s++) {
        var c, u, h, d = s / (l - 1) * (n ? r : r - 1), f = Math.floor(d), p = d - f, v = t[f % r];
        n ? (c = t[(f - 1 + r) % r], u = t[(f + 1) % r], h = t[(f + 2) % r]) : (c = t[0 === f ? f : f - 1], u = t[f > r - 2 ? r - 1 : f + 1], h = t[f > r - 3 ? r - 1 : f + 2]);
        var m = p * p, g = p * m;
        a.push([e(c[0], v[0], u[0], h[0], p, m, g), e(c[1], v[1], u[1], h[1], p, m, g)])
      }
      return a
    }
  }),e("zrender/animation/requestAnimationFrame", [Pe], function () {
    return "undefined" != typeof window && (window.requestAnimationFrame || window.msRequestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (t) {
        setTimeout(t, 16)
      }
  }),e("zrender/core/event", [Pe, "../mixin/Eventful"], function (t) {
    function e(t) {
      return t.getBoundingClientRect ? t.getBoundingClientRect() : {left: 0, top: 0}
    }

    function i(t, i, n) {
      var r = e(t);
      return n = n || {}, n.zrX = i.clientX - r.left, n.zrY = i.clientY - r.top, n
    }

    function n(t, e) {
      if (e = e || window.event, null != e.zrX)return e;
      var n = e.type, r = n && n[V]("touch") >= 0;
      if (r) {
        var a = "touchend" != n ? e.targetTouches[0] : e.changedTouches[0];
        a && i(t, a, e)
      } else i(t, e, e), e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
      return e
    }

    function r(t, e, i) {
      s ? t.addEventListener(e, i) : t.attachEvent("on" + e, i)
    }

    function a(t, e, i) {
      s ? t.removeEventListener(e, i) : t.detachEvent("on" + e, i)
    }

    var o = t("../mixin/Eventful"), s = "undefined" != typeof window && !!window.addEventListener, l = s ? function (t) {
      t.preventDefault(), t.stopPropagation(), t.cancelBubble = !0
    } : function (t) {
      t.returnValue = !1, t.cancelBubble = !0
    };
    return {clientToLocal: i, normalizeEvent: n, addEventListener: r, removeEventListener: a, stop: l, Dispatcher: o}
  }),e("zrender/graphic/helper/roundRect", [Pe], function () {
    return {
      buildPath: function (t, e) {
        var i, r, a, o, s = e.x, l = e.y, c = e.width, u = e[ce], h = e.r;
        0 > c && (s += c, c = -c), 0 > u && (l += u, u = -u), typeof h === q ? i = r = a = o = h : h instanceof Array ? 1 === h[ne] ? i = r = a = o = h[0] : 2 === h[ne] ? (i = a = h[0], r = o = h[1]) : 3 === h[ne] ? (i = h[0], r = o = h[1], a = h[2]) : (i = h[0], r = h[1], a = h[2], o = h[3]) : i = r = a = o = 0;
        var d;
        i + r > c && (d = i + r, i *= c / d, r *= c / d), a + o > c && (d = a + o, a *= c / d, o *= c / d), r + a > u && (d = r + a, r *= u / d, a *= u / d), i + o > u && (d = i + o, i *= u / d, o *= u / d), t[n](s + i, l), t.lineTo(s + c - r, l), 0 !== r && t.quadraticCurveTo(s + c, l, s + c, l + r), t.lineTo(s + c, l + u - a), 0 !== a && t.quadraticCurveTo(s + c, l + u, s + c - a, l + u), t.lineTo(s + o, l + u), 0 !== o && t.quadraticCurveTo(s, l + u, s, l + u - o), t.lineTo(s, l + i), 0 !== i && t.quadraticCurveTo(s, l, s + i, l)
      }
    }
  }),e("zrender/core/GestureMgr", [Pe, "./event"], function (t) {
    function e(t) {
      var e = t[1][0] - t[0][0], i = t[1][1] - t[0][1];
      return Math.sqrt(e * e + i * i)
    }

    function i(t) {
      return [(t[0][0] + t[1][0]) / 2, (t[0][1] + t[1][1]) / 2]
    }

    var n = t("./event"), r = function () {
      this._track = []
    };
    r[xe] = {
      constructor: r, recognize: function (t, e, i) {
        return this._doTrack(t, e, i), this._recognize(t)
      }, clear: function () {
        return this._track[ne] = 0, this
      }, _doTrack: function (t, e, i) {
        var r = t.touches;
        if (r) {
          for (var a = {points: [], touches: [], target: e, event: t}, o = 0, s = r[ne]; s > o; o++) {
            var l = r[o], c = n.clientToLocal(i, l);
            a.points.push([c.zrX, c.zrY]), a.touches.push(l)
          }
          this._track.push(a)
        }
      }, _recognize: function (t) {
        for (var e in a)if (a.hasOwnProperty(e)) {
          var i = a[e](this._track, t);
          if (i)return i
        }
      }
    };
    var a = {
      pinch: function (t, n) {
        var r = t[ne];
        if (r) {
          var a = (t[r - 1] || {}).points, o = (t[r - 2] || {}).points || a;
          if (o && o[ne] > 1 && a && a[ne] > 1) {
            var s = e(a) / e(o);
            !isFinite(s) && (s = 1), n.pinchScale = s;
            var l = i(a);
            return n.pinchX = l[0], n.pinchY = l[1], {type: "pinch", target: t[0][K], event: n}
          }
        }
      }
    };
    return r
  }),e("echarts/component/axis/AxisView", [Pe, Le, A, "./AxisBuilder", p], function (t) {
    function e(t, e) {
      function i(t) {
        var e = n.getAxis(t);
        return e.toGlobalCoord(e[b](0))
      }

      var n = t[Te], r = e.axis, a = {}, o = r[z], s = r.onZero ? "onZero" : o, c = r.dim, u = n.getRect(), h = [u.x, u.x + u.width, u.y, u.y + u[ce]], d = e.get("offset") || 0, f = {
        x: {
          top: h[2] - d,
          bottom: h[3] + d
        }, y: {left: h[0] - d, right: h[1] + d}
      };
      f.x.onZero = Math.max(Math.min(i("y"), f.x[ue]), f.x.top), f.y.onZero = Math.max(Math.min(i("x"), f.y.right), f.y.left), a[z] = ["y" === c ? f.y[s] : h[0], "x" === c ? f.x[s] : h[3]], a.rotation = Math.PI / 2 * ("x" === c ? 0 : 1);
      var p = {top: -1, bottom: 1, left: -1, right: 1};
      a.labelDirection = a.tickDirection = a.nameDirection = p[o], r.onZero && (a.labelOffset = f[c][o] - f[c].onZero), e[me]("axisTick").get(l) && (a.tickDirection = -a.tickDirection), e[me]("axisLabel").get(l) && (a.labelDirection = -a.labelDirection);
      var v = e[me]("axisLabel").get("rotate");
      return a.labelRotation = "top" === s ? -v : v, a.labelInterval = r.getLabelInterval(), a.z2 = 1, a
    }

    var i = t(Le), n = t(A), r = t("./AxisBuilder"), a = r.ifIgnoreOnTick, o = r.getInterval, s = ["axisLine", "axisLabel", "axisTick", "axisName"], c = ["splitArea", "splitLine"], u = t(p)[Ae]({
      type: "axis",
      render: function (t, a) {
        this.group[Ce]();
        var o = this._axisGroup;
        if (this._axisGroup = new n.Group, this.group.add(this._axisGroup), t.get("show")) {
          var l = a.getComponent("grid", t.get("gridIndex")), u = e(l, t), h = new r(t, u);
          i.each(s, h.add, h), this._axisGroup.add(h.getGroup()), i.each(c, function (e) {
            t.get(e + ".show") && this["_" + e](t, l, u.labelInterval)
          }, this), n.groupTransition(o, this._axisGroup, t)
        }
      },
      _splitLine: function (t, e, r) {
        var s = t.axis, l = t[me]("splitLine"), c = l[me]("lineStyle"), u = c.get("color"), h = o(l, r);
        u = i[Z](u) ? u : [u];
        for (var d = e[Te].getRect(), f = s.isHorizontal(), p = 0, v = s.getTicksCoords(), m = s.scale[P](), g = [], y = [], x = c.getLineStyle(), _ = 0; _ < v[ne]; _++)if (!a(s, _, h)) {
          var b = s.toGlobalCoord(v[_]);
          f ? (g[0] = b, g[1] = d.y, y[0] = b, y[1] = d.y + d[ce]) : (g[0] = d.x, g[1] = b, y[0] = d.x + d.width, y[1] = b);
          var w = p++ % u[ne];
          this._axisGroup.add(new n.Line(n.subPixelOptimizeLine({
            anid: "line_" + m[_],
            shape: {x1: g[0], y1: g[1], x2: y[0], y2: y[1]},
            style: i[Me]({stroke: u[w]}, x),
            silent: !0
          })))
        }
      },
      _splitArea: function (t, e, r) {
        var s = t.axis, l = t[me]("splitArea"), c = l[me]("areaStyle"), u = c.get("color"), h = e[Te].getRect(), d = s.getTicksCoords(), f = s.scale[P](), p = s.toGlobalCoord(d[0]), v = s.toGlobalCoord(d[0]), m = 0, g = o(l, r), y = c.getAreaStyle();
        u = i[Z](u) ? u : [u];
        for (var x = 1; x < d[ne]; x++)if (!a(s, x, g)) {
          var _, b, w, S, M = s.toGlobalCoord(d[x]);
          s.isHorizontal() ? (_ = p, b = h.y, w = M - _, S = h[ce]) : (_ = h.x, b = v, w = h.width, S = M - b);
          var T = m++ % u[ne];
          this._axisGroup.add(new n.Rect({
            anid: "area_" + f[x],
            shape: {x: _, y: b, width: w, height: S},
            style: i[Me]({fill: u[T]}, y),
            silent: !0
          })), p = _ + w, v = b + S
        }
      }
    });
    u[re]({type: "xAxis"}), u[re]({type: "yAxis"})
  }),e("zrender/Layer", [Pe, "./core/util", "./config", "./graphic/Style", "./graphic/Pattern"], function (t) {
    function e() {
      return !1
    }

    function i(t, e, i, n) {
      var r = document[y](e), a = i[ve](), o = i[pe](), s = r.style;
      return s[z] = "absolute", s.left = 0, s.top = 0, s.width = a + "px", s[ce] = o + "px", r.width = a * n, r[ce] = o * n, r.setAttribute("data-zr-dom-id", t), r
    }

    var n = t("./core/util"), r = t("./config"), a = t("./graphic/Style"), o = t("./graphic/Pattern"), s = function (t, a, o) {
      var s;
      o = o || r.devicePixelRatio, typeof t === ye ? s = i(t, "canvas", a, o) : n[oe](t) && (s = t, t = s.id), this.id = t, this.dom = s;
      var l = s.style;
      l && (s.onselectstart = e, l["-webkit-user-select"] = "none", l["user-select"] = "none", l["-webkit-touch-callout"] = "none", l["-webkit-tap-highlight-color"] = "rgba(0,0,0,0)"), this.domBack = null, this.ctxBack = null, this.painter = a, this.config = null, this.clearColor = 0, this.motionBlur = !1, this.lastFrameAlpha = .7, this.dpr = o
    };
    return s[xe] = {
      constructor: s, elCount: 0, __dirty: !0, initContext: function () {
        this.ctx = this.dom.getContext("2d");
        var t = this.dpr;
        1 != t && this.ctx.scale(t, t)
      }, createBackBuffer: function () {
        var t = this.dpr;
        this.domBack = i("back-" + this.id, "canvas", this.painter, t), this.ctxBack = this.domBack.getContext("2d"), 1 != t && this.ctxBack.scale(t, t)
      }, resize: function (t, e) {
        var i = this.dpr, n = this.dom, r = n.style, a = this.domBack;
        r.width = t + "px", r[ce] = e + "px", n.width = t * i, n[ce] = e * i, 1 != i && this.ctx.scale(i, i), a && (a.width = t * i, a[ce] = e * i, 1 != i && this.ctxBack.scale(i, i))
      }, clear: function (t) {
        var e = this.dom, i = this.ctx, n = e.width, r = e[ce], s = this.clearColor, l = this.motionBlur && !t, c = this.lastFrameAlpha, u = this.dpr;
        if (l && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(e, 0, 0, n / u, r / u)), i.clearRect(0, 0, n / u, r / u), s) {
          var h;
          s.colorStops ? (h = s.__canvasGradient || a.getGradient(i, s, {
            x: 0,
            y: 0,
            width: n / u,
            height: r / u
          }), s.__canvasGradient = h) : s.image && (h = o[xe].getCanvasPattern.call(s, i)), i.save(), i.fillStyle = h || s, i.fillRect(0, 0, n / u, r / u), i.restore()
        }
        if (l) {
          var d = this.domBack;
          i.save(), i.globalAlpha = c, i.drawImage(d, 0, 0, n / u, r / u), i.restore()
        }
      }
    }, s
  }),e("echarts/component/axis/AxisBuilder", [Pe, Le, "../../util/format", A, "../../model/Model", "../../util/number", be], function (t) {
    function e(t) {
      var e = {componentType: t.mainType};
      return e[t.mainType + "Index"] = t.componentIndex, e
    }

    function i(t, e, i) {
      var n, r, a = p(e - t.rotation);
      return v(a) ? (r = i > 0 ? "top" : ue, n = D) : v(a - _) ? (r = i > 0 ? ue : "top", n = D) : (r = E, n = a > 0 && _ > a ? i > 0 ? "right" : "left" : i > 0 ? "left" : "right"), {
        rotation: a,
        textAlign: n,
        verticalAlign: r
      }
    }

    function n(t, e, i, n) {
      var r, a, o = p(i - t.rotation), s = n[0] > n[1], l = "start" === e && !s || "start" !== e && s;
      return v(o - _ / 2) ? (a = l ? ue : "top", r = D) : v(o - 1.5 * _) ? (a = l ? "top" : ue, r = D) : (a = E, r = 1.5 * _ > o && o > _ / 2 ? l ? "left" : "right" : l ? "right" : "left"), {
        rotation: o,
        textAlign: r,
        verticalAlign: a
      }
    }

    function o(t) {
      var e = t.get("tooltip");
      return t.get("silent") || !(t.get("triggerEvent") || e && e.show)
    }

    var l = t(Le), c = t("../../util/format"), u = t(A), d = t("../../model/Model"), f = t("../../util/number"), p = f.remRadian, v = f.isRadianAroundZero, m = t(be), g = m[h], y = l.retrieve, _ = Math.PI, w = function (t, e) {
      this.opt = e, this.axisModel = t, l[Me](e, {
        labelOffset: 0,
        nameDirection: 1,
        tickDirection: 1,
        labelDirection: 1,
        silent: !0
      }), this.group = new u.Group;
      var i = new u.Group({position: e[z].slice(), rotation: e.rotation});
      i.updateTransform(), this._transform = i[r], this._dumbGroup = i
    };
    w[xe] = {
      constructor: w, hasBuilder: function (t) {
        return !!S[t]
      }, add: function (t) {
        S[t].call(this)
      }, getGroup: function () {
        return this.group
      }
    };
    var S = {
      axisLine: function () {
        var t = this.opt, e = this.axisModel;
        if (e.get("axisLine.show")) {
          var i = this.axisModel.axis[L](), n = this._transform, r = [i[0], 0], a = [i[1], 0];
          n && (g(r, r, n), g(a, a, n)), this.group.add(new u.Line(u.subPixelOptimizeLine({
            anid: "line",
            shape: {x1: r[0], y1: r[1], x2: a[0], y2: a[1]},
            style: l[re]({lineCap: "round"}, e[me]("axisLine.lineStyle").getLineStyle()),
            strokeContainThreshold: t.strokeContainThreshold || 5,
            silent: !0,
            z2: 1
          })))
        }
      }, axisTick: function () {
        var t = this.axisModel;
        if (t.get("axisTick.show"))for (var e = t.axis, i = t[me]("axisTick"), n = this.opt, r = i[me]("lineStyle"), a = i.get(ne), o = T(i, n.labelInterval), s = e.getTicksCoords(i.get("alignWithLabel")), c = e.scale[P](), h = [], d = [], f = this._transform, p = 0; p < s[ne]; p++)if (!M(e, p, o)) {
          var v = s[p];
          h[0] = v, h[1] = 0, d[0] = v, d[1] = n.tickDirection * a, f && (g(h, h, f), g(d, d, f)), this.group.add(new u.Line(u.subPixelOptimizeLine({
            anid: "tick_" + c[p],
            shape: {x1: h[0], y1: h[1], x2: d[0], y2: d[1]},
            style: l[Me](r.getLineStyle(), {stroke: t.get("axisLine.lineStyle.color")}),
            z2: 2,
            silent: !0
          })))
        }
      }, axisLabel: function () {
        function t(t, e) {
          var i = t && t[O]().clone(), n = e && e[O]().clone();
          return i && n ? (i[h](t.getLocalTransform()), n[h](e.getLocalTransform()), i.intersect(n)) : void 0
        }

        var n = this.opt, r = this.axisModel, l = y(n.axisLabelShow, r.get("axisLabel.show"));
        if (l) {
          var c = r.axis, f = r[me]("axisLabel"), p = f[me](G), v = f.get("margin"), m = c.scale[P](), g = r.getFormattedLabels(), x = y(n.labelRotation, f.get("rotate")) || 0;
          x = x * _ / 180;
          for (var w = i(n, x, n.labelDirection), S = r.get("data"), T = [], C = o(r), A = r.get("triggerEvent"), L = 0; L < m[ne]; L++)if (!M(c, L, n.labelInterval)) {
            var k = p;
            S && S[L] && S[L][G] && (k = new d(S[L][G], p, r[a]));
            var I = k[R]() || r.get("axisLine.lineStyle.color"), z = c[b](m[L]), D = [z, n.labelOffset + n.labelDirection * v], E = c.scale.getLabel(m[L]), F = new u.Text({
              anid: "label_" + m[L],
              style: {
                text: g[L],
                textAlign: k.get("align", !0) || w[N],
                textVerticalAlign: k.get("baseline", !0) || w.verticalAlign,
                textFont: k[B](),
                fill: typeof I === W ? I(E) : I
              },
              position: D,
              rotation: w.rotation,
              silent: C,
              z2: 10
            });
            A && (F.eventData = e(r), F.eventData.targetType = "axisLabel", F.eventData.value = E), this._dumbGroup.add(F), F.updateTransform(), T.push(F), this.group.add(F), F.decomposeTransform()
          }
          if (c.type !== s) {
            if (r.getMin ? r.getMin() : r.get("min")) {
              var V = T[0], H = T[1];
              t(V, H) && (V[he] = !0)
            }
            if (r.getMax ? r.getMax() : r.get("max")) {
              var q = T[T[ne] - 1], Z = T[T[ne] - 2];
              t(Z, q) && (q[he] = !0)
            }
          }
        }
      }, axisName: function () {
        var t = this.opt, r = this.axisModel, a = y(t.axisName, r.get("name"));
        if (a) {
          var s, h = r.get("nameLocation"), d = t.nameDirection, f = r[me]("nameTextStyle"), p = r.get("nameGap") || 0, v = this.axisModel.axis[L](), m = v[0] > v[1] ? -1 : 1, g = ["start" === h ? v[0] - m * p : "end" === h ? v[1] + m * p : (v[0] + v[1]) / 2, h === E ? t.labelOffset + d * p : 0], x = r.get("nameRotate");
          null != x && (x = x * _ / 180);
          var b;
          h === E ? s = i(t, null != x ? x : t.rotation, d) : (s = n(t, h, x || 0, v), b = t.axisNameAvailableWidth, null != b && (b = Math.abs(b / Math.sin(s.rotation)), !isFinite(b) && (b = null)));
          var w = f[B](), S = r.get("nameTruncate", !0) || {}, M = S.ellipsis, T = y(S.maxWidth, b), C = null != M && null != T ? c.truncateText(a, T, w, M, {
            minChar: 2,
            placeholder: S.placeholder
          }) : a, A = r.get("tooltip", !0), P = r.mainType, k = {componentType: P, name: a, $vars: ["name"]};
          k[P + "Index"] = r.componentIndex;
          var I = new u.Text({
            anid: "name",
            __fullText: a,
            __truncatedText: C,
            style: {
              text: C,
              textFont: w,
              fill: f[R]() || r.get("axisLine.lineStyle.color"),
              textAlign: s[N],
              textVerticalAlign: s.verticalAlign
            },
            position: g,
            rotation: s.rotation,
            silent: o(r),
            z2: 1,
            tooltip: A && A.show ? l[re]({
              content: a, formatter: function () {
                return a
              }, formatterParams: k
            }, A) : null
          });
          r.get("triggerEvent") && (I.eventData = e(r), I.eventData.targetType = "axisName", I.eventData.name = a), this._dumbGroup.add(I), I.updateTransform(), this.group.add(I), I.decomposeTransform()
        }
      }
    }, M = w.ifIgnoreOnTick = function (t, e, i) {
      var n, r = t.scale;
      return r.type === x && (typeof i === W ? (n = r[P]()[e], !i(n, r.getLabel(n))) : e % (i + 1))
    }, T = w.getInterval = function (t, e) {
      var i = t.get("interval");
      return (null == i || "auto" == i) && (i = e), i
    };
    return w
  }),e("echarts/preprocessor/helper/compatStyle", [Pe, Le], function (t) {
    function e(t) {
      var e = t && t.itemStyle;
      e && i.each(n, function (n) {
        var r = e[f], a = e.emphasis;
        r && r[n] && (t[n] = t[n] || {}, t[n][f] ? i.merge(t[n][f], r[n]) : t[n][f] = r[n], r[n] = null), a && a[n] && (t[n] = t[n] || {}, t[n].emphasis ? i.merge(t[n].emphasis, a[n]) : t[n].emphasis = a[n], a[n] = null)
      })
    }

    var i = t(Le), n = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
    return function (t) {
      if (t) {
        e(t), e(t.markPoint), e(t.markLine);
        var n = t.data;
        if (n) {
          for (var r = 0; r < n[ne]; r++)e(n[r]);
          var a = t.markPoint;
          if (a && a.data)for (var o = a.data, r = 0; r < o[ne]; r++)e(o[r]);
          var s = t.markLine;
          if (s && s.data)for (var l = s.data, r = 0; r < l[ne]; r++)i[Z](l[r]) ? (e(l[r][0]), e(l[r][1])) : e(l[r])
        }
      }
    }
  }),e("echarts/chart/helper/SymbolDraw", [Pe, A, "./Symbol"], function (t) {
    function e(t) {
      this.group = new n.Group, this._symbolCtor = t || r
    }

    function i(t, e, i) {
      var n = t.getItemLayout(e);
      return !(!n || isNaN(n[0]) || isNaN(n[1]) || i && i(e) || "none" === t[w](e, "symbol"))
    }

    var n = t(A), r = t("./Symbol"), a = e[xe];
    return a.updateData = function (t, e) {
      var r = this.group, a = t.hostModel, o = this._data, s = this._symbolCtor, l = {
        itemStyle: a[me]("itemStyle.normal")[Se](["color"]),
        hoverItemStyle: a[me]("itemStyle.emphasis")[Se](),
        symbolRotate: a.get("symbolRotate"),
        symbolOffset: a.get("symbolOffset"),
        hoverAnimation: a.get("hoverAnimation"),
        labelModel: a[me]("label.normal"),
        hoverLabelModel: a[me]("label.emphasis")
      };
      t.diff(o).add(function (n) {
        var a = t.getItemLayout(n);
        if (i(t, n, e)) {
          var o = new s(t, n, l);
          o.attr(z, a), t.setItemGraphicEl(n, o), r.add(o)
        }
      })[se](function (c, u) {
        var h = o.getItemGraphicEl(u), d = t.getItemLayout(c);
        return i(t, c, e) ? (h ? (h.updateData(t, c, l), n.updateProps(h, {position: d}, a)) : (h = new s(t, c), h.attr(z, d)), r.add(h), void t.setItemGraphicEl(c, h)) : void r[ae](h)
      })[ae](function (t) {
        var e = o.getItemGraphicEl(t);
        e && e.fadeOut(function () {
          r[ae](e)
        })
      }).execute(), this._data = t
    }, a.updateLayout = function () {
      var t = this._data;
      t && t.eachItemGraphicEl(function (e, i) {
        var n = t.getItemLayout(i);
        e.attr(z, n)
      })
    }, a[ae] = function (t) {
      var e = this.group, i = this._data;
      i && (t ? i.eachItemGraphicEl(function (t) {
        t.fadeOut(function () {
          e[ae](t)
        })
      }) : e[Ce]())
    }, e
  }),e("echarts/chart/helper/Symbol", [Pe, Le, "../../util/symbol", A, "../../util/number"], function (t) {
    function e(t) {
      return t instanceof Array || (t = [+t, +t]), t
    }

    function i(t, e, i) {
      o.Group.call(this), this.updateData(t, e, i)
    }

    function n(t, e) {
      this.parent.drift(t, e)
    }

    var r = t(Le), a = t("../../util/symbol"), o = t(A), s = t("../../util/number"), l = i[xe];
    l._createSymbol = function (t, i, r) {
      this[Ce]();
      var s = i.hostModel, l = i[w](r, "color"), c = a.createSymbol(t, -.5, -.5, 1, 1, l);
      c.attr({z2: 100, culling: !0, scale: [0, 0]}), c.drift = n;
      var u = e(i[w](r, "symbolSize"));
      o.initProps(c, {scale: u}, s, r), this._symbolType = t, this.add(c)
    }, l.stopSymbolAnimation = function (t) {
      this.childAt(0).stopAnimation(t)
    }, l.getScale = function () {
      return this.childAt(0).scale
    }, l.highlight = function () {
      this.childAt(0).trigger("emphasis")
    }, l.downplay = function () {
      this.childAt(0).trigger(f)
    }, l.setZ = function (t, e) {
      var i = this.childAt(0);
      i[j] = t, i.z = e
    }, l.setDraggable = function (t) {
      var e = this.childAt(0);
      e.draggable = t, e.cursor = t ? "move" : "pointer"
    }, l.updateData = function (t, i, n) {
      this.silent = !1;
      var r = t[w](i, "symbol") || "circle", a = t.hostModel, s = e(t[w](i, "symbolSize"));
      if (r !== this._symbolType)this._createSymbol(r, t, i); else {
        var l = this.childAt(0);
        o.updateProps(l, {scale: s}, a, i)
      }
      this._updateCommon(t, i, s, n), this._seriesModel = a
    };
    var c = ["itemStyle", f], u = ["itemStyle", "emphasis"], h = ["label", f], d = ["label", "emphasis"];
    return l._updateCommon = function (t, i, n, a) {
      var l = this.childAt(0), p = t.hostModel, g = t[w](i, "color");
      "image" !== l.type && l.useStyle({strokeNoScale: !0}), a = a || null;
      var y = a && a.itemStyle, _ = a && a.hoverItemStyle, b = a && a.symbolRotate, M = a && a.symbolOffset, T = a && a.labelModel, C = a && a.hoverLabelModel, A = a && a.hoverAnimation;
      if (!a || t.hasItemOption) {
        var L = t[m](i);
        y = L[me](c)[Se](["color"]), _ = L[me](u)[Se](), b = L[v]("symbolRotate"), M = L[v]("symbolOffset"), T = L[me](h), C = L[me](d), A = L[v]("hoverAnimation")
      } else _ = r[re]({}, _);
      var P = l.style;
      l.rotation = (b || 0) * Math.PI / 180 || 0, M && l.attr(z, [s.parsePercent(M[0], n[0]), s.parsePercent(M[1], n[1])]), l.setColor(g), l[X](y);
      var k = t[w](i, I);
      null != k && (P[I] = k);
      for (var D, E, O = t[S].slice(); O[ne] && (D = O.pop(), E = t.getDimensionInfo(D).type, E === x || "time" === E););
      null != D && T[v]("show") ? (o.setText(P, T, g), P.text = r.retrieve(p.getFormattedLabel(i, f), t.get(D, i))) : P.text = "", null != D && C[v]("show") ? (o.setText(_, C, g), _.text = r.retrieve(p.getFormattedLabel(i, "emphasis"), t.get(D, i))) : _.text = "";
      var R = e(t[w](i, "symbolSize"));
      if (l.off(te).off(J).off("emphasis").off(f), o.setHoverStyle(l, _), A && p.ifEnableAnimation()) {
        var B = function () {
          var t = R[1] / R[0];
          this.animateTo({scale: [Math.max(1.1 * R[0], R[0] + 3), Math.max(1.1 * R[1], R[1] + 3 * t)]}, 400, "elasticOut")
        }, N = function () {
          this.animateTo({scale: R}, 400, "elasticOut")
        };
        l.on(te, B).on(J, N).on("emphasis", B).on(f, N)
      }
    }, l.fadeOut = function (t) {
      var e = this.childAt(0);
      this.silent = !0, e.style.text = "", o.updateProps(e, {scale: [0, 0]}, this._seriesModel, this[Q], t)
    }, r[F](i, o.Group), i
  }),e("echarts/chart/line/lineAnimationDiff", [Pe], function () {
    function t(t) {
      return t >= 0 ? 1 : -1
    }

    function e(e, i, n) {
      for (var r, a = e[C](), o = e.getOtherAxis(a), s = a.onZero ? 0 : o.scale[L]()[0], l = o.dim, c = "x" === l || l === T ? 1 : 0, u = i.stackedOn, h = i.get(l, n); u && t(u.get(l, n)) === t(h);) {
        r = u;
        break
      }
      var d = [];
      return d[c] = i.get(a.dim, n), d[1 - c] = r ? r.get(l, n, !0) : s, e[M](d)
    }

    function i(t, e) {
      var i = [];
      return e.diff(t).add(function (t) {
        i.push({cmd: "+", idx: t})
      })[se](function (t, e) {
        i.push({cmd: "=", idx: e, idx1: t})
      })[ae](function (t) {
        i.push({cmd: "-", idx: t})
      }).execute(), i
    }

    return function (t, n, r, a, o, s) {
      for (var l = i(t, n), c = [], u = [], h = [], d = [], f = [], p = [], v = [], m = s[S], g = 0; g < l[ne]; g++) {
        var y = l[g], x = !0;
        switch (y.cmd) {
          case"=":
            var _ = t.getItemLayout(y.idx), b = n.getItemLayout(y.idx1);
            (isNaN(_[0]) || isNaN(_[1])) && (_ = b.slice()), c.push(_), u.push(b), h.push(r[y.idx]), d.push(a[y.idx1]), v.push(n.getRawIndex(y.idx1));
            break;
          case"+":
            var w = y.idx;
            c.push(o[M]([n.get(m[0], w, !0), n.get(m[1], w, !0)])), u.push(n.getItemLayout(w).slice()), h.push(e(o, n, w)), d.push(a[w]), v.push(n.getRawIndex(w));
            break;
          case"-":
            var w = y.idx, T = t.getRawIndex(w);
            T !== w ? (c.push(t.getItemLayout(w)), u.push(s[M]([t.get(m[0], w, !0), t.get(m[1], w, !0)])), h.push(r[w]), d.push(e(s, t, w)), v.push(T)) : x = !1
        }
        x && (f.push(y), p.push(p[ne]))
      }
      p.sort(function (t, e) {
        return v[t] - v[e]
      });
      for (var C = [], A = [], L = [], P = [], k = [], g = 0; g < p[ne]; g++) {
        var w = p[g];
        C[g] = c[w], A[g] = u[w], L[g] = h[w], P[g] = d[w], k[g] = f[w]
      }
      return {current: C, next: A, stackedOnCurrent: L, stackedOnNext: P, status: k}
    }
  }),e("echarts/component/helper/selectableMixin", [Pe, Le], function (t) {
    var e = t(Le);
    return {
      updateSelectedMap: function (t) {
        this._selectTargetMap = e.reduce(t || [], function (t, e) {
          return t[e.name] = e, t
        }, {})
      }, select: function (t) {
        var i = this._selectTargetMap, n = i[t], r = this.get("selectedMode");
        "single" === r && e.each(i, function (t) {
          t.selected = !1
        }), n && (n.selected = !0)
      }, unSelect: function (t) {
        var e = this._selectTargetMap[t];
        e && (e.selected = !1)
      }, toggleSelected: function (t) {
        var e = this._selectTargetMap[t];
        return null != e ? (this[e.selected ? "unSelect" : "select"](t), e.selected) : void 0
      }, isSelected: function (t) {
        var e = this._selectTargetMap[t];
        return e && e.selected
      }
    }
  }),e("echarts/chart/line/poly", [Pe, "zrender/graphic/Path", be], function (t) {
    function e(t) {
      return isNaN(t[0]) || isNaN(t[1])
    }

    function i(t, i, r, a, p, v, m, g, y, x, _) {
      for (var b = 0, w = r, S = 0; a > S; S++) {
        var M = i[w];
        if (w >= p || 0 > w)break;
        if (e(M)) {
          if (_) {
            w += v;
            continue
          }
          break
        }
        if (w === r)t[v > 0 ? n : "lineTo"](M[0], M[1]), u(d, M); else if (y > 0) {
          var T = w + v, C = i[T];
          if (_)for (; C && e(i[T]);)T += v, C = i[T];
          var A = .5, L = i[b], C = i[T];
          if (!C || e(C))u(f, M); else {
            e(C) && !_ && (C = M), o.sub(h, C, L);
            var P, k;
            if ("x" === x || "y" === x) {
              var I = "x" === x ? 0 : 1;
              P = Math.abs(M[I] - L[I]), k = Math.abs(M[I] - C[I])
            } else P = o.dist(M, L), k = o.dist(M, C);
            A = k / (k + P), c(f, M, h, -y * (1 - A))
          }
          s(d, d, g), l(d, d, m), s(f, f, g), l(f, f, m), t.bezierCurveTo(d[0], d[1], f[0], f[1], M[0], M[1]), c(d, M, h, y * A)
        } else t.lineTo(M[0], M[1]);
        b = w, w += v
      }
      return S
    }

    function r(t, e) {
      var i = [1 / 0, 1 / 0], n = [-1 / 0, -1 / 0];
      if (e)for (var r = 0; r < t[ne]; r++) {
        var a = t[r];
        a[0] < i[0] && (i[0] = a[0]), a[1] < i[1] && (i[1] = a[1]), a[0] > n[0] && (n[0] = a[0]), a[1] > n[1] && (n[1] = a[1])
      }
      return {min: e ? i : n, max: e ? n : i}
    }

    var a = t("zrender/graphic/Path"), o = t(be), s = o.min, l = o.max, c = o.scaleAndAdd, u = o.copy, h = [], d = [], f = [];
    return {
      Polyline: a[re]({
        type: "ec-polyline",
        shape: {points: [], smooth: 0, smoothConstraint: !0, smoothMonotone: null, connectNulls: !1},
        style: {fill: null, stroke: "#000"},
        buildPath: function (t, n) {
          var a = n.points, o = 0, s = a[ne], l = r(a, n.smoothConstraint);
          if (n.connectNulls) {
            for (; s > 0 && e(a[s - 1]); s--);
            for (; s > o && e(a[o]); o++);
          }
          for (; s > o;)o += i(t, a, o, s, s, 1, l.min, l.max, n.smooth, n.smoothMonotone, n.connectNulls) + 1
        }
      }),
      Polygon: a[re]({
        type: "ec-polygon",
        shape: {
          points: [],
          stackedOnPoints: [],
          smooth: 0,
          stackedOnSmooth: 0,
          smoothConstraint: !0,
          smoothMonotone: null,
          connectNulls: !1
        },
        buildPath: function (t, n) {
          var a = n.points, o = n.stackedOnPoints, s = 0, l = a[ne], c = n.smoothMonotone, u = r(a, n.smoothConstraint), h = r(o, n.smoothConstraint);
          if (n.connectNulls) {
            for (; l > 0 && e(a[l - 1]); l--);
            for (; l > s && e(a[s]); s++);
          }
          for (; l > s;) {
            var d = i(t, a, s, l, l, 1, u.min, u.max, n.smooth, c, n.connectNulls);
            i(t, o, s + d - 1, d, l, -1, h.min, h.max, n.stackedOnSmooth, c, n.connectNulls), s += d + 1, t.closePath()
          }
        }
      })
    }
  }),e("echarts/coord/radar/Radar", [Pe, Le, "./IndicatorAxis", "../../scale/Interval", "../../util/number", "../axisHelper", "../../CoordinateSystem"], function (t) {
    function e(t, e, a) {
      this._model = t, this[S] = [], this._indicatorAxes = i.map(t.getIndicatorModels(), function (t, e) {
        var i = "indicator_" + e, a = new n(i, new r);
        return a.name = t.get("name"), a.model = t, t.axis = a, this[S].push(i), a
      }, this), this[ge](t, a), this.cx, this.cy, this.r, this.startAngle
    }

    var i = t(Le), n = t("./IndicatorAxis"), r = t("../../scale/Interval"), a = t("../../util/number"), o = t("../axisHelper");
    return e[xe].getIndicatorAxes = function () {
      return this._indicatorAxes
    }, e[xe][M] = function (t, e) {
      var i = this._indicatorAxes[e];
      return this.coordToPoint(i[b](t), e)
    }, e[xe].coordToPoint = function (t, e) {
      var i = this._indicatorAxes[e], n = i.angle, r = this.cx + t * Math.cos(n), a = this.cy - t * Math.sin(n);
      return [r, a]
    }, e[xe].pointToData = function (t) {
      var e = t[0] - this.cx, i = t[1] - this.cy, n = Math.sqrt(e * e + i * i);
      e /= n, i /= n;
      for (var r, a = Math.atan2(-i, e), o = 1 / 0, s = -1, l = 0; l < this._indicatorAxes[ne]; l++) {
        var c = this._indicatorAxes[l], u = Math.abs(a - c.angle);
        o > u && (r = c, s = l, o = u)
      }
      return [s, +(r && r.coodToData(n))]
    }, e[xe][ge] = function (t, e) {
      var n = t.get(D), r = e[ve](), o = e[pe](), s = Math.min(r, o) / 2;
      this.cx = a.parsePercent(n[0], r), this.cy = a.parsePercent(n[1], o), this.startAngle = t.get("startAngle") * Math.PI / 180, this.r = a.parsePercent(t.get(T), s), i.each(this._indicatorAxes, function (t, e) {
        t.setExtent(0, this.r);
        var i = this.startAngle + e * Math.PI * 2 / this._indicatorAxes[ne];
        i = Math.atan2(Math.sin(i), Math.cos(i)), t.angle = i
      }, this)
    }, e[xe][se] = function (t) {
      function e(t) {
        var e = Math.pow(10, Math.floor(Math.log(t) / Math.LN10)), i = t / e;
        return 2 === i ? i = 5 : i *= 2, i * e
      }

      var n = this._indicatorAxes, r = this._model;
      i.each(n, function (t) {
        t.scale.setExtent(1 / 0, -1 / 0)
      }), t.eachSeriesByType("radar", function (e) {
        if ("radar" === e.get(Te) && t.getComponent("radar", e.get("radarIndex")) === r) {
          var a = e[we]();
          i.each(n, function (t) {
            t.scale.unionExtent(a.getDataExtent(t.dim))
          })
        }
      }, this);
      var s = r.get("splitNumber");
      i.each(n, function (t) {
        var i = o.getScaleExtent(t, t.model);
        o.niceScaleExtent(t, t.model);
        var n = t.model, r = t.scale, l = n.get("min"), c = n.get("max"), u = r.getInterval();
        if (null != l && null != c)r.setInterval((c - l) / s); else if (null != l) {
          var h;
          do h = l + u * s, r.setExtent(+l, h), r.setInterval(u), u = e(u); while (h < i[1] && isFinite(h) && isFinite(i[1]))
        } else if (null != c) {
          var d;
          do d = c - u * s, r.setExtent(d, +c), r.setInterval(u), u = e(u); while (d > i[0] && isFinite(d) && isFinite(i[0]))
        } else {
          var f = r[P]()[ne] - 1;
          f > s && (u = e(u));
          var p = Math.round((i[0] + i[1]) / 2 / u) * u, v = Math.round(s / 2);
          r.setExtent(a.round(p - v * u), a.round(p + (s - v) * u)), r.setInterval(u)
        }
      })
    }, e[S] = [], e[le] = function (t, i) {
      var n = [];
      return t.eachComponent("radar", function (r) {
        var a = new e(r, t, i);
        n.push(a), r[Te] = a
      }), t.eachSeriesByType("radar", function (t) {
        "radar" === t.get(Te) && (t[Te] = n[t.get("radarIndex") || 0])
      }), n
    }, t("../../CoordinateSystem").register("radar", e), e
  }),e("echarts/coord/radar/RadarModel", [Pe, "../axisDefault", "../../model/Model", Le, "../axisModelCommonMixin", p], function (t) {
    function e(t, e) {
      return o[Me]({show: e}, t)
    }

    var i = t("../axisDefault"), n = i.valueAxis, r = t("../../model/Model"), o = t(Le), s = t("../axisModelCommonMixin"), l = t(p).extendComponentModel({
      type: "radar",
      optionUpdated: function () {
        var t = this.get("boundaryGap"), e = this.get("splitNumber"), i = this.get("scale"), n = this.get("axisLine"), l = this.get("axisTick"), c = this.get("axisLabel"), u = this.get("name.textStyle"), h = this.get("name.show"), d = this.get("name.formatter"), f = this.get("nameGap"), p = o.map(this.get("indicator") || [], function (p) {
          return null != p.max && p.max > 0 ? p.min = 0 : null != p.min && p.min < 0 && (p.max = 0), p = o.merge(o.clone(p), {
            boundaryGap: t,
            splitNumber: e,
            scale: i,
            axisLine: n,
            axisTick: l,
            axisLabel: c,
            name: p.text,
            nameLocation: "end",
            nameGap: f,
            nameTextStyle: u
          }, !1), h || (p.name = ""), typeof d === ye ? p.name = d[U]("{value}", p.name) : typeof d === W && (p.name = d(p.name, p)), o[re](new r(p, null, this[a]), s)
        }, this);
        this.getIndicatorModels = function () {
          return p
        }
      },
      defaultOption: {
        zlevel: 0,
        z: 0,
        center: ["50%", "50%"],
        radius: "75%",
        startAngle: 90,
        name: {show: !0},
        boundaryGap: [0, 0],
        splitNumber: 5,
        nameGap: 15,
        scale: !1,
        shape: "polygon",
        axisLine: o.merge({lineStyle: {color: "#bbb"}}, n.axisLine),
        axisLabel: e(n.axisLabel, !1),
        axisTick: e(n.axisTick, !1),
        splitLine: e(n.splitLine, !0),
        splitArea: e(n.splitArea, !0),
        indicator: []
      }
    });
    return l
  }),e("echarts/component/radar/RadarView", [Pe, "../axis/AxisBuilder", Le, A, p], function (t) {
    var e = t("../axis/AxisBuilder"), i = t(Le), n = t(A), r = ["axisLine", "axisLabel", "axisTick", "axisName"];
    return t(p)[Ae]({
      type: "radar", render: function (t) {
        var e = this.group;
        e[Ce](), this._buildAxes(t), this._buildSplitLineAndArea(t)
      }, _buildAxes: function (t) {
        var n = t[Te], a = n.getIndicatorAxes(), o = i.map(a, function (t) {
          var i = new e(t.model, {
            position: [n.cx, n.cy],
            rotation: t.angle,
            labelDirection: -1,
            tickDirection: -1,
            nameDirection: 1
          });
          return i
        });
        i.each(o, function (t) {
          i.each(r, t.add, t), this.group.add(t.getGroup())
        }, this)
      }, _buildSplitLineAndArea: function (t) {
        function e(t, e, i) {
          var n = i % e[ne];
          return t[n] = t[n] || [], n
        }

        var r = t[Te], a = t.get("splitNumber"), o = r.getIndicatorAxes();
        if (o[ne]) {
          var s = t.get("shape"), l = t[me]("splitLine"), c = t[me]("splitArea"), u = l[me]("lineStyle"), h = c[me]("areaStyle"), d = l.get("show"), f = c.get("show"), p = u.get("color"), v = h.get("color");
          p = i[Z](p) ? p : [p], v = i[Z](v) ? v : [v];
          var m = [], y = [];
          if ("circle" === s)for (var x = o[0].getTicksCoords(), _ = r.cx, b = r.cy, w = 0; w < x[ne]; w++) {
            if (d) {
              var S = e(m, p, w);
              m[S].push(new n.Circle({shape: {cx: _, cy: b, r: x[w]}}))
            }
            if (f && w < x[ne] - 1) {
              var S = e(y, v, w);
              y[S].push(new n.Ring({shape: {cx: _, cy: b, r0: x[w], r: x[w + 1]}}))
            }
          } else for (var M = i.map(o, function (t, e) {
            var n = t.getTicksCoords();
            return i.map(n, function (t) {
              return r.coordToPoint(t, e)
            })
          }), T = [], w = 0; a >= w; w++) {
            for (var C = [], A = 0; A < o[ne]; A++)C.push(M[A][w]);
            if (C.push(C[0].slice()), d) {
              var S = e(m, p, w);
              m[S].push(new n.Polyline({shape: {points: C}}))
            }
            if (f && T) {
              var S = e(y, v, w - 1);
              y[S].push(new n.Polygon({shape: {points: C[g](T)}}))
            }
            T = C.slice().reverse()
          }
          var L = u.getLineStyle(), P = h.getAreaStyle();
          i.each(y, function (t, e) {
            this.group.add(n.mergePath(t, {style: i[Me]({stroke: "none", fill: v[e % v[ne]]}, P), silent: !0}))
          }, this), i.each(m, function (t, e) {
            this.group.add(n.mergePath(t, {style: i[Me]({fill: "none", stroke: p[e % p[ne]]}, L), silent: !0}))
          }, this)
        }
      }
    })
  }),e("echarts/util/symbol", [Pe, "./graphic", "zrender/core/BoundingRect"], function (t) {
    var e = t("./graphic"), i = t("zrender/core/BoundingRect"), r = e.extendShape({
      type: "triangle",
      shape: {cx: 0, cy: 0, width: 0, height: 0},
      buildPath: function (t, e) {
        var i = e.cx, r = e.cy, a = e.width / 2, o = e[ce] / 2;
        t[n](i, r - o), t.lineTo(i + a, r + o), t.lineTo(i - a, r + o), t.closePath()
      }
    }), a = e.extendShape({
      type: "diamond", shape: {cx: 0, cy: 0, width: 0, height: 0}, buildPath: function (t, e) {
        var i = e.cx, r = e.cy, a = e.width / 2, o = e[ce] / 2;
        t[n](i, r - o), t.lineTo(i + a, r), t.lineTo(i, r + o), t.lineTo(i - a, r), t.closePath()
      }
    }), o = e.extendShape({
      type: "pin", shape: {x: 0, y: 0, width: 0, height: 0}, buildPath: function (t, e) {
        var i = e.x, n = e.y, r = e.width / 5 * 3, a = Math.max(r, e[ce]), o = r / 2, s = o * o / (a - o), l = n - a + o + s, c = Math.asin(s / o), u = Math.cos(c) * o, h = Math.sin(c), d = Math.cos(c);
        t.arc(i, l, o, Math.PI - c, 2 * Math.PI + c);
        var f = .6 * o, p = .7 * o;
        t.bezierCurveTo(i + u - h * f, l + s + d * f, i, n - p, i, n), t.bezierCurveTo(i, n - p, i - u + h * f, l + s + d * f, i - u, l + s), t.closePath()
      }
    }), s = e.extendShape({
      type: "arrow", shape: {x: 0, y: 0, width: 0, height: 0}, buildPath: function (t, e) {
        var i = e[ce], r = e.width, a = e.x, o = e.y, s = r / 3 * 2;
        t[n](a, o), t.lineTo(a + s, o + i), t.lineTo(a, o + i / 4 * 3), t.lineTo(a - s, o + i), t.lineTo(a, o), t.closePath()
      }
    }), u = {
      line: e.Line,
      rect: e.Rect,
      roundRect: e.Rect,
      square: e.Rect,
      circle: e.Circle,
      diamond: a,
      pin: o,
      arrow: s,
      triangle: r
    }, h = {
      line: function (t, e, i, n, r) {
        r.x1 = t, r.y1 = e + n / 2, r.x2 = t + i, r.y2 = e + n / 2
      }, rect: function (t, e, i, n, r) {
        r.x = t, r.y = e, r.width = i, r[ce] = n
      }, roundRect: function (t, e, i, n, r) {
        r.x = t, r.y = e, r.width = i, r[ce] = n, r.r = Math.min(i, n) / 4
      }, square: function (t, e, i, n, r) {
        var a = Math.min(i, n);
        r.x = t, r.y = e, r.width = a, r[ce] = a
      }, circle: function (t, e, i, n, r) {
        r.cx = t + i / 2, r.cy = e + n / 2, r.r = Math.min(i, n) / 2
      }, diamond: function (t, e, i, n, r) {
        r.cx = t + i / 2, r.cy = e + n / 2, r.width = i, r[ce] = n
      }, pin: function (t, e, i, n, r) {
        r.x = t + i / 2, r.y = e + n / 2, r.width = i, r[ce] = n
      }, arrow: function (t, e, i, n, r) {
        r.x = t + i / 2, r.y = e + n / 2, r.width = i, r[ce] = n
      }, triangle: function (t, e, i, n, r) {
        r.cx = t + i / 2, r.cy = e + n / 2, r.width = i, r[ce] = n
      }
    }, d = {};
    for (var f in u)d[f] = new u[f];
    var p = e.extendShape({
      type: "symbol",
      shape: {symbolType: "", x: 0, y: 0, width: 0, height: 0},
      beforeBrush: function () {
        var t = this.style, e = this.shape;
        "pin" === e.symbolType && t.textPosition === l && (t.textPosition = ["50%", "40%"], t[N] = D, t.textVerticalAlign = E)
      },
      buildPath: function (t, e, i) {
        var n = e.symbolType, r = d[n];
        "none" !== e.symbolType && (r || (n = "rect", r = d[n]), h[n](e.x, e.y, e.width, e[ce], r.shape), r.buildPath(t, r.shape, i))
      }
    }), v = function (t) {
      if ("image" !== this.type) {
        var e = this.style, i = this.shape;
        i && "line" === i.symbolType ? e[c] = t : this.__isEmptyBrush ? (e[c] = t, e.fill = "#fff") : (e.fill && (e.fill = t), e[c] && (e[c] = t)), this.dirty(!1)
      }
    }, m = {
      createSymbol: function (t, n, r, a, o, s) {
        var l = 0 === t[V]("empty");
        l && (t = t.substr(5, 1)[_e]() + t.substr(6));
        var c;
        return c = 0 === t[V]("image://") ? new e.Image({
          style: {
            image: t.slice(8),
            x: n,
            y: r,
            width: a,
            height: o
          }
        }) : 0 === t[V]("path://") ? e.makePath(t.slice(7), {}, new i(n, r, a, o)) : new p({
          shape: {
            symbolType: t,
            x: n,
            y: r,
            width: a,
            height: o
          }
        }), c.__isEmptyBrush = l, c.setColor = v, c.setColor(s), c
      }
    };
    return m
  }),e("echarts/component/helper/listComponent", [Pe, "../../util/layout", "../../util/format", A], function (t) {
    function e(t, e, n) {
      i.positionGroup(t, e.getBoxLayoutParams(), {width: n[ve](), height: n[pe]()}, e.get("padding"))
    }

    var i = t("../../util/layout"), n = t("../../util/format"), r = t(A);
    return {
      layout: function (t, n, r) {
        var a = i.getLayoutRect(n.getBoxLayoutParams(), {width: r[ve](), height: r[pe]()}, n.get("padding"));
        i.box(n.get("orient"), t, n.get("itemGap"), a.width, a[ce]), e(t, n, r)
      }, addBackground: function (t, e) {
        var i = n.normalizeCssArray(e.get("padding")), a = t[O](), o = e[Se](["color", I]);
        o.fill = e.get("backgroundColor");
        var s = new r.Rect({
          shape: {
            x: a.x - i[3],
            y: a.y - i[0],
            width: a.width + i[1] + i[3],
            height: a[ce] + i[0] + i[2]
          }, style: o, silent: !0, z2: -1
        });
        r.subPixelOptimizeRect(s), t.add(s)
      }
    }
  }),e("echarts/component/tooltip/TooltipContent", [Pe, Le, "zrender/tool/color", "zrender/core/event", "../../util/format", "zrender/core/env"], function (t) {
    function e(t) {
      var e = "cubic-bezier(0.23, 1, 0.32, 1)", i = "left " + t + "s " + e + ",top " + t + "s " + e;
      return o.map(f, function (t) {
        return t + "transition:" + i
      }).join(";")
    }

    function i(t) {
      var e = [], i = t.get("fontSize"), n = t[R]();
      return n && e.push("color:" + n), e.push("font:" + t[B]()), i && e.push("line-height:" + Math.round(3 * i / 2) + "px"), u(["decoration", "align"], function (i) {
        var n = t.get(i);
        n && e.push("text-" + i + ":" + n)
      }), e.join(";")
    }

    function n(t) {
      t = t;
      var n = [], r = t.get("transitionDuration"), a = t.get("backgroundColor"), o = t[me](G), l = t.get("padding");
      return r && n.push(e(r)), a && (d[fe] ? n.push("background-Color:" + a) : (n.push("background-Color:#" + s.toHex(a)), n.push("filter:alpha(opacity=70)"))), u(["width", "color", T], function (e) {
        var i = "border-" + e, r = h(i), a = t.get(r);
        null != a && n.push(i + ":" + a + ("color" === e ? "" : "px"))
      }), n.push(i(o)), null != l && n.push("padding:" + c.normalizeCssArray(l).join("px ") + "px"), n.join(";") + ";"
    }

    function r(t, e) {
      var i = document[y]("div"), n = e.getZr();
      this.el = i, this._x = e[ve]() / 2, this._y = e[pe]() / 2, t.appendChild(i), this._container = t, this._show = !1, this._hideTimeout;
      var r = this;
      i.onmouseenter = function () {
        r.enterable && (clearTimeout(r._hideTimeout), r._show = !0), r._inContent = !0
      }, i.onmousemove = function (e) {
        if (!r.enterable) {
          var i = n.handler;
          l.normalizeEvent(t, e), i.dispatch("mousemove", e)
        }
      }, i.onmouseleave = function () {
        r.enterable && r._show && r.hideLater(r._hideDelay), r._inContent = !1
      }, a(i, t)
    }

    function a(t, e) {
      function i(t) {
        n(t[K]) && t.preventDefault()
      }

      function n(i) {
        for (; i && i !== e;) {
          if (i === t)return !0;
          i = i.parentNode
        }
      }

      l.addEventListener(e, "touchstart", i), l.addEventListener(e, "touchmove", i), l.addEventListener(e, "touchend", i)
    }

    var o = t(Le), s = t("zrender/tool/color"), l = t("zrender/core/event"), c = t("../../util/format"), u = o.each, h = c.toCamelCase, d = t("zrender/core/env"), f = ["", "-webkit-", "-moz-", "-o-"], p = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;";
    return r[xe] = {
      constructor: r, enterable: !0, update: function () {
        var t = this._container, e = t.currentStyle || document.defaultView.getComputedStyle(t), i = t.style;
        "absolute" !== i[z] && "absolute" !== e[z] && (i[z] = "relative")
      }, show: function (t) {
        clearTimeout(this._hideTimeout);
        var e = this.el;
        e.style.cssText = p + n(t) + ";left:" + this._x + "px;top:" + this._y + "px;" + (t.get("extraCssText") || ""), e.style.display = e.innerHTML ? "block" : "none", this._show = !0
      }, setContent: function (t) {
        var e = this.el;
        e.innerHTML = t, e.style.display = t ? "block" : "none"
      }, moveTo: function (t, e) {
        var i = this.el.style;
        i.left = t + "px", i.top = e + "px", this._x = t, this._y = e
      }, hide: function () {
        this.el.style.display = "none", this._show = !1
      }, hideLater: function (t) {
        !this._show || this._inContent && this.enterable || (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(o.bind(this.hide, this), t)) : this.hide())
      }, isShow: function () {
        return this._show
      }
    }, r
  }),e("echarts/chart/pie/labelLayout", [Pe, "zrender/contain/text"], function (t) {
    function e(t, e, i, n, r, a, o) {
      function s(e, i, n) {
        for (var r = e; i > r; r++)if (t[r].y += n, r > e && i > r + 1 && t[r + 1].y > t[r].y + t[r][ce])return void l(r, n / 2);
        l(i - 1, n / 2)
      }

      function l(e, i) {
        for (var n = e; n >= 0 && (t[n].y -= i, !(n > 0 && t[n].y > t[n - 1].y + t[n - 1][ce])); n--);
      }

      function c(t, e, i, n, r, a) {
        for (var o = a > 0 ? e ? Number.MAX_VALUE : 0 : e ? Number.MAX_VALUE : 0, s = 0, l = t[ne]; l > s; s++)if (t[s][z] !== D) {
          var c = Math.abs(t[s].y - n), u = t[s].len, h = t[s].len2, d = r + u > c ? Math.sqrt((r + u + h) * (r + u + h) - c * c) : Math.abs(t[s].x - i);
          e && d >= o && (d = o - 10), !e && o >= d && (d = o + 10), t[s].x = i + d * a, o = d
        }
      }

      t.sort(function (t, e) {
        return t.y - e.y
      });
      for (var u, h = 0, d = t[ne], f = [], p = [], v = 0; d > v; v++)u = t[v].y - h, 0 > u && s(v, d, -u, r), h = t[v].y + t[v][ce];
      0 > o - h && l(d - 1, h - o);
      for (var v = 0; d > v; v++)t[v].y >= i ? p.push(t[v]) : f.push(t[v]);
      c(f, !1, e, i, n, r), c(p, !0, e, i, n, r)
    }

    function i(t, i, n, r, a, o) {
      for (var s = [], l = [], c = 0; c < t[ne]; c++)t[c].x < i ? s.push(t[c]) : l.push(t[c]);
      e(l, i, n, r, 1, a, o), e(s, i, n, r, -1, a, o);
      for (var c = 0; c < t[ne]; c++) {
        var u = t[c].linePoints;
        if (u) {
          var h = u[1][0] - u[2][0];
          u[2][0] = t[c].x < i ? t[c].x + 3 : t[c].x - 3, u[1][1] = u[2][1] = t[c].y, u[1][0] = u[2][0] + h
        }
      }
    }

    var n = t("zrender/contain/text");
    return function (t, e, r, a) {
      var o, s, c = t[we](), u = [], h = !1;
      c.each(function (i) {
        var r, a, p, v, g = c.getItemLayout(i), y = c[m](i), x = y[me]("label.normal"), _ = x.get(z) || y.get("label.emphasis.position"), b = y[me]("labelLine.normal"), w = b.get(ne), S = b.get("length2"), M = (g.startAngle + g.endAngle) / 2, T = Math.cos(M), C = Math.sin(M);
        o = g.cx, s = g.cy;
        var A = _ === l || "inner" === _;
        if (_ === D)r = g.cx, a = g.cy, v = D; else {
          var L = (A ? (g.r + g.r0) / 2 * T : g.r * T) + o, P = (A ? (g.r + g.r0) / 2 * C : g.r * C) + s;
          if (r = L + 3 * T, a = P + 3 * C, !A) {
            var k = L + T * (w + e - g.r), I = P + C * (w + e - g.r), E = k + (0 > T ? -1 : 1) * S, R = I;
            r = E + (0 > T ? -5 : 5), a = R, p = [[L, P], [k, I], [E, R]]
          }
          v = A ? D : T > 0 ? "left" : "right"
        }
        var N = x[me](G)[B](), F = x.get("rotate") ? 0 > T ? -M + Math.PI : -M : 0, V = t.getFormattedLabel(i, f) || c[d](i), H = n[O](V, N, v, "top");
        h = !!F, g.label = {
          x: r,
          y: a,
          position: _,
          height: H[ce],
          len: w,
          len2: S,
          linePoints: p,
          textAlign: v,
          verticalAlign: "middle",
          font: N,
          rotation: F
        }, A || u.push(g.label)
      }), !h && t.get("avoidLabelOverlap") && i(u, o, s, e, r, a)
    }
  }),e("echarts/coord/radar/IndicatorAxis", [Pe, Le, "../Axis"], function (t) {
    function e(t, e, i) {
      n.call(this, t, e, i), this.type = "value", this.angle = 0, this.name = "", this.model
    }

    var i = t(Le), n = t("../Axis");
    return i[F](e, n), e
  }),e("zrender", ["zrender/zrender"], function (t) {
    return t
  }),e("echarts", ["echarts/echarts"], function (t) {
    return t
  });
  var ke = t("echarts");
  return ke.graphic = t("echarts/util/graphic"), ke.number = t("echarts/util/number"), ke.format = t("echarts/util/format"), t("echarts/chart/bar"), t("echarts/chart/line"), t("echarts/chart/pie"), t("echarts/chart/radar"), t("echarts/component/grid"), t("echarts/component/title"), t("echarts/component/legend"), t("echarts/component/tooltip"), t("zrender/vml/vml"), ke
});
